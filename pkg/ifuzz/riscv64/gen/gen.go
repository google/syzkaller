// Copyright 2026 syzkaller project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

// gen generates riscv64 instruction tables from riscv-unified-db YAML.
// https://github.com/riscv-software-src/riscv-unified-db/tree/main/spec/std/isa/inst
package main

import (
	"bytes"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/google/syzkaller/pkg/ifuzz/riscv64"
	"github.com/google/syzkaller/pkg/osutil"
	"github.com/google/syzkaller/pkg/serializer"
	"github.com/google/syzkaller/pkg/tool"
)

type instYAML struct {
	Kind     string `yaml:"kind"`
	Name     string `yaml:"name"`
	Encoding struct {
		Match     string `yaml:"match"`
		Variables []struct {
			Name     string `yaml:"name"`
			Location string `yaml:"location"` // e.g. "24-20"
		} `yaml:"variables"`
	} `yaml:"encoding"`
	Access struct {
		U  string `yaml:"u"`
		VU string `yaml:"vu"`
	} `yaml:"access"`
}

func main() {
	if len(os.Args) != 3 {
		tool.Failf("usage: go run gen.go <riscv-unified-db/spec/std/isa/inst> <output.go>")
	}
	root := os.Args[1]
	outFile := os.Args[2]

	insns := []*riscv64.Insn{}

	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() || !strings.HasSuffix(path, ".yaml") {
			return nil
		}

		data, err := os.ReadFile(path)
		if err != nil {
			return nil
		}

		var inst instYAML
		if err := yaml.Unmarshal(data, &inst); err != nil {
			return nil
		}
		if inst.Kind != "instruction" {
			return nil
		}

		match := inst.Encoding.Match
		if len(match) != 32 {
			return nil
		}

		insn, ok := buildInsn(inst)
		if ok {
			insns = append(insns, insn)
		}
		return nil
	})
	if err != nil {
		tool.Fail(err)
	}

	var out bytes.Buffer
	fmt.Fprintf(&out, `// Code generated by pkg/ifuzz/riscv64/gen. DO NOT EDIT.

// go:build !codeanalysis

package generated

import (
	. "github.com/google/syzkaller/pkg/ifuzz/riscv64"
)

func init() {
	Register(insns_riscv64)
}

var insns_riscv64 = 
`)
	serializer.Write(&out, insns)

	if err := osutil.WriteFileAtomically(outFile, out.Bytes()); err != nil {
		tool.Fail(err)
	}

	fmt.Fprintf(os.Stderr, "generated %d instructions\n", len(insns))
}

func buildInsn(inst instYAML) (*riscv64.Insn, bool) {
	match := inst.Encoding.Match

	var opcode uint32
	var mask uint32

	for i, ch := range match {
		bit := uint(31 - i)
		switch ch {
		case '0':
			mask |= 1 << bit
		case '1':
			mask |= 1 << bit
			opcode |= 1 << bit
		case '-':
		default:
			return nil, false
		}
	}

	fields := []riscv64.InsnField{}
	for _, v := range inst.Encoding.Variables {
		subFields, ok := parseLocations(v.Name, v.Location)
		if !ok {
			return nil, false
		}
		fields = append(fields, subFields...)
	}

	priv := inst.Access.U == "never" || inst.Access.VU == "never"

	return &riscv64.Insn{
		Name:       inst.Name,
		OpcodeMask: mask,
		Opcode:     opcode,
		Fields:     fields,
		AsUInt32:   opcode,
		Generator:  nil,
		Priv:       priv,
	}, true
}

func parseLocations(name, loc string) ([]riscv64.InsnField, bool) {
	// Support multiple ranges separated by '|', e.g.:
	//   "31-25|11-7"
	ranges := strings.Split(loc, "|")
	fields := make([]riscv64.InsnField, 0, len(ranges))

	for _, r := range ranges {
		start, length, hi, lo, ok := parseRange(r)
		if !ok {
			return nil, false
		}

		fieldName := name
		if len(ranges) > 1 {
			fieldName = fmt.Sprintf("%s_%d_%d", name, hi, lo)
		}

		fields = append(fields, riscv64.InsnField{
			Name:   fieldName,
			Start:  start,
			Length: length,
		})
	}

	return fields, true
}

func parseRange(r string) (start, length, hi, lo uint, ok bool) {
	parts := strings.Split(r, "-")
	if len(parts) != 2 {
		return 0, 0, 0, 0, false
	}

	if _, err := fmt.Sscanf(parts[0], "%d", &hi); err != nil {
		return 0, 0, 0, 0, false
	}
	if _, err := fmt.Sscanf(parts[1], "%d", &lo); err != nil {
		return 0, 0, 0, 0, false
	}
	if hi < lo {
		return 0, 0, 0, 0, false
	}

	start = hi
	length = hi - lo + 1
	return start, length, hi, lo, true
}
