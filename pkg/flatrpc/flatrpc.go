// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flatrpc

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type Const uint64

const (
	ConstSnapshotDoorbellSize Const = 4096
	ConstMaxInputSize         Const = 4198400
	ConstMaxOutputSize        Const = 14680064
	ConstSnapshotShmemSize    Const = 33554432
)

var EnumNamesConst = map[Const]string{
	ConstSnapshotDoorbellSize: "SnapshotDoorbellSize",
	ConstMaxInputSize:         "MaxInputSize",
	ConstMaxOutputSize:        "MaxOutputSize",
	ConstSnapshotShmemSize:    "SnapshotShmemSize",
}

var EnumValuesConst = map[string]Const{
	"SnapshotDoorbellSize": ConstSnapshotDoorbellSize,
	"MaxInputSize":         ConstMaxInputSize,
	"MaxOutputSize":        ConstMaxOutputSize,
	"SnapshotShmemSize":    ConstSnapshotShmemSize,
}

func (v Const) String() string {
	if s, ok := EnumNamesConst[v]; ok {
		return s
	}
	return "Const(" + strconv.FormatInt(int64(v), 10) + ")"
}

type Feature uint64

const (
	FeatureCoverage         Feature = 1
	FeatureComparisons      Feature = 2
	FeatureExtraCoverage    Feature = 4
	FeatureDelayKcovMmap    Feature = 8
	FeatureSandboxNone      Feature = 16
	FeatureSandboxSetuid    Feature = 32
	FeatureSandboxNamespace Feature = 64
	FeatureSandboxAndroid   Feature = 128
	FeatureFault            Feature = 256
	FeatureLeak             Feature = 512
	FeatureNetInjection     Feature = 1024
	FeatureNetDevices       Feature = 2048
	FeatureKCSAN            Feature = 4096
	FeatureDevlinkPCI       Feature = 8192
	FeatureNicVF            Feature = 16384
	FeatureUSBEmulation     Feature = 32768
	FeatureVhciInjection    Feature = 65536
	FeatureWifiEmulation    Feature = 131072
	FeatureLRWPANEmulation  Feature = 262144
	FeatureBinFmtMisc       Feature = 524288
	FeatureSwap             Feature = 1048576
)

var EnumNamesFeature = map[Feature]string{
	FeatureCoverage:         "Coverage",
	FeatureComparisons:      "Comparisons",
	FeatureExtraCoverage:    "ExtraCoverage",
	FeatureDelayKcovMmap:    "DelayKcovMmap",
	FeatureSandboxNone:      "SandboxNone",
	FeatureSandboxSetuid:    "SandboxSetuid",
	FeatureSandboxNamespace: "SandboxNamespace",
	FeatureSandboxAndroid:   "SandboxAndroid",
	FeatureFault:            "Fault",
	FeatureLeak:             "Leak",
	FeatureNetInjection:     "NetInjection",
	FeatureNetDevices:       "NetDevices",
	FeatureKCSAN:            "KCSAN",
	FeatureDevlinkPCI:       "DevlinkPCI",
	FeatureNicVF:            "NicVF",
	FeatureUSBEmulation:     "USBEmulation",
	FeatureVhciInjection:    "VhciInjection",
	FeatureWifiEmulation:    "WifiEmulation",
	FeatureLRWPANEmulation:  "LRWPANEmulation",
	FeatureBinFmtMisc:       "BinFmtMisc",
	FeatureSwap:             "Swap",
}

var EnumValuesFeature = map[string]Feature{
	"Coverage":         FeatureCoverage,
	"Comparisons":      FeatureComparisons,
	"ExtraCoverage":    FeatureExtraCoverage,
	"DelayKcovMmap":    FeatureDelayKcovMmap,
	"SandboxNone":      FeatureSandboxNone,
	"SandboxSetuid":    FeatureSandboxSetuid,
	"SandboxNamespace": FeatureSandboxNamespace,
	"SandboxAndroid":   FeatureSandboxAndroid,
	"Fault":            FeatureFault,
	"Leak":             FeatureLeak,
	"NetInjection":     FeatureNetInjection,
	"NetDevices":       FeatureNetDevices,
	"KCSAN":            FeatureKCSAN,
	"DevlinkPCI":       FeatureDevlinkPCI,
	"NicVF":            FeatureNicVF,
	"USBEmulation":     FeatureUSBEmulation,
	"VhciInjection":    FeatureVhciInjection,
	"WifiEmulation":    FeatureWifiEmulation,
	"LRWPANEmulation":  FeatureLRWPANEmulation,
	"BinFmtMisc":       FeatureBinFmtMisc,
	"Swap":             FeatureSwap,
}

func (v Feature) String() string {
	if s, ok := EnumNamesFeature[v]; ok {
		return s
	}
	return "Feature(" + strconv.FormatInt(int64(v), 10) + ")"
}

type HostMessagesRaw byte

const (
	HostMessagesRawNONE          HostMessagesRaw = 0
	HostMessagesRawExecRequest   HostMessagesRaw = 1
	HostMessagesRawSignalUpdate  HostMessagesRaw = 2
	HostMessagesRawCorpusTriaged HostMessagesRaw = 3
	HostMessagesRawStateRequest  HostMessagesRaw = 4
)

var EnumNamesHostMessagesRaw = map[HostMessagesRaw]string{
	HostMessagesRawNONE:          "NONE",
	HostMessagesRawExecRequest:   "ExecRequest",
	HostMessagesRawSignalUpdate:  "SignalUpdate",
	HostMessagesRawCorpusTriaged: "CorpusTriaged",
	HostMessagesRawStateRequest:  "StateRequest",
}

var EnumValuesHostMessagesRaw = map[string]HostMessagesRaw{
	"NONE":          HostMessagesRawNONE,
	"ExecRequest":   HostMessagesRawExecRequest,
	"SignalUpdate":  HostMessagesRawSignalUpdate,
	"CorpusTriaged": HostMessagesRawCorpusTriaged,
	"StateRequest":  HostMessagesRawStateRequest,
}

func (v HostMessagesRaw) String() string {
	if s, ok := EnumNamesHostMessagesRaw[v]; ok {
		return s
	}
	return "HostMessagesRaw(" + strconv.FormatInt(int64(v), 10) + ")"
}

type HostMessagesRawT struct {
	Type  HostMessagesRaw
	Value interface{}
}

func (t *HostMessagesRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case HostMessagesRawExecRequest:
		return t.Value.(*ExecRequestRawT).Pack(builder)
	case HostMessagesRawSignalUpdate:
		return t.Value.(*SignalUpdateRawT).Pack(builder)
	case HostMessagesRawCorpusTriaged:
		return t.Value.(*CorpusTriagedRawT).Pack(builder)
	case HostMessagesRawStateRequest:
		return t.Value.(*StateRequestRawT).Pack(builder)
	}
	return 0
}

func (rcv HostMessagesRaw) UnPack(table flatbuffers.Table) *HostMessagesRawT {
	switch rcv {
	case HostMessagesRawExecRequest:
		x := ExecRequestRaw{_tab: table}
		return &HostMessagesRawT{Type: HostMessagesRawExecRequest, Value: x.UnPack()}
	case HostMessagesRawSignalUpdate:
		x := SignalUpdateRaw{_tab: table}
		return &HostMessagesRawT{Type: HostMessagesRawSignalUpdate, Value: x.UnPack()}
	case HostMessagesRawCorpusTriaged:
		x := CorpusTriagedRaw{_tab: table}
		return &HostMessagesRawT{Type: HostMessagesRawCorpusTriaged, Value: x.UnPack()}
	case HostMessagesRawStateRequest:
		x := StateRequestRaw{_tab: table}
		return &HostMessagesRawT{Type: HostMessagesRawStateRequest, Value: x.UnPack()}
	}
	return nil
}

type ExecutorMessagesRaw byte

const (
	ExecutorMessagesRawNONE       ExecutorMessagesRaw = 0
	ExecutorMessagesRawExecResult ExecutorMessagesRaw = 1
	ExecutorMessagesRawExecuting  ExecutorMessagesRaw = 2
	ExecutorMessagesRawState      ExecutorMessagesRaw = 3
)

var EnumNamesExecutorMessagesRaw = map[ExecutorMessagesRaw]string{
	ExecutorMessagesRawNONE:       "NONE",
	ExecutorMessagesRawExecResult: "ExecResult",
	ExecutorMessagesRawExecuting:  "Executing",
	ExecutorMessagesRawState:      "State",
}

var EnumValuesExecutorMessagesRaw = map[string]ExecutorMessagesRaw{
	"NONE":       ExecutorMessagesRawNONE,
	"ExecResult": ExecutorMessagesRawExecResult,
	"Executing":  ExecutorMessagesRawExecuting,
	"State":      ExecutorMessagesRawState,
}

func (v ExecutorMessagesRaw) String() string {
	if s, ok := EnumNamesExecutorMessagesRaw[v]; ok {
		return s
	}
	return "ExecutorMessagesRaw(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecutorMessagesRawT struct {
	Type  ExecutorMessagesRaw
	Value interface{}
}

func (t *ExecutorMessagesRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case ExecutorMessagesRawExecResult:
		return t.Value.(*ExecResultRawT).Pack(builder)
	case ExecutorMessagesRawExecuting:
		return t.Value.(*ExecutingMessageRawT).Pack(builder)
	case ExecutorMessagesRawState:
		return t.Value.(*StateResultRawT).Pack(builder)
	}
	return 0
}

func (rcv ExecutorMessagesRaw) UnPack(table flatbuffers.Table) *ExecutorMessagesRawT {
	switch rcv {
	case ExecutorMessagesRawExecResult:
		x := ExecResultRaw{_tab: table}
		return &ExecutorMessagesRawT{Type: ExecutorMessagesRawExecResult, Value: x.UnPack()}
	case ExecutorMessagesRawExecuting:
		x := ExecutingMessageRaw{_tab: table}
		return &ExecutorMessagesRawT{Type: ExecutorMessagesRawExecuting, Value: x.UnPack()}
	case ExecutorMessagesRawState:
		x := StateResultRaw{_tab: table}
		return &ExecutorMessagesRawT{Type: ExecutorMessagesRawState, Value: x.UnPack()}
	}
	return nil
}

type RequestFlag uint64

const (
	RequestFlagIsBinary     RequestFlag = 1
	RequestFlagReturnOutput RequestFlag = 2
	RequestFlagReturnError  RequestFlag = 4
)

var EnumNamesRequestFlag = map[RequestFlag]string{
	RequestFlagIsBinary:     "IsBinary",
	RequestFlagReturnOutput: "ReturnOutput",
	RequestFlagReturnError:  "ReturnError",
}

var EnumValuesRequestFlag = map[string]RequestFlag{
	"IsBinary":     RequestFlagIsBinary,
	"ReturnOutput": RequestFlagReturnOutput,
	"ReturnError":  RequestFlagReturnError,
}

func (v RequestFlag) String() string {
	if s, ok := EnumNamesRequestFlag[v]; ok {
		return s
	}
	return "RequestFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecEnv uint64

const (
	ExecEnvDebug               ExecEnv = 1
	ExecEnvSignal              ExecEnv = 2
	ExecEnvResetState          ExecEnv = 4
	ExecEnvSandboxNone         ExecEnv = 8
	ExecEnvSandboxSetuid       ExecEnv = 16
	ExecEnvSandboxNamespace    ExecEnv = 32
	ExecEnvSandboxAndroid      ExecEnv = 64
	ExecEnvExtraCover          ExecEnv = 128
	ExecEnvEnableTun           ExecEnv = 256
	ExecEnvEnableNetDev        ExecEnv = 512
	ExecEnvEnableNetReset      ExecEnv = 1024
	ExecEnvEnableCgroups       ExecEnv = 2048
	ExecEnvEnableCloseFds      ExecEnv = 4096
	ExecEnvEnableDevlinkPCI    ExecEnv = 8192
	ExecEnvEnableVhciInjection ExecEnv = 16384
	ExecEnvEnableWifi          ExecEnv = 32768
	ExecEnvDelayKcovMmap       ExecEnv = 65536
	ExecEnvEnableNicVF         ExecEnv = 131072
)

var EnumNamesExecEnv = map[ExecEnv]string{
	ExecEnvDebug:               "Debug",
	ExecEnvSignal:              "Signal",
	ExecEnvResetState:          "ResetState",
	ExecEnvSandboxNone:         "SandboxNone",
	ExecEnvSandboxSetuid:       "SandboxSetuid",
	ExecEnvSandboxNamespace:    "SandboxNamespace",
	ExecEnvSandboxAndroid:      "SandboxAndroid",
	ExecEnvExtraCover:          "ExtraCover",
	ExecEnvEnableTun:           "EnableTun",
	ExecEnvEnableNetDev:        "EnableNetDev",
	ExecEnvEnableNetReset:      "EnableNetReset",
	ExecEnvEnableCgroups:       "EnableCgroups",
	ExecEnvEnableCloseFds:      "EnableCloseFds",
	ExecEnvEnableDevlinkPCI:    "EnableDevlinkPCI",
	ExecEnvEnableVhciInjection: "EnableVhciInjection",
	ExecEnvEnableWifi:          "EnableWifi",
	ExecEnvDelayKcovMmap:       "DelayKcovMmap",
	ExecEnvEnableNicVF:         "EnableNicVF",
}

var EnumValuesExecEnv = map[string]ExecEnv{
	"Debug":               ExecEnvDebug,
	"Signal":              ExecEnvSignal,
	"ResetState":          ExecEnvResetState,
	"SandboxNone":         ExecEnvSandboxNone,
	"SandboxSetuid":       ExecEnvSandboxSetuid,
	"SandboxNamespace":    ExecEnvSandboxNamespace,
	"SandboxAndroid":      ExecEnvSandboxAndroid,
	"ExtraCover":          ExecEnvExtraCover,
	"EnableTun":           ExecEnvEnableTun,
	"EnableNetDev":        ExecEnvEnableNetDev,
	"EnableNetReset":      ExecEnvEnableNetReset,
	"EnableCgroups":       ExecEnvEnableCgroups,
	"EnableCloseFds":      ExecEnvEnableCloseFds,
	"EnableDevlinkPCI":    ExecEnvEnableDevlinkPCI,
	"EnableVhciInjection": ExecEnvEnableVhciInjection,
	"EnableWifi":          ExecEnvEnableWifi,
	"DelayKcovMmap":       ExecEnvDelayKcovMmap,
	"EnableNicVF":         ExecEnvEnableNicVF,
}

func (v ExecEnv) String() string {
	if s, ok := EnumNamesExecEnv[v]; ok {
		return s
	}
	return "ExecEnv(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecFlag uint64

const (
	ExecFlagCollectSignal ExecFlag = 1
	ExecFlagCollectCover  ExecFlag = 2
	ExecFlagDedupCover    ExecFlag = 4
	ExecFlagCollectComps  ExecFlag = 8
	ExecFlagThreaded      ExecFlag = 16
)

var EnumNamesExecFlag = map[ExecFlag]string{
	ExecFlagCollectSignal: "CollectSignal",
	ExecFlagCollectCover:  "CollectCover",
	ExecFlagDedupCover:    "DedupCover",
	ExecFlagCollectComps:  "CollectComps",
	ExecFlagThreaded:      "Threaded",
}

var EnumValuesExecFlag = map[string]ExecFlag{
	"CollectSignal": ExecFlagCollectSignal,
	"CollectCover":  ExecFlagCollectCover,
	"DedupCover":    ExecFlagDedupCover,
	"CollectComps":  ExecFlagCollectComps,
	"Threaded":      ExecFlagThreaded,
}

func (v ExecFlag) String() string {
	if s, ok := EnumNamesExecFlag[v]; ok {
		return s
	}
	return "ExecFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type CallFlag byte

const (
	CallFlagExecuted      CallFlag = 1
	CallFlagFinished      CallFlag = 2
	CallFlagBlocked       CallFlag = 4
	CallFlagFaultInjected CallFlag = 8
)

var EnumNamesCallFlag = map[CallFlag]string{
	CallFlagExecuted:      "Executed",
	CallFlagFinished:      "Finished",
	CallFlagBlocked:       "Blocked",
	CallFlagFaultInjected: "FaultInjected",
}

var EnumValuesCallFlag = map[string]CallFlag{
	"Executed":      CallFlagExecuted,
	"Finished":      CallFlagFinished,
	"Blocked":       CallFlagBlocked,
	"FaultInjected": CallFlagFaultInjected,
}

func (v CallFlag) String() string {
	if s, ok := EnumNamesCallFlag[v]; ok {
		return s
	}
	return "CallFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type SnapshotState uint64

const (
	SnapshotStateInitial     SnapshotState = 0
	SnapshotStateHandshake   SnapshotState = 1
	SnapshotStateReady       SnapshotState = 2
	SnapshotStateSnapshotted SnapshotState = 3
	SnapshotStateExecute     SnapshotState = 4
	SnapshotStateExecuted    SnapshotState = 5
	SnapshotStateFailed      SnapshotState = 6
)

var EnumNamesSnapshotState = map[SnapshotState]string{
	SnapshotStateInitial:     "Initial",
	SnapshotStateHandshake:   "Handshake",
	SnapshotStateReady:       "Ready",
	SnapshotStateSnapshotted: "Snapshotted",
	SnapshotStateExecute:     "Execute",
	SnapshotStateExecuted:    "Executed",
	SnapshotStateFailed:      "Failed",
}

var EnumValuesSnapshotState = map[string]SnapshotState{
	"Initial":     SnapshotStateInitial,
	"Handshake":   SnapshotStateHandshake,
	"Ready":       SnapshotStateReady,
	"Snapshotted": SnapshotStateSnapshotted,
	"Execute":     SnapshotStateExecute,
	"Executed":    SnapshotStateExecuted,
	"Failed":      SnapshotStateFailed,
}

func (v SnapshotState) String() string {
	if s, ok := EnumNamesSnapshotState[v]; ok {
		return s
	}
	return "SnapshotState(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ConnectRequestRawT struct {
	Name        string `json:"name"`
	Arch        string `json:"arch"`
	GitRevision string `json:"git_revision"`
	SyzRevision string `json:"syz_revision"`
}

func (t *ConnectRequestRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	archOffset := builder.CreateString(t.Arch)
	gitRevisionOffset := builder.CreateString(t.GitRevision)
	syzRevisionOffset := builder.CreateString(t.SyzRevision)
	ConnectRequestRawStart(builder)
	ConnectRequestRawAddName(builder, nameOffset)
	ConnectRequestRawAddArch(builder, archOffset)
	ConnectRequestRawAddGitRevision(builder, gitRevisionOffset)
	ConnectRequestRawAddSyzRevision(builder, syzRevisionOffset)
	return ConnectRequestRawEnd(builder)
}

func (rcv *ConnectRequestRaw) UnPackTo(t *ConnectRequestRawT) {
	t.Name = string(rcv.Name())
	t.Arch = string(rcv.Arch())
	t.GitRevision = string(rcv.GitRevision())
	t.SyzRevision = string(rcv.SyzRevision())
}

func (rcv *ConnectRequestRaw) UnPack() *ConnectRequestRawT {
	if rcv == nil {
		return nil
	}
	t := &ConnectRequestRawT{}
	rcv.UnPackTo(t)
	return t
}

type ConnectRequestRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsConnectRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *ConnectRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ConnectRequestRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsConnectRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *ConnectRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ConnectRequestRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ConnectRequestRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ConnectRequestRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ConnectRequestRaw) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequestRaw) Arch() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequestRaw) GitRevision() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequestRaw) SyzRevision() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ConnectRequestRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ConnectRequestRawAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func ConnectRequestRawAddArch(builder *flatbuffers.Builder, arch flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(arch), 0)
}
func ConnectRequestRawAddGitRevision(builder *flatbuffers.Builder, gitRevision flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(gitRevision), 0)
}
func ConnectRequestRawAddSyzRevision(builder *flatbuffers.Builder, syzRevision flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(syzRevision), 0)
}
func ConnectRequestRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ConnectReplyRawT struct {
	Debug            bool     `json:"debug"`
	Cover            bool     `json:"cover"`
	CoverEdges       bool     `json:"cover_edges"`
	Kernel64Bit      bool     `json:"kernel_64_bit"`
	Procs            int32    `json:"procs"`
	Slowdown         int32    `json:"slowdown"`
	SyscallTimeoutMs int32    `json:"syscall_timeout_ms"`
	ProgramTimeoutMs int32    `json:"program_timeout_ms"`
	LeakFrames       []string `json:"leak_frames"`
	RaceFrames       []string `json:"race_frames"`
	Features         Feature  `json:"features"`
	Files            []string `json:"files"`
	Globs            []string `json:"globs"`
}

func (t *ConnectReplyRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	leakFramesOffset := flatbuffers.UOffsetT(0)
	if t.LeakFrames != nil {
		leakFramesLength := len(t.LeakFrames)
		leakFramesOffsets := make([]flatbuffers.UOffsetT, leakFramesLength)
		for j := 0; j < leakFramesLength; j++ {
			leakFramesOffsets[j] = builder.CreateString(t.LeakFrames[j])
		}
		ConnectReplyRawStartLeakFramesVector(builder, leakFramesLength)
		for j := leakFramesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(leakFramesOffsets[j])
		}
		leakFramesOffset = builder.EndVector(leakFramesLength)
	}
	raceFramesOffset := flatbuffers.UOffsetT(0)
	if t.RaceFrames != nil {
		raceFramesLength := len(t.RaceFrames)
		raceFramesOffsets := make([]flatbuffers.UOffsetT, raceFramesLength)
		for j := 0; j < raceFramesLength; j++ {
			raceFramesOffsets[j] = builder.CreateString(t.RaceFrames[j])
		}
		ConnectReplyRawStartRaceFramesVector(builder, raceFramesLength)
		for j := raceFramesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(raceFramesOffsets[j])
		}
		raceFramesOffset = builder.EndVector(raceFramesLength)
	}
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = builder.CreateString(t.Files[j])
		}
		ConnectReplyRawStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	globsOffset := flatbuffers.UOffsetT(0)
	if t.Globs != nil {
		globsLength := len(t.Globs)
		globsOffsets := make([]flatbuffers.UOffsetT, globsLength)
		for j := 0; j < globsLength; j++ {
			globsOffsets[j] = builder.CreateString(t.Globs[j])
		}
		ConnectReplyRawStartGlobsVector(builder, globsLength)
		for j := globsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(globsOffsets[j])
		}
		globsOffset = builder.EndVector(globsLength)
	}
	ConnectReplyRawStart(builder)
	ConnectReplyRawAddDebug(builder, t.Debug)
	ConnectReplyRawAddCover(builder, t.Cover)
	ConnectReplyRawAddCoverEdges(builder, t.CoverEdges)
	ConnectReplyRawAddKernel64Bit(builder, t.Kernel64Bit)
	ConnectReplyRawAddProcs(builder, t.Procs)
	ConnectReplyRawAddSlowdown(builder, t.Slowdown)
	ConnectReplyRawAddSyscallTimeoutMs(builder, t.SyscallTimeoutMs)
	ConnectReplyRawAddProgramTimeoutMs(builder, t.ProgramTimeoutMs)
	ConnectReplyRawAddLeakFrames(builder, leakFramesOffset)
	ConnectReplyRawAddRaceFrames(builder, raceFramesOffset)
	ConnectReplyRawAddFeatures(builder, t.Features)
	ConnectReplyRawAddFiles(builder, filesOffset)
	ConnectReplyRawAddGlobs(builder, globsOffset)
	return ConnectReplyRawEnd(builder)
}

func (rcv *ConnectReplyRaw) UnPackTo(t *ConnectReplyRawT) {
	t.Debug = rcv.Debug()
	t.Cover = rcv.Cover()
	t.CoverEdges = rcv.CoverEdges()
	t.Kernel64Bit = rcv.Kernel64Bit()
	t.Procs = rcv.Procs()
	t.Slowdown = rcv.Slowdown()
	t.SyscallTimeoutMs = rcv.SyscallTimeoutMs()
	t.ProgramTimeoutMs = rcv.ProgramTimeoutMs()
	leakFramesLength := rcv.LeakFramesLength()
	t.LeakFrames = make([]string, leakFramesLength)
	for j := 0; j < leakFramesLength; j++ {
		t.LeakFrames[j] = string(rcv.LeakFrames(j))
	}
	raceFramesLength := rcv.RaceFramesLength()
	t.RaceFrames = make([]string, raceFramesLength)
	for j := 0; j < raceFramesLength; j++ {
		t.RaceFrames[j] = string(rcv.RaceFrames(j))
	}
	t.Features = rcv.Features()
	filesLength := rcv.FilesLength()
	t.Files = make([]string, filesLength)
	for j := 0; j < filesLength; j++ {
		t.Files[j] = string(rcv.Files(j))
	}
	globsLength := rcv.GlobsLength()
	t.Globs = make([]string, globsLength)
	for j := 0; j < globsLength; j++ {
		t.Globs[j] = string(rcv.Globs(j))
	}
}

func (rcv *ConnectReplyRaw) UnPack() *ConnectReplyRawT {
	if rcv == nil {
		return nil
	}
	t := &ConnectReplyRawT{}
	rcv.UnPackTo(t)
	return t
}

type ConnectReplyRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsConnectReplyRaw(buf []byte, offset flatbuffers.UOffsetT) *ConnectReplyRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ConnectReplyRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsConnectReplyRaw(buf []byte, offset flatbuffers.UOffsetT) *ConnectReplyRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ConnectReplyRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ConnectReplyRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ConnectReplyRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ConnectReplyRaw) Debug() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ConnectReplyRaw) MutateDebug(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

func (rcv *ConnectReplyRaw) Cover() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ConnectReplyRaw) MutateCover(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *ConnectReplyRaw) CoverEdges() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ConnectReplyRaw) MutateCoverEdges(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

func (rcv *ConnectReplyRaw) Kernel64Bit() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ConnectReplyRaw) MutateKernel64Bit(n bool) bool {
	return rcv._tab.MutateBoolSlot(10, n)
}

func (rcv *ConnectReplyRaw) Procs() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ConnectReplyRaw) MutateProcs(n int32) bool {
	return rcv._tab.MutateInt32Slot(12, n)
}

func (rcv *ConnectReplyRaw) Slowdown() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ConnectReplyRaw) MutateSlowdown(n int32) bool {
	return rcv._tab.MutateInt32Slot(14, n)
}

func (rcv *ConnectReplyRaw) SyscallTimeoutMs() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ConnectReplyRaw) MutateSyscallTimeoutMs(n int32) bool {
	return rcv._tab.MutateInt32Slot(16, n)
}

func (rcv *ConnectReplyRaw) ProgramTimeoutMs() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ConnectReplyRaw) MutateProgramTimeoutMs(n int32) bool {
	return rcv._tab.MutateInt32Slot(18, n)
}

func (rcv *ConnectReplyRaw) LeakFrames(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReplyRaw) LeakFramesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReplyRaw) RaceFrames(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReplyRaw) RaceFramesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReplyRaw) Features() Feature {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return Feature(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ConnectReplyRaw) MutateFeatures(n Feature) bool {
	return rcv._tab.MutateUint64Slot(24, uint64(n))
}

func (rcv *ConnectReplyRaw) Files(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReplyRaw) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReplyRaw) Globs(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReplyRaw) GlobsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ConnectReplyRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(13)
}
func ConnectReplyRawAddDebug(builder *flatbuffers.Builder, debug bool) {
	builder.PrependBoolSlot(0, debug, false)
}
func ConnectReplyRawAddCover(builder *flatbuffers.Builder, cover bool) {
	builder.PrependBoolSlot(1, cover, false)
}
func ConnectReplyRawAddCoverEdges(builder *flatbuffers.Builder, coverEdges bool) {
	builder.PrependBoolSlot(2, coverEdges, false)
}
func ConnectReplyRawAddKernel64Bit(builder *flatbuffers.Builder, kernel64Bit bool) {
	builder.PrependBoolSlot(3, kernel64Bit, false)
}
func ConnectReplyRawAddProcs(builder *flatbuffers.Builder, procs int32) {
	builder.PrependInt32Slot(4, procs, 0)
}
func ConnectReplyRawAddSlowdown(builder *flatbuffers.Builder, slowdown int32) {
	builder.PrependInt32Slot(5, slowdown, 0)
}
func ConnectReplyRawAddSyscallTimeoutMs(builder *flatbuffers.Builder, syscallTimeoutMs int32) {
	builder.PrependInt32Slot(6, syscallTimeoutMs, 0)
}
func ConnectReplyRawAddProgramTimeoutMs(builder *flatbuffers.Builder, programTimeoutMs int32) {
	builder.PrependInt32Slot(7, programTimeoutMs, 0)
}
func ConnectReplyRawAddLeakFrames(builder *flatbuffers.Builder, leakFrames flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(leakFrames), 0)
}
func ConnectReplyRawStartLeakFramesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyRawAddRaceFrames(builder *flatbuffers.Builder, raceFrames flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(raceFrames), 0)
}
func ConnectReplyRawStartRaceFramesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyRawAddFeatures(builder *flatbuffers.Builder, features Feature) {
	builder.PrependUint64Slot(10, uint64(features), 0)
}
func ConnectReplyRawAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(files), 0)
}
func ConnectReplyRawStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyRawAddGlobs(builder *flatbuffers.Builder, globs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(globs), 0)
}
func ConnectReplyRawStartGlobsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type InfoRequestRawT struct {
	Error    string             `json:"error"`
	Features []*FeatureInfoRawT `json:"features"`
	Files    []*FileInfoRawT    `json:"files"`
	Globs    []*GlobInfoRawT    `json:"globs"`
}

func (t *InfoRequestRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	errorOffset := builder.CreateString(t.Error)
	featuresOffset := flatbuffers.UOffsetT(0)
	if t.Features != nil {
		featuresLength := len(t.Features)
		featuresOffsets := make([]flatbuffers.UOffsetT, featuresLength)
		for j := 0; j < featuresLength; j++ {
			featuresOffsets[j] = t.Features[j].Pack(builder)
		}
		InfoRequestRawStartFeaturesVector(builder, featuresLength)
		for j := featuresLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(featuresOffsets[j])
		}
		featuresOffset = builder.EndVector(featuresLength)
	}
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = t.Files[j].Pack(builder)
		}
		InfoRequestRawStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	globsOffset := flatbuffers.UOffsetT(0)
	if t.Globs != nil {
		globsLength := len(t.Globs)
		globsOffsets := make([]flatbuffers.UOffsetT, globsLength)
		for j := 0; j < globsLength; j++ {
			globsOffsets[j] = t.Globs[j].Pack(builder)
		}
		InfoRequestRawStartGlobsVector(builder, globsLength)
		for j := globsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(globsOffsets[j])
		}
		globsOffset = builder.EndVector(globsLength)
	}
	InfoRequestRawStart(builder)
	InfoRequestRawAddError(builder, errorOffset)
	InfoRequestRawAddFeatures(builder, featuresOffset)
	InfoRequestRawAddFiles(builder, filesOffset)
	InfoRequestRawAddGlobs(builder, globsOffset)
	return InfoRequestRawEnd(builder)
}

func (rcv *InfoRequestRaw) UnPackTo(t *InfoRequestRawT) {
	t.Error = string(rcv.Error())
	featuresLength := rcv.FeaturesLength()
	t.Features = make([]*FeatureInfoRawT, featuresLength)
	for j := 0; j < featuresLength; j++ {
		x := FeatureInfoRaw{}
		rcv.Features(&x, j)
		t.Features[j] = x.UnPack()
	}
	filesLength := rcv.FilesLength()
	t.Files = make([]*FileInfoRawT, filesLength)
	for j := 0; j < filesLength; j++ {
		x := FileInfoRaw{}
		rcv.Files(&x, j)
		t.Files[j] = x.UnPack()
	}
	globsLength := rcv.GlobsLength()
	t.Globs = make([]*GlobInfoRawT, globsLength)
	for j := 0; j < globsLength; j++ {
		x := GlobInfoRaw{}
		rcv.Globs(&x, j)
		t.Globs[j] = x.UnPack()
	}
}

func (rcv *InfoRequestRaw) UnPack() *InfoRequestRawT {
	if rcv == nil {
		return nil
	}
	t := &InfoRequestRawT{}
	rcv.UnPackTo(t)
	return t
}

type InfoRequestRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsInfoRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *InfoRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &InfoRequestRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsInfoRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *InfoRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &InfoRequestRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *InfoRequestRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *InfoRequestRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *InfoRequestRaw) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *InfoRequestRaw) Features(obj *FeatureInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *InfoRequestRaw) FeaturesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *InfoRequestRaw) Files(obj *FileInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *InfoRequestRaw) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *InfoRequestRaw) Globs(obj *GlobInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *InfoRequestRaw) GlobsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func InfoRequestRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func InfoRequestRawAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(error), 0)
}
func InfoRequestRawAddFeatures(builder *flatbuffers.Builder, features flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(features), 0)
}
func InfoRequestRawStartFeaturesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoRequestRawAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(files), 0)
}
func InfoRequestRawStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoRequestRawAddGlobs(builder *flatbuffers.Builder, globs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(globs), 0)
}
func InfoRequestRawStartGlobsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoRequestRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type InfoReplyRawT struct {
	CoverFilter []uint64 `json:"cover_filter"`
}

func (t *InfoReplyRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	coverFilterOffset := flatbuffers.UOffsetT(0)
	if t.CoverFilter != nil {
		coverFilterLength := len(t.CoverFilter)
		InfoReplyRawStartCoverFilterVector(builder, coverFilterLength)
		for j := coverFilterLength - 1; j >= 0; j-- {
			builder.PrependUint64(t.CoverFilter[j])
		}
		coverFilterOffset = builder.EndVector(coverFilterLength)
	}
	InfoReplyRawStart(builder)
	InfoReplyRawAddCoverFilter(builder, coverFilterOffset)
	return InfoReplyRawEnd(builder)
}

func (rcv *InfoReplyRaw) UnPackTo(t *InfoReplyRawT) {
	coverFilterLength := rcv.CoverFilterLength()
	t.CoverFilter = make([]uint64, coverFilterLength)
	for j := 0; j < coverFilterLength; j++ {
		t.CoverFilter[j] = rcv.CoverFilter(j)
	}
}

func (rcv *InfoReplyRaw) UnPack() *InfoReplyRawT {
	if rcv == nil {
		return nil
	}
	t := &InfoReplyRawT{}
	rcv.UnPackTo(t)
	return t
}

type InfoReplyRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsInfoReplyRaw(buf []byte, offset flatbuffers.UOffsetT) *InfoReplyRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &InfoReplyRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsInfoReplyRaw(buf []byte, offset flatbuffers.UOffsetT) *InfoReplyRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &InfoReplyRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *InfoReplyRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *InfoReplyRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *InfoReplyRaw) CoverFilter(j int) uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *InfoReplyRaw) CoverFilterLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *InfoReplyRaw) MutateCoverFilter(j int, n uint64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func InfoReplyRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func InfoReplyRawAddCoverFilter(builder *flatbuffers.Builder, coverFilter flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(coverFilter), 0)
}
func InfoReplyRawStartCoverFilterVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func InfoReplyRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FileInfoRawT struct {
	Name   string `json:"name"`
	Exists bool   `json:"exists"`
	Error  string `json:"error"`
	Data   []byte `json:"data"`
}

func (t *FileInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	errorOffset := builder.CreateString(t.Error)
	dataOffset := flatbuffers.UOffsetT(0)
	if t.Data != nil {
		dataOffset = builder.CreateByteString(t.Data)
	}
	FileInfoRawStart(builder)
	FileInfoRawAddName(builder, nameOffset)
	FileInfoRawAddExists(builder, t.Exists)
	FileInfoRawAddError(builder, errorOffset)
	FileInfoRawAddData(builder, dataOffset)
	return FileInfoRawEnd(builder)
}

func (rcv *FileInfoRaw) UnPackTo(t *FileInfoRawT) {
	t.Name = string(rcv.Name())
	t.Exists = rcv.Exists()
	t.Error = string(rcv.Error())
	t.Data = rcv.DataBytes()
}

func (rcv *FileInfoRaw) UnPack() *FileInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &FileInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type FileInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsFileInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *FileInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FileInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFileInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *FileInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FileInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FileInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FileInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FileInfoRaw) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfoRaw) Exists() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *FileInfoRaw) MutateExists(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *FileInfoRaw) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfoRaw) Data(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *FileInfoRaw) DataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *FileInfoRaw) DataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfoRaw) MutateData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func FileInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func FileInfoRawAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func FileInfoRawAddExists(builder *flatbuffers.Builder, exists bool) {
	builder.PrependBoolSlot(1, exists, false)
}
func FileInfoRawAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(error), 0)
}
func FileInfoRawAddData(builder *flatbuffers.Builder, data flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(data), 0)
}
func FileInfoRawStartDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func FileInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type GlobInfoRawT struct {
	Name  string   `json:"name"`
	Files []string `json:"files"`
}

func (t *GlobInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = builder.CreateString(t.Files[j])
		}
		GlobInfoRawStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	GlobInfoRawStart(builder)
	GlobInfoRawAddName(builder, nameOffset)
	GlobInfoRawAddFiles(builder, filesOffset)
	return GlobInfoRawEnd(builder)
}

func (rcv *GlobInfoRaw) UnPackTo(t *GlobInfoRawT) {
	t.Name = string(rcv.Name())
	filesLength := rcv.FilesLength()
	t.Files = make([]string, filesLength)
	for j := 0; j < filesLength; j++ {
		t.Files[j] = string(rcv.Files(j))
	}
}

func (rcv *GlobInfoRaw) UnPack() *GlobInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &GlobInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type GlobInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsGlobInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *GlobInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GlobInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsGlobInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *GlobInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &GlobInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *GlobInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GlobInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GlobInfoRaw) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GlobInfoRaw) Files(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *GlobInfoRaw) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func GlobInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func GlobInfoRawAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func GlobInfoRawAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(files), 0)
}
func GlobInfoRawStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GlobInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FeatureInfoRawT struct {
	Id        Feature `json:"id"`
	NeedSetup bool    `json:"need_setup"`
	Reason    string  `json:"reason"`
}

func (t *FeatureInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	reasonOffset := builder.CreateString(t.Reason)
	FeatureInfoRawStart(builder)
	FeatureInfoRawAddId(builder, t.Id)
	FeatureInfoRawAddNeedSetup(builder, t.NeedSetup)
	FeatureInfoRawAddReason(builder, reasonOffset)
	return FeatureInfoRawEnd(builder)
}

func (rcv *FeatureInfoRaw) UnPackTo(t *FeatureInfoRawT) {
	t.Id = rcv.Id()
	t.NeedSetup = rcv.NeedSetup()
	t.Reason = string(rcv.Reason())
}

func (rcv *FeatureInfoRaw) UnPack() *FeatureInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &FeatureInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type FeatureInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsFeatureInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *FeatureInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FeatureInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFeatureInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *FeatureInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FeatureInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FeatureInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FeatureInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FeatureInfoRaw) Id() Feature {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Feature(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *FeatureInfoRaw) MutateId(n Feature) bool {
	return rcv._tab.MutateUint64Slot(4, uint64(n))
}

func (rcv *FeatureInfoRaw) NeedSetup() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *FeatureInfoRaw) MutateNeedSetup(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *FeatureInfoRaw) Reason() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func FeatureInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func FeatureInfoRawAddId(builder *flatbuffers.Builder, id Feature) {
	builder.PrependUint64Slot(0, uint64(id), 0)
}
func FeatureInfoRawAddNeedSetup(builder *flatbuffers.Builder, needSetup bool) {
	builder.PrependBoolSlot(1, needSetup, false)
}
func FeatureInfoRawAddReason(builder *flatbuffers.Builder, reason flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(reason), 0)
}
func FeatureInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type HostMessageRawT struct {
	Msg *HostMessagesRawT `json:"msg"`
}

func (t *HostMessageRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	msgOffset := t.Msg.Pack(builder)

	HostMessageRawStart(builder)
	if t.Msg != nil {
		HostMessageRawAddMsgType(builder, t.Msg.Type)
	}
	HostMessageRawAddMsg(builder, msgOffset)
	return HostMessageRawEnd(builder)
}

func (rcv *HostMessageRaw) UnPackTo(t *HostMessageRawT) {
	msgTable := flatbuffers.Table{}
	if rcv.Msg(&msgTable) {
		t.Msg = rcv.MsgType().UnPack(msgTable)
	}
}

func (rcv *HostMessageRaw) UnPack() *HostMessageRawT {
	if rcv == nil {
		return nil
	}
	t := &HostMessageRawT{}
	rcv.UnPackTo(t)
	return t
}

type HostMessageRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsHostMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *HostMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &HostMessageRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsHostMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *HostMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &HostMessageRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *HostMessageRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *HostMessageRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *HostMessageRaw) MsgType() HostMessagesRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return HostMessagesRaw(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *HostMessageRaw) MutateMsgType(n HostMessagesRaw) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *HostMessageRaw) Msg(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func HostMessageRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func HostMessageRawAddMsgType(builder *flatbuffers.Builder, msgType HostMessagesRaw) {
	builder.PrependByteSlot(0, byte(msgType), 0)
}
func HostMessageRawAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func HostMessageRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecutorMessageRawT struct {
	Msg *ExecutorMessagesRawT `json:"msg"`
}

func (t *ExecutorMessageRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	msgOffset := t.Msg.Pack(builder)

	ExecutorMessageRawStart(builder)
	if t.Msg != nil {
		ExecutorMessageRawAddMsgType(builder, t.Msg.Type)
	}
	ExecutorMessageRawAddMsg(builder, msgOffset)
	return ExecutorMessageRawEnd(builder)
}

func (rcv *ExecutorMessageRaw) UnPackTo(t *ExecutorMessageRawT) {
	msgTable := flatbuffers.Table{}
	if rcv.Msg(&msgTable) {
		t.Msg = rcv.MsgType().UnPack(msgTable)
	}
}

func (rcv *ExecutorMessageRaw) UnPack() *ExecutorMessageRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecutorMessageRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecutorMessageRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsExecutorMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecutorMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecutorMessageRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecutorMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecutorMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecutorMessageRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecutorMessageRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecutorMessageRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecutorMessageRaw) MsgType() ExecutorMessagesRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return ExecutorMessagesRaw(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecutorMessageRaw) MutateMsgType(n ExecutorMessagesRaw) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *ExecutorMessageRaw) Msg(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ExecutorMessageRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ExecutorMessageRawAddMsgType(builder *flatbuffers.Builder, msgType ExecutorMessagesRaw) {
	builder.PrependByteSlot(0, byte(msgType), 0)
}
func ExecutorMessageRawAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func ExecutorMessageRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecOptsRawT struct {
	EnvFlags   ExecEnv  `json:"env_flags"`
	ExecFlags  ExecFlag `json:"exec_flags"`
	SandboxArg int64    `json:"sandbox_arg"`
}

func (t *ExecOptsRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	return CreateExecOptsRaw(builder, t.EnvFlags, t.ExecFlags, t.SandboxArg)
}
func (rcv *ExecOptsRaw) UnPackTo(t *ExecOptsRawT) {
	t.EnvFlags = rcv.EnvFlags()
	t.ExecFlags = rcv.ExecFlags()
	t.SandboxArg = rcv.SandboxArg()
}

func (rcv *ExecOptsRaw) UnPack() *ExecOptsRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecOptsRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecOptsRaw struct {
	_tab flatbuffers.Struct
}

func (rcv *ExecOptsRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecOptsRaw) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *ExecOptsRaw) EnvFlags() ExecEnv {
	return ExecEnv(rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(0)))
}
func (rcv *ExecOptsRaw) MutateEnvFlags(n ExecEnv) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(0), uint64(n))
}

func (rcv *ExecOptsRaw) ExecFlags() ExecFlag {
	return ExecFlag(rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(8)))
}
func (rcv *ExecOptsRaw) MutateExecFlags(n ExecFlag) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(8), uint64(n))
}

func (rcv *ExecOptsRaw) SandboxArg() int64 {
	return rcv._tab.GetInt64(rcv._tab.Pos + flatbuffers.UOffsetT(16))
}
func (rcv *ExecOptsRaw) MutateSandboxArg(n int64) bool {
	return rcv._tab.MutateInt64(rcv._tab.Pos+flatbuffers.UOffsetT(16), n)
}

func CreateExecOptsRaw(builder *flatbuffers.Builder, envFlags ExecEnv, execFlags ExecFlag, sandboxArg int64) flatbuffers.UOffsetT {
	builder.Prep(8, 24)
	builder.PrependInt64(sandboxArg)
	builder.PrependUint64(uint64(execFlags))
	builder.PrependUint64(uint64(envFlags))
	return builder.Offset()
}

type ExecRequestRawT struct {
	Id        int64         `json:"id"`
	Avoid     uint64        `json:"avoid"`
	ProgData  []byte        `json:"prog_data"`
	ExecOpts  *ExecOptsRawT `json:"exec_opts"`
	Flags     RequestFlag   `json:"flags"`
	AllSignal []int32       `json:"all_signal"`
}

func (t *ExecRequestRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	progDataOffset := flatbuffers.UOffsetT(0)
	if t.ProgData != nil {
		progDataOffset = builder.CreateByteString(t.ProgData)
	}
	allSignalOffset := flatbuffers.UOffsetT(0)
	if t.AllSignal != nil {
		allSignalLength := len(t.AllSignal)
		ExecRequestRawStartAllSignalVector(builder, allSignalLength)
		for j := allSignalLength - 1; j >= 0; j-- {
			builder.PrependInt32(t.AllSignal[j])
		}
		allSignalOffset = builder.EndVector(allSignalLength)
	}
	ExecRequestRawStart(builder)
	ExecRequestRawAddId(builder, t.Id)
	ExecRequestRawAddAvoid(builder, t.Avoid)
	ExecRequestRawAddProgData(builder, progDataOffset)
	execOptsOffset := t.ExecOpts.Pack(builder)
	ExecRequestRawAddExecOpts(builder, execOptsOffset)
	ExecRequestRawAddFlags(builder, t.Flags)
	ExecRequestRawAddAllSignal(builder, allSignalOffset)
	return ExecRequestRawEnd(builder)
}

func (rcv *ExecRequestRaw) UnPackTo(t *ExecRequestRawT) {
	t.Id = rcv.Id()
	t.Avoid = rcv.Avoid()
	t.ProgData = rcv.ProgDataBytes()
	t.ExecOpts = rcv.ExecOpts(nil).UnPack()
	t.Flags = rcv.Flags()
	allSignalLength := rcv.AllSignalLength()
	t.AllSignal = make([]int32, allSignalLength)
	for j := 0; j < allSignalLength; j++ {
		t.AllSignal[j] = rcv.AllSignal(j)
	}
}

func (rcv *ExecRequestRaw) UnPack() *ExecRequestRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecRequestRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecRequestRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsExecRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecRequestRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecRequestRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecRequestRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecRequestRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecRequestRaw) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *ExecRequestRaw) Avoid() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateAvoid(n uint64) bool {
	return rcv._tab.MutateUint64Slot(6, n)
}

func (rcv *ExecRequestRaw) ProgData(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ExecRequestRaw) ProgDataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecRequestRaw) ProgDataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecRequestRaw) MutateProgData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *ExecRequestRaw) ExecOpts(obj *ExecOptsRaw) *ExecOptsRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(ExecOptsRaw)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ExecRequestRaw) Flags() RequestFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return RequestFlag(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateFlags(n RequestFlag) bool {
	return rcv._tab.MutateUint64Slot(12, uint64(n))
}

func (rcv *ExecRequestRaw) AllSignal(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *ExecRequestRaw) AllSignalLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateAllSignal(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func ExecRequestRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func ExecRequestRawAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(0, id, 0)
}
func ExecRequestRawAddAvoid(builder *flatbuffers.Builder, avoid uint64) {
	builder.PrependUint64Slot(1, avoid, 0)
}
func ExecRequestRawAddProgData(builder *flatbuffers.Builder, progData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(progData), 0)
}
func ExecRequestRawStartProgDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ExecRequestRawAddExecOpts(builder *flatbuffers.Builder, execOpts flatbuffers.UOffsetT) {
	builder.PrependStructSlot(3, flatbuffers.UOffsetT(execOpts), 0)
}
func ExecRequestRawAddFlags(builder *flatbuffers.Builder, flags RequestFlag) {
	builder.PrependUint64Slot(4, uint64(flags), 0)
}
func ExecRequestRawAddAllSignal(builder *flatbuffers.Builder, allSignal flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(allSignal), 0)
}
func ExecRequestRawStartAllSignalVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ExecRequestRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type SignalUpdateRawT struct {
	NewMax []uint64 `json:"new_max"`
}

func (t *SignalUpdateRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	newMaxOffset := flatbuffers.UOffsetT(0)
	if t.NewMax != nil {
		newMaxLength := len(t.NewMax)
		SignalUpdateRawStartNewMaxVector(builder, newMaxLength)
		for j := newMaxLength - 1; j >= 0; j-- {
			builder.PrependUint64(t.NewMax[j])
		}
		newMaxOffset = builder.EndVector(newMaxLength)
	}
	SignalUpdateRawStart(builder)
	SignalUpdateRawAddNewMax(builder, newMaxOffset)
	return SignalUpdateRawEnd(builder)
}

func (rcv *SignalUpdateRaw) UnPackTo(t *SignalUpdateRawT) {
	newMaxLength := rcv.NewMaxLength()
	t.NewMax = make([]uint64, newMaxLength)
	for j := 0; j < newMaxLength; j++ {
		t.NewMax[j] = rcv.NewMax(j)
	}
}

func (rcv *SignalUpdateRaw) UnPack() *SignalUpdateRawT {
	if rcv == nil {
		return nil
	}
	t := &SignalUpdateRawT{}
	rcv.UnPackTo(t)
	return t
}

type SignalUpdateRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsSignalUpdateRaw(buf []byte, offset flatbuffers.UOffsetT) *SignalUpdateRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SignalUpdateRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSignalUpdateRaw(buf []byte, offset flatbuffers.UOffsetT) *SignalUpdateRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SignalUpdateRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SignalUpdateRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SignalUpdateRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SignalUpdateRaw) NewMax(j int) uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *SignalUpdateRaw) NewMaxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SignalUpdateRaw) MutateNewMax(j int, n uint64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func SignalUpdateRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func SignalUpdateRawAddNewMax(builder *flatbuffers.Builder, newMax flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(newMax), 0)
}
func SignalUpdateRawStartNewMaxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func SignalUpdateRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type CorpusTriagedRawT struct {
}

func (t *CorpusTriagedRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	CorpusTriagedRawStart(builder)
	return CorpusTriagedRawEnd(builder)
}

func (rcv *CorpusTriagedRaw) UnPackTo(t *CorpusTriagedRawT) {
}

func (rcv *CorpusTriagedRaw) UnPack() *CorpusTriagedRawT {
	if rcv == nil {
		return nil
	}
	t := &CorpusTriagedRawT{}
	rcv.UnPackTo(t)
	return t
}

type CorpusTriagedRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsCorpusTriagedRaw(buf []byte, offset flatbuffers.UOffsetT) *CorpusTriagedRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CorpusTriagedRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCorpusTriagedRaw(buf []byte, offset flatbuffers.UOffsetT) *CorpusTriagedRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CorpusTriagedRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CorpusTriagedRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CorpusTriagedRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func CorpusTriagedRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func CorpusTriagedRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type StateRequestRawT struct {
}

func (t *StateRequestRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	StateRequestRawStart(builder)
	return StateRequestRawEnd(builder)
}

func (rcv *StateRequestRaw) UnPackTo(t *StateRequestRawT) {
}

func (rcv *StateRequestRaw) UnPack() *StateRequestRawT {
	if rcv == nil {
		return nil
	}
	t := &StateRequestRawT{}
	rcv.UnPackTo(t)
	return t
}

type StateRequestRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsStateRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *StateRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StateRequestRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsStateRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *StateRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &StateRequestRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *StateRequestRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StateRequestRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func StateRequestRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(0)
}
func StateRequestRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecutingMessageRawT struct {
	Id           int64 `json:"id"`
	ProcId       int32 `json:"proc_id"`
	Try          int32 `json:"try"`
	WaitDuration int64 `json:"wait_duration"`
}

func (t *ExecutingMessageRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	ExecutingMessageRawStart(builder)
	ExecutingMessageRawAddId(builder, t.Id)
	ExecutingMessageRawAddProcId(builder, t.ProcId)
	ExecutingMessageRawAddTry(builder, t.Try)
	ExecutingMessageRawAddWaitDuration(builder, t.WaitDuration)
	return ExecutingMessageRawEnd(builder)
}

func (rcv *ExecutingMessageRaw) UnPackTo(t *ExecutingMessageRawT) {
	t.Id = rcv.Id()
	t.ProcId = rcv.ProcId()
	t.Try = rcv.Try()
	t.WaitDuration = rcv.WaitDuration()
}

func (rcv *ExecutingMessageRaw) UnPack() *ExecutingMessageRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecutingMessageRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecutingMessageRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsExecutingMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecutingMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecutingMessageRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecutingMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecutingMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecutingMessageRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecutingMessageRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecutingMessageRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecutingMessageRaw) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessageRaw) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *ExecutingMessageRaw) ProcId() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessageRaw) MutateProcId(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ExecutingMessageRaw) Try() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessageRaw) MutateTry(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *ExecutingMessageRaw) WaitDuration() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessageRaw) MutateWaitDuration(n int64) bool {
	return rcv._tab.MutateInt64Slot(10, n)
}

func ExecutingMessageRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ExecutingMessageRawAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(0, id, 0)
}
func ExecutingMessageRawAddProcId(builder *flatbuffers.Builder, procId int32) {
	builder.PrependInt32Slot(1, procId, 0)
}
func ExecutingMessageRawAddTry(builder *flatbuffers.Builder, try int32) {
	builder.PrependInt32Slot(2, try, 0)
}
func ExecutingMessageRawAddWaitDuration(builder *flatbuffers.Builder, waitDuration int64) {
	builder.PrependInt64Slot(3, waitDuration, 0)
}
func ExecutingMessageRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type CallInfoRawT struct {
	Flags  CallFlag          `json:"flags"`
	Error  int32             `json:"error"`
	Signal []uint64          `json:"signal"`
	Cover  []uint64          `json:"cover"`
	Comps  []*ComparisonRawT `json:"comps"`
}

func (t *CallInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	signalOffset := flatbuffers.UOffsetT(0)
	if t.Signal != nil {
		signalLength := len(t.Signal)
		CallInfoRawStartSignalVector(builder, signalLength)
		for j := signalLength - 1; j >= 0; j-- {
			builder.PrependUint64(t.Signal[j])
		}
		signalOffset = builder.EndVector(signalLength)
	}
	coverOffset := flatbuffers.UOffsetT(0)
	if t.Cover != nil {
		coverLength := len(t.Cover)
		CallInfoRawStartCoverVector(builder, coverLength)
		for j := coverLength - 1; j >= 0; j-- {
			builder.PrependUint64(t.Cover[j])
		}
		coverOffset = builder.EndVector(coverLength)
	}
	compsOffset := flatbuffers.UOffsetT(0)
	if t.Comps != nil {
		compsLength := len(t.Comps)
		CallInfoRawStartCompsVector(builder, compsLength)
		for j := compsLength - 1; j >= 0; j-- {
			t.Comps[j].Pack(builder)
		}
		compsOffset = builder.EndVector(compsLength)
	}
	CallInfoRawStart(builder)
	CallInfoRawAddFlags(builder, t.Flags)
	CallInfoRawAddError(builder, t.Error)
	CallInfoRawAddSignal(builder, signalOffset)
	CallInfoRawAddCover(builder, coverOffset)
	CallInfoRawAddComps(builder, compsOffset)
	return CallInfoRawEnd(builder)
}

func (rcv *CallInfoRaw) UnPackTo(t *CallInfoRawT) {
	t.Flags = rcv.Flags()
	t.Error = rcv.Error()
	signalLength := rcv.SignalLength()
	t.Signal = make([]uint64, signalLength)
	for j := 0; j < signalLength; j++ {
		t.Signal[j] = rcv.Signal(j)
	}
	coverLength := rcv.CoverLength()
	t.Cover = make([]uint64, coverLength)
	for j := 0; j < coverLength; j++ {
		t.Cover[j] = rcv.Cover(j)
	}
	compsLength := rcv.CompsLength()
	t.Comps = make([]*ComparisonRawT, compsLength)
	for j := 0; j < compsLength; j++ {
		x := ComparisonRaw{}
		rcv.Comps(&x, j)
		t.Comps[j] = x.UnPack()
	}
}

func (rcv *CallInfoRaw) UnPack() *CallInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &CallInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type CallInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsCallInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *CallInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CallInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCallInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *CallInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CallInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CallInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CallInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *CallInfoRaw) Flags() CallFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return CallFlag(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *CallInfoRaw) MutateFlags(n CallFlag) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *CallInfoRaw) Error() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CallInfoRaw) MutateError(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *CallInfoRaw) Signal(j int) uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *CallInfoRaw) SignalLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *CallInfoRaw) MutateSignal(j int, n uint64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *CallInfoRaw) Cover(j int) uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *CallInfoRaw) CoverLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *CallInfoRaw) MutateCover(j int, n uint64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *CallInfoRaw) Comps(obj *ComparisonRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 32
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *CallInfoRaw) CompsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func CallInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func CallInfoRawAddFlags(builder *flatbuffers.Builder, flags CallFlag) {
	builder.PrependByteSlot(0, byte(flags), 0)
}
func CallInfoRawAddError(builder *flatbuffers.Builder, error int32) {
	builder.PrependInt32Slot(1, error, 0)
}
func CallInfoRawAddSignal(builder *flatbuffers.Builder, signal flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(signal), 0)
}
func CallInfoRawStartSignalVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func CallInfoRawAddCover(builder *flatbuffers.Builder, cover flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(cover), 0)
}
func CallInfoRawStartCoverVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func CallInfoRawAddComps(builder *flatbuffers.Builder, comps flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(comps), 0)
}
func CallInfoRawStartCompsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(32, numElems, 8)
}
func CallInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ComparisonRawT struct {
	Pc      uint64 `json:"pc"`
	Op1     uint64 `json:"op1"`
	Op2     uint64 `json:"op2"`
	IsConst bool   `json:"is_const"`
}

func (t *ComparisonRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	return CreateComparisonRaw(builder, t.Pc, t.Op1, t.Op2, t.IsConst)
}
func (rcv *ComparisonRaw) UnPackTo(t *ComparisonRawT) {
	t.Pc = rcv.Pc()
	t.Op1 = rcv.Op1()
	t.Op2 = rcv.Op2()
	t.IsConst = rcv.IsConst()
}

func (rcv *ComparisonRaw) UnPack() *ComparisonRawT {
	if rcv == nil {
		return nil
	}
	t := &ComparisonRawT{}
	rcv.UnPackTo(t)
	return t
}

type ComparisonRaw struct {
	_tab flatbuffers.Struct
}

func (rcv *ComparisonRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ComparisonRaw) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *ComparisonRaw) Pc() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *ComparisonRaw) MutatePc(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *ComparisonRaw) Op1() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
func (rcv *ComparisonRaw) MutateOp1(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func (rcv *ComparisonRaw) Op2() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(16))
}
func (rcv *ComparisonRaw) MutateOp2(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(16), n)
}

func (rcv *ComparisonRaw) IsConst() bool {
	return rcv._tab.GetBool(rcv._tab.Pos + flatbuffers.UOffsetT(24))
}
func (rcv *ComparisonRaw) MutateIsConst(n bool) bool {
	return rcv._tab.MutateBool(rcv._tab.Pos+flatbuffers.UOffsetT(24), n)
}

func CreateComparisonRaw(builder *flatbuffers.Builder, pc uint64, op1 uint64, op2 uint64, isConst bool) flatbuffers.UOffsetT {
	builder.Prep(8, 32)
	builder.Pad(7)
	builder.PrependBool(isConst)
	builder.PrependUint64(op2)
	builder.PrependUint64(op1)
	builder.PrependUint64(pc)
	return builder.Offset()
}

type ProgInfoRawT struct {
	Calls     []*CallInfoRawT `json:"calls"`
	ExtraRaw  []*CallInfoRawT `json:"extra_raw"`
	Extra     *CallInfoRawT   `json:"extra"`
	Elapsed   uint64          `json:"elapsed"`
	Freshness uint64          `json:"freshness"`
}

func (t *ProgInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	callsOffset := flatbuffers.UOffsetT(0)
	if t.Calls != nil {
		callsLength := len(t.Calls)
		callsOffsets := make([]flatbuffers.UOffsetT, callsLength)
		for j := 0; j < callsLength; j++ {
			callsOffsets[j] = t.Calls[j].Pack(builder)
		}
		ProgInfoRawStartCallsVector(builder, callsLength)
		for j := callsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(callsOffsets[j])
		}
		callsOffset = builder.EndVector(callsLength)
	}
	extraRawOffset := flatbuffers.UOffsetT(0)
	if t.ExtraRaw != nil {
		extraRawLength := len(t.ExtraRaw)
		extraRawOffsets := make([]flatbuffers.UOffsetT, extraRawLength)
		for j := 0; j < extraRawLength; j++ {
			extraRawOffsets[j] = t.ExtraRaw[j].Pack(builder)
		}
		ProgInfoRawStartExtraRawVector(builder, extraRawLength)
		for j := extraRawLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(extraRawOffsets[j])
		}
		extraRawOffset = builder.EndVector(extraRawLength)
	}
	extraOffset := t.Extra.Pack(builder)
	ProgInfoRawStart(builder)
	ProgInfoRawAddCalls(builder, callsOffset)
	ProgInfoRawAddExtraRaw(builder, extraRawOffset)
	ProgInfoRawAddExtra(builder, extraOffset)
	ProgInfoRawAddElapsed(builder, t.Elapsed)
	ProgInfoRawAddFreshness(builder, t.Freshness)
	return ProgInfoRawEnd(builder)
}

func (rcv *ProgInfoRaw) UnPackTo(t *ProgInfoRawT) {
	callsLength := rcv.CallsLength()
	t.Calls = make([]*CallInfoRawT, callsLength)
	for j := 0; j < callsLength; j++ {
		x := CallInfoRaw{}
		rcv.Calls(&x, j)
		t.Calls[j] = x.UnPack()
	}
	extraRawLength := rcv.ExtraRawLength()
	t.ExtraRaw = make([]*CallInfoRawT, extraRawLength)
	for j := 0; j < extraRawLength; j++ {
		x := CallInfoRaw{}
		rcv.ExtraRaw(&x, j)
		t.ExtraRaw[j] = x.UnPack()
	}
	t.Extra = rcv.Extra(nil).UnPack()
	t.Elapsed = rcv.Elapsed()
	t.Freshness = rcv.Freshness()
}

func (rcv *ProgInfoRaw) UnPack() *ProgInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &ProgInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type ProgInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsProgInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *ProgInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ProgInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsProgInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *ProgInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ProgInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ProgInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ProgInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ProgInfoRaw) Calls(obj *CallInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ProgInfoRaw) CallsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ProgInfoRaw) ExtraRaw(obj *CallInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ProgInfoRaw) ExtraRawLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ProgInfoRaw) Extra(obj *CallInfoRaw) *CallInfoRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CallInfoRaw)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ProgInfoRaw) Elapsed() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ProgInfoRaw) MutateElapsed(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

func (rcv *ProgInfoRaw) Freshness() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ProgInfoRaw) MutateFreshness(n uint64) bool {
	return rcv._tab.MutateUint64Slot(12, n)
}

func ProgInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ProgInfoRawAddCalls(builder *flatbuffers.Builder, calls flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(calls), 0)
}
func ProgInfoRawStartCallsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ProgInfoRawAddExtraRaw(builder *flatbuffers.Builder, extraRaw flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(extraRaw), 0)
}
func ProgInfoRawStartExtraRawVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ProgInfoRawAddExtra(builder *flatbuffers.Builder, extra flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(extra), 0)
}
func ProgInfoRawAddElapsed(builder *flatbuffers.Builder, elapsed uint64) {
	builder.PrependUint64Slot(3, elapsed, 0)
}
func ProgInfoRawAddFreshness(builder *flatbuffers.Builder, freshness uint64) {
	builder.PrependUint64Slot(4, freshness, 0)
}
func ProgInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecResultRawT struct {
	Id     int64         `json:"id"`
	Proc   int32         `json:"proc"`
	Output []byte        `json:"output"`
	Error  string        `json:"error"`
	Info   *ProgInfoRawT `json:"info"`
}

func (t *ExecResultRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	outputOffset := flatbuffers.UOffsetT(0)
	if t.Output != nil {
		outputOffset = builder.CreateByteString(t.Output)
	}
	errorOffset := builder.CreateString(t.Error)
	infoOffset := t.Info.Pack(builder)
	ExecResultRawStart(builder)
	ExecResultRawAddId(builder, t.Id)
	ExecResultRawAddProc(builder, t.Proc)
	ExecResultRawAddOutput(builder, outputOffset)
	ExecResultRawAddError(builder, errorOffset)
	ExecResultRawAddInfo(builder, infoOffset)
	return ExecResultRawEnd(builder)
}

func (rcv *ExecResultRaw) UnPackTo(t *ExecResultRawT) {
	t.Id = rcv.Id()
	t.Proc = rcv.Proc()
	t.Output = rcv.OutputBytes()
	t.Error = string(rcv.Error())
	t.Info = rcv.Info(nil).UnPack()
}

func (rcv *ExecResultRaw) UnPack() *ExecResultRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecResultRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecResultRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsExecResultRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecResultRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecResultRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecResultRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecResultRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecResultRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecResultRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecResultRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecResultRaw) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecResultRaw) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *ExecResultRaw) Proc() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecResultRaw) MutateProc(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ExecResultRaw) Output(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ExecResultRaw) OutputLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecResultRaw) OutputBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecResultRaw) MutateOutput(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *ExecResultRaw) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecResultRaw) Info(obj *ProgInfoRaw) *ProgInfoRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ProgInfoRaw)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func ExecResultRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ExecResultRawAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(0, id, 0)
}
func ExecResultRawAddProc(builder *flatbuffers.Builder, proc int32) {
	builder.PrependInt32Slot(1, proc, 0)
}
func ExecResultRawAddOutput(builder *flatbuffers.Builder, output flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(output), 0)
}
func ExecResultRawStartOutputVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ExecResultRawAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(error), 0)
}
func ExecResultRawAddInfo(builder *flatbuffers.Builder, info flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(info), 0)
}
func ExecResultRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type StateResultRawT struct {
	Data []byte `json:"data"`
}

func (t *StateResultRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	dataOffset := flatbuffers.UOffsetT(0)
	if t.Data != nil {
		dataOffset = builder.CreateByteString(t.Data)
	}
	StateResultRawStart(builder)
	StateResultRawAddData(builder, dataOffset)
	return StateResultRawEnd(builder)
}

func (rcv *StateResultRaw) UnPackTo(t *StateResultRawT) {
	t.Data = rcv.DataBytes()
}

func (rcv *StateResultRaw) UnPack() *StateResultRawT {
	if rcv == nil {
		return nil
	}
	t := &StateResultRawT{}
	rcv.UnPackTo(t)
	return t
}

type StateResultRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsStateResultRaw(buf []byte, offset flatbuffers.UOffsetT) *StateResultRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StateResultRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsStateResultRaw(buf []byte, offset flatbuffers.UOffsetT) *StateResultRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &StateResultRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *StateResultRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StateResultRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *StateResultRaw) Data(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *StateResultRaw) DataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *StateResultRaw) DataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *StateResultRaw) MutateData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func StateResultRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func StateResultRawAddData(builder *flatbuffers.Builder, data flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(data), 0)
}
func StateResultRawStartDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func StateResultRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type SnapshotHeaderT struct {
	State        SnapshotState `json:"state"`
	OutputOffset uint32        `json:"output_offset"`
	OutputSize   uint32        `json:"output_size"`
}

func (t *SnapshotHeaderT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	SnapshotHeaderStart(builder)
	SnapshotHeaderAddState(builder, t.State)
	SnapshotHeaderAddOutputOffset(builder, t.OutputOffset)
	SnapshotHeaderAddOutputSize(builder, t.OutputSize)
	return SnapshotHeaderEnd(builder)
}

func (rcv *SnapshotHeader) UnPackTo(t *SnapshotHeaderT) {
	t.State = rcv.State()
	t.OutputOffset = rcv.OutputOffset()
	t.OutputSize = rcv.OutputSize()
}

func (rcv *SnapshotHeader) UnPack() *SnapshotHeaderT {
	if rcv == nil {
		return nil
	}
	t := &SnapshotHeaderT{}
	rcv.UnPackTo(t)
	return t
}

type SnapshotHeader struct {
	_tab flatbuffers.Table
}

func GetRootAsSnapshotHeader(buf []byte, offset flatbuffers.UOffsetT) *SnapshotHeader {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SnapshotHeader{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSnapshotHeader(buf []byte, offset flatbuffers.UOffsetT) *SnapshotHeader {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SnapshotHeader{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SnapshotHeader) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SnapshotHeader) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SnapshotHeader) State() SnapshotState {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return SnapshotState(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *SnapshotHeader) MutateState(n SnapshotState) bool {
	return rcv._tab.MutateUint64Slot(4, uint64(n))
}

func (rcv *SnapshotHeader) OutputOffset() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SnapshotHeader) MutateOutputOffset(n uint32) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

func (rcv *SnapshotHeader) OutputSize() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SnapshotHeader) MutateOutputSize(n uint32) bool {
	return rcv._tab.MutateUint32Slot(8, n)
}

func SnapshotHeaderStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func SnapshotHeaderAddState(builder *flatbuffers.Builder, state SnapshotState) {
	builder.PrependUint64Slot(0, uint64(state), 0)
}
func SnapshotHeaderAddOutputOffset(builder *flatbuffers.Builder, outputOffset uint32) {
	builder.PrependUint32Slot(1, outputOffset, 0)
}
func SnapshotHeaderAddOutputSize(builder *flatbuffers.Builder, outputSize uint32) {
	builder.PrependUint32Slot(2, outputSize, 0)
}
func SnapshotHeaderEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type SnapshotHandshakeT struct {
	CoverEdges       bool    `json:"cover_edges"`
	Kernel64Bit      bool    `json:"kernel_64_bit"`
	Slowdown         int32   `json:"slowdown"`
	SyscallTimeoutMs int32   `json:"syscall_timeout_ms"`
	ProgramTimeoutMs int32   `json:"program_timeout_ms"`
	Features         Feature `json:"features"`
	EnvFlags         ExecEnv `json:"env_flags"`
	SandboxArg       int64   `json:"sandbox_arg"`
}

func (t *SnapshotHandshakeT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	SnapshotHandshakeStart(builder)
	SnapshotHandshakeAddCoverEdges(builder, t.CoverEdges)
	SnapshotHandshakeAddKernel64Bit(builder, t.Kernel64Bit)
	SnapshotHandshakeAddSlowdown(builder, t.Slowdown)
	SnapshotHandshakeAddSyscallTimeoutMs(builder, t.SyscallTimeoutMs)
	SnapshotHandshakeAddProgramTimeoutMs(builder, t.ProgramTimeoutMs)
	SnapshotHandshakeAddFeatures(builder, t.Features)
	SnapshotHandshakeAddEnvFlags(builder, t.EnvFlags)
	SnapshotHandshakeAddSandboxArg(builder, t.SandboxArg)
	return SnapshotHandshakeEnd(builder)
}

func (rcv *SnapshotHandshake) UnPackTo(t *SnapshotHandshakeT) {
	t.CoverEdges = rcv.CoverEdges()
	t.Kernel64Bit = rcv.Kernel64Bit()
	t.Slowdown = rcv.Slowdown()
	t.SyscallTimeoutMs = rcv.SyscallTimeoutMs()
	t.ProgramTimeoutMs = rcv.ProgramTimeoutMs()
	t.Features = rcv.Features()
	t.EnvFlags = rcv.EnvFlags()
	t.SandboxArg = rcv.SandboxArg()
}

func (rcv *SnapshotHandshake) UnPack() *SnapshotHandshakeT {
	if rcv == nil {
		return nil
	}
	t := &SnapshotHandshakeT{}
	rcv.UnPackTo(t)
	return t
}

type SnapshotHandshake struct {
	_tab flatbuffers.Table
}

func GetRootAsSnapshotHandshake(buf []byte, offset flatbuffers.UOffsetT) *SnapshotHandshake {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SnapshotHandshake{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSnapshotHandshake(buf []byte, offset flatbuffers.UOffsetT) *SnapshotHandshake {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SnapshotHandshake{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SnapshotHandshake) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SnapshotHandshake) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SnapshotHandshake) CoverEdges() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *SnapshotHandshake) MutateCoverEdges(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

func (rcv *SnapshotHandshake) Kernel64Bit() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *SnapshotHandshake) MutateKernel64Bit(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *SnapshotHandshake) Slowdown() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SnapshotHandshake) MutateSlowdown(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *SnapshotHandshake) SyscallTimeoutMs() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SnapshotHandshake) MutateSyscallTimeoutMs(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func (rcv *SnapshotHandshake) ProgramTimeoutMs() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SnapshotHandshake) MutateProgramTimeoutMs(n int32) bool {
	return rcv._tab.MutateInt32Slot(12, n)
}

func (rcv *SnapshotHandshake) Features() Feature {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return Feature(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *SnapshotHandshake) MutateFeatures(n Feature) bool {
	return rcv._tab.MutateUint64Slot(14, uint64(n))
}

func (rcv *SnapshotHandshake) EnvFlags() ExecEnv {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return ExecEnv(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *SnapshotHandshake) MutateEnvFlags(n ExecEnv) bool {
	return rcv._tab.MutateUint64Slot(16, uint64(n))
}

func (rcv *SnapshotHandshake) SandboxArg() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SnapshotHandshake) MutateSandboxArg(n int64) bool {
	return rcv._tab.MutateInt64Slot(18, n)
}

func SnapshotHandshakeStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func SnapshotHandshakeAddCoverEdges(builder *flatbuffers.Builder, coverEdges bool) {
	builder.PrependBoolSlot(0, coverEdges, false)
}
func SnapshotHandshakeAddKernel64Bit(builder *flatbuffers.Builder, kernel64Bit bool) {
	builder.PrependBoolSlot(1, kernel64Bit, false)
}
func SnapshotHandshakeAddSlowdown(builder *flatbuffers.Builder, slowdown int32) {
	builder.PrependInt32Slot(2, slowdown, 0)
}
func SnapshotHandshakeAddSyscallTimeoutMs(builder *flatbuffers.Builder, syscallTimeoutMs int32) {
	builder.PrependInt32Slot(3, syscallTimeoutMs, 0)
}
func SnapshotHandshakeAddProgramTimeoutMs(builder *flatbuffers.Builder, programTimeoutMs int32) {
	builder.PrependInt32Slot(4, programTimeoutMs, 0)
}
func SnapshotHandshakeAddFeatures(builder *flatbuffers.Builder, features Feature) {
	builder.PrependUint64Slot(5, uint64(features), 0)
}
func SnapshotHandshakeAddEnvFlags(builder *flatbuffers.Builder, envFlags ExecEnv) {
	builder.PrependUint64Slot(6, uint64(envFlags), 0)
}
func SnapshotHandshakeAddSandboxArg(builder *flatbuffers.Builder, sandboxArg int64) {
	builder.PrependInt64Slot(7, sandboxArg, 0)
}
func SnapshotHandshakeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type SnapshotRequestT struct {
	ExecFlags      ExecFlag `json:"exec_flags"`
	NumCalls       int32    `json:"num_calls"`
	AllCallSignal  uint64   `json:"all_call_signal"`
	AllExtraSignal bool     `json:"all_extra_signal"`
	ProgData       []byte   `json:"prog_data"`
}

func (t *SnapshotRequestT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	progDataOffset := flatbuffers.UOffsetT(0)
	if t.ProgData != nil {
		progDataOffset = builder.CreateByteString(t.ProgData)
	}
	SnapshotRequestStart(builder)
	SnapshotRequestAddExecFlags(builder, t.ExecFlags)
	SnapshotRequestAddNumCalls(builder, t.NumCalls)
	SnapshotRequestAddAllCallSignal(builder, t.AllCallSignal)
	SnapshotRequestAddAllExtraSignal(builder, t.AllExtraSignal)
	SnapshotRequestAddProgData(builder, progDataOffset)
	return SnapshotRequestEnd(builder)
}

func (rcv *SnapshotRequest) UnPackTo(t *SnapshotRequestT) {
	t.ExecFlags = rcv.ExecFlags()
	t.NumCalls = rcv.NumCalls()
	t.AllCallSignal = rcv.AllCallSignal()
	t.AllExtraSignal = rcv.AllExtraSignal()
	t.ProgData = rcv.ProgDataBytes()
}

func (rcv *SnapshotRequest) UnPack() *SnapshotRequestT {
	if rcv == nil {
		return nil
	}
	t := &SnapshotRequestT{}
	rcv.UnPackTo(t)
	return t
}

type SnapshotRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsSnapshotRequest(buf []byte, offset flatbuffers.UOffsetT) *SnapshotRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SnapshotRequest{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSnapshotRequest(buf []byte, offset flatbuffers.UOffsetT) *SnapshotRequest {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SnapshotRequest{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SnapshotRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SnapshotRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SnapshotRequest) ExecFlags() ExecFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return ExecFlag(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *SnapshotRequest) MutateExecFlags(n ExecFlag) bool {
	return rcv._tab.MutateUint64Slot(4, uint64(n))
}

func (rcv *SnapshotRequest) NumCalls() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SnapshotRequest) MutateNumCalls(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *SnapshotRequest) AllCallSignal() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *SnapshotRequest) MutateAllCallSignal(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *SnapshotRequest) AllExtraSignal() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *SnapshotRequest) MutateAllExtraSignal(n bool) bool {
	return rcv._tab.MutateBoolSlot(10, n)
}

func (rcv *SnapshotRequest) ProgData(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *SnapshotRequest) ProgDataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SnapshotRequest) ProgDataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *SnapshotRequest) MutateProgData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func SnapshotRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func SnapshotRequestAddExecFlags(builder *flatbuffers.Builder, execFlags ExecFlag) {
	builder.PrependUint64Slot(0, uint64(execFlags), 0)
}
func SnapshotRequestAddNumCalls(builder *flatbuffers.Builder, numCalls int32) {
	builder.PrependInt32Slot(1, numCalls, 0)
}
func SnapshotRequestAddAllCallSignal(builder *flatbuffers.Builder, allCallSignal uint64) {
	builder.PrependUint64Slot(2, allCallSignal, 0)
}
func SnapshotRequestAddAllExtraSignal(builder *flatbuffers.Builder, allExtraSignal bool) {
	builder.PrependBoolSlot(3, allExtraSignal, false)
}
func SnapshotRequestAddProgData(builder *flatbuffers.Builder, progData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(progData), 0)
}
func SnapshotRequestStartProgDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func SnapshotRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
