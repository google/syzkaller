// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flatrpc

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type Feature uint64

const (
	FeatureCoverage         Feature = 1
	FeatureComparisons      Feature = 2
	FeatureExtraCoverage    Feature = 4
	FeatureDelayKcovMmap    Feature = 8
	FeatureSandboxSetuid    Feature = 16
	FeatureSandboxNamespace Feature = 32
	FeatureSandboxAndroid   Feature = 64
	FeatureFault            Feature = 128
	FeatureLeak             Feature = 256
	FeatureNetInjection     Feature = 512
	FeatureNetDevices       Feature = 1024
	FeatureKCSAN            Feature = 2048
	FeatureDevlinkPCI       Feature = 4096
	FeatureNicVF            Feature = 8192
	FeatureUSBEmulation     Feature = 16384
	FeatureVhciInjection    Feature = 32768
	FeatureWifiEmulation    Feature = 65536
	FeatureLRWPANEmulation  Feature = 131072
	FeatureBinFmtMisc       Feature = 262144
	FeatureSwap             Feature = 524288
)

var EnumNamesFeature = map[Feature]string{
	FeatureCoverage:         "Coverage",
	FeatureComparisons:      "Comparisons",
	FeatureExtraCoverage:    "ExtraCoverage",
	FeatureDelayKcovMmap:    "DelayKcovMmap",
	FeatureSandboxSetuid:    "SandboxSetuid",
	FeatureSandboxNamespace: "SandboxNamespace",
	FeatureSandboxAndroid:   "SandboxAndroid",
	FeatureFault:            "Fault",
	FeatureLeak:             "Leak",
	FeatureNetInjection:     "NetInjection",
	FeatureNetDevices:       "NetDevices",
	FeatureKCSAN:            "KCSAN",
	FeatureDevlinkPCI:       "DevlinkPCI",
	FeatureNicVF:            "NicVF",
	FeatureUSBEmulation:     "USBEmulation",
	FeatureVhciInjection:    "VhciInjection",
	FeatureWifiEmulation:    "WifiEmulation",
	FeatureLRWPANEmulation:  "LRWPANEmulation",
	FeatureBinFmtMisc:       "BinFmtMisc",
	FeatureSwap:             "Swap",
}

var EnumValuesFeature = map[string]Feature{
	"Coverage":         FeatureCoverage,
	"Comparisons":      FeatureComparisons,
	"ExtraCoverage":    FeatureExtraCoverage,
	"DelayKcovMmap":    FeatureDelayKcovMmap,
	"SandboxSetuid":    FeatureSandboxSetuid,
	"SandboxNamespace": FeatureSandboxNamespace,
	"SandboxAndroid":   FeatureSandboxAndroid,
	"Fault":            FeatureFault,
	"Leak":             FeatureLeak,
	"NetInjection":     FeatureNetInjection,
	"NetDevices":       FeatureNetDevices,
	"KCSAN":            FeatureKCSAN,
	"DevlinkPCI":       FeatureDevlinkPCI,
	"NicVF":            FeatureNicVF,
	"USBEmulation":     FeatureUSBEmulation,
	"VhciInjection":    FeatureVhciInjection,
	"WifiEmulation":    FeatureWifiEmulation,
	"LRWPANEmulation":  FeatureLRWPANEmulation,
	"BinFmtMisc":       FeatureBinFmtMisc,
	"Swap":             FeatureSwap,
}

func (v Feature) String() string {
	if s, ok := EnumNamesFeature[v]; ok {
		return s
	}
	return "Feature(" + strconv.FormatInt(int64(v), 10) + ")"
}

type HostMessagesRaw byte

const (
	HostMessagesRawNONE         HostMessagesRaw = 0
	HostMessagesRawExecRequest  HostMessagesRaw = 1
	HostMessagesRawSignalUpdate HostMessagesRaw = 2
)

var EnumNamesHostMessagesRaw = map[HostMessagesRaw]string{
	HostMessagesRawNONE:         "NONE",
	HostMessagesRawExecRequest:  "ExecRequest",
	HostMessagesRawSignalUpdate: "SignalUpdate",
}

var EnumValuesHostMessagesRaw = map[string]HostMessagesRaw{
	"NONE":         HostMessagesRawNONE,
	"ExecRequest":  HostMessagesRawExecRequest,
	"SignalUpdate": HostMessagesRawSignalUpdate,
}

func (v HostMessagesRaw) String() string {
	if s, ok := EnumNamesHostMessagesRaw[v]; ok {
		return s
	}
	return "HostMessagesRaw(" + strconv.FormatInt(int64(v), 10) + ")"
}

type HostMessagesRawT struct {
	Type  HostMessagesRaw
	Value interface{}
}

func (t *HostMessagesRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case HostMessagesRawExecRequest:
		return t.Value.(*ExecRequestRawT).Pack(builder)
	case HostMessagesRawSignalUpdate:
		return t.Value.(*SignalUpdateRawT).Pack(builder)
	}
	return 0
}

func (rcv HostMessagesRaw) UnPack(table flatbuffers.Table) *HostMessagesRawT {
	switch rcv {
	case HostMessagesRawExecRequest:
		x := ExecRequestRaw{_tab: table}
		return &HostMessagesRawT{Type: HostMessagesRawExecRequest, Value: x.UnPack()}
	case HostMessagesRawSignalUpdate:
		x := SignalUpdateRaw{_tab: table}
		return &HostMessagesRawT{Type: HostMessagesRawSignalUpdate, Value: x.UnPack()}
	}
	return nil
}

type ExecutorMessagesRaw byte

const (
	ExecutorMessagesRawNONE       ExecutorMessagesRaw = 0
	ExecutorMessagesRawExecResult ExecutorMessagesRaw = 1
	ExecutorMessagesRawExecuting  ExecutorMessagesRaw = 2
	ExecutorMessagesRawStats      ExecutorMessagesRaw = 3
)

var EnumNamesExecutorMessagesRaw = map[ExecutorMessagesRaw]string{
	ExecutorMessagesRawNONE:       "NONE",
	ExecutorMessagesRawExecResult: "ExecResult",
	ExecutorMessagesRawExecuting:  "Executing",
	ExecutorMessagesRawStats:      "Stats",
}

var EnumValuesExecutorMessagesRaw = map[string]ExecutorMessagesRaw{
	"NONE":       ExecutorMessagesRawNONE,
	"ExecResult": ExecutorMessagesRawExecResult,
	"Executing":  ExecutorMessagesRawExecuting,
	"Stats":      ExecutorMessagesRawStats,
}

func (v ExecutorMessagesRaw) String() string {
	if s, ok := EnumNamesExecutorMessagesRaw[v]; ok {
		return s
	}
	return "ExecutorMessagesRaw(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecutorMessagesRawT struct {
	Type  ExecutorMessagesRaw
	Value interface{}
}

func (t *ExecutorMessagesRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case ExecutorMessagesRawExecResult:
		return t.Value.(*ExecResultRawT).Pack(builder)
	case ExecutorMessagesRawExecuting:
		return t.Value.(*ExecutingMessageRawT).Pack(builder)
	case ExecutorMessagesRawStats:
		return t.Value.(*StatsMessageRawT).Pack(builder)
	}
	return 0
}

func (rcv ExecutorMessagesRaw) UnPack(table flatbuffers.Table) *ExecutorMessagesRawT {
	switch rcv {
	case ExecutorMessagesRawExecResult:
		x := ExecResultRaw{_tab: table}
		return &ExecutorMessagesRawT{Type: ExecutorMessagesRawExecResult, Value: x.UnPack()}
	case ExecutorMessagesRawExecuting:
		x := ExecutingMessageRaw{_tab: table}
		return &ExecutorMessagesRawT{Type: ExecutorMessagesRawExecuting, Value: x.UnPack()}
	case ExecutorMessagesRawStats:
		x := StatsMessageRaw{_tab: table}
		return &ExecutorMessagesRawT{Type: ExecutorMessagesRawStats, Value: x.UnPack()}
	}
	return nil
}

type RequestFlag uint64

const (
	RequestFlagIsBinary     RequestFlag = 1
	RequestFlagNewSignal    RequestFlag = 2
	RequestFlagResetState   RequestFlag = 4
	RequestFlagReturnOutput RequestFlag = 8
	RequestFlagReturnError  RequestFlag = 16
)

var EnumNamesRequestFlag = map[RequestFlag]string{
	RequestFlagIsBinary:     "IsBinary",
	RequestFlagNewSignal:    "NewSignal",
	RequestFlagResetState:   "ResetState",
	RequestFlagReturnOutput: "ReturnOutput",
	RequestFlagReturnError:  "ReturnError",
}

var EnumValuesRequestFlag = map[string]RequestFlag{
	"IsBinary":     RequestFlagIsBinary,
	"NewSignal":    RequestFlagNewSignal,
	"ResetState":   RequestFlagResetState,
	"ReturnOutput": RequestFlagReturnOutput,
	"ReturnError":  RequestFlagReturnError,
}

func (v RequestFlag) String() string {
	if s, ok := EnumNamesRequestFlag[v]; ok {
		return s
	}
	return "RequestFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecEnv uint64

const (
	ExecEnvDebug               ExecEnv = 1
	ExecEnvSignal              ExecEnv = 2
	ExecEnvSandboxSetuid       ExecEnv = 4
	ExecEnvSandboxNamespace    ExecEnv = 8
	ExecEnvSandboxAndroid      ExecEnv = 16
	ExecEnvExtraCover          ExecEnv = 32
	ExecEnvEnableTun           ExecEnv = 64
	ExecEnvEnableNetDev        ExecEnv = 128
	ExecEnvEnableNetReset      ExecEnv = 256
	ExecEnvEnableCgroups       ExecEnv = 512
	ExecEnvEnableCloseFds      ExecEnv = 1024
	ExecEnvEnableDevlinkPCI    ExecEnv = 2048
	ExecEnvEnableVhciInjection ExecEnv = 4096
	ExecEnvEnableWifi          ExecEnv = 8192
	ExecEnvDelayKcovMmap       ExecEnv = 16384
	ExecEnvEnableNicVF         ExecEnv = 32768
)

var EnumNamesExecEnv = map[ExecEnv]string{
	ExecEnvDebug:               "Debug",
	ExecEnvSignal:              "Signal",
	ExecEnvSandboxSetuid:       "SandboxSetuid",
	ExecEnvSandboxNamespace:    "SandboxNamespace",
	ExecEnvSandboxAndroid:      "SandboxAndroid",
	ExecEnvExtraCover:          "ExtraCover",
	ExecEnvEnableTun:           "EnableTun",
	ExecEnvEnableNetDev:        "EnableNetDev",
	ExecEnvEnableNetReset:      "EnableNetReset",
	ExecEnvEnableCgroups:       "EnableCgroups",
	ExecEnvEnableCloseFds:      "EnableCloseFds",
	ExecEnvEnableDevlinkPCI:    "EnableDevlinkPCI",
	ExecEnvEnableVhciInjection: "EnableVhciInjection",
	ExecEnvEnableWifi:          "EnableWifi",
	ExecEnvDelayKcovMmap:       "DelayKcovMmap",
	ExecEnvEnableNicVF:         "EnableNicVF",
}

var EnumValuesExecEnv = map[string]ExecEnv{
	"Debug":               ExecEnvDebug,
	"Signal":              ExecEnvSignal,
	"SandboxSetuid":       ExecEnvSandboxSetuid,
	"SandboxNamespace":    ExecEnvSandboxNamespace,
	"SandboxAndroid":      ExecEnvSandboxAndroid,
	"ExtraCover":          ExecEnvExtraCover,
	"EnableTun":           ExecEnvEnableTun,
	"EnableNetDev":        ExecEnvEnableNetDev,
	"EnableNetReset":      ExecEnvEnableNetReset,
	"EnableCgroups":       ExecEnvEnableCgroups,
	"EnableCloseFds":      ExecEnvEnableCloseFds,
	"EnableDevlinkPCI":    ExecEnvEnableDevlinkPCI,
	"EnableVhciInjection": ExecEnvEnableVhciInjection,
	"EnableWifi":          ExecEnvEnableWifi,
	"DelayKcovMmap":       ExecEnvDelayKcovMmap,
	"EnableNicVF":         ExecEnvEnableNicVF,
}

func (v ExecEnv) String() string {
	if s, ok := EnumNamesExecEnv[v]; ok {
		return s
	}
	return "ExecEnv(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecFlag uint64

const (
	ExecFlagCollectSignal ExecFlag = 1
	ExecFlagCollectCover  ExecFlag = 2
	ExecFlagDedupCover    ExecFlag = 4
	ExecFlagCollectComps  ExecFlag = 8
	ExecFlagThreaded      ExecFlag = 16
	ExecFlagCoverFilter   ExecFlag = 32
)

var EnumNamesExecFlag = map[ExecFlag]string{
	ExecFlagCollectSignal: "CollectSignal",
	ExecFlagCollectCover:  "CollectCover",
	ExecFlagDedupCover:    "DedupCover",
	ExecFlagCollectComps:  "CollectComps",
	ExecFlagThreaded:      "Threaded",
	ExecFlagCoverFilter:   "CoverFilter",
}

var EnumValuesExecFlag = map[string]ExecFlag{
	"CollectSignal": ExecFlagCollectSignal,
	"CollectCover":  ExecFlagCollectCover,
	"DedupCover":    ExecFlagDedupCover,
	"CollectComps":  ExecFlagCollectComps,
	"Threaded":      ExecFlagThreaded,
	"CoverFilter":   ExecFlagCoverFilter,
}

func (v ExecFlag) String() string {
	if s, ok := EnumNamesExecFlag[v]; ok {
		return s
	}
	return "ExecFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type CallFlag byte

const (
	CallFlagExecuted      CallFlag = 1
	CallFlagFinished      CallFlag = 2
	CallFlagBlocked       CallFlag = 4
	CallFlagFaultInjected CallFlag = 8
)

var EnumNamesCallFlag = map[CallFlag]string{
	CallFlagExecuted:      "Executed",
	CallFlagFinished:      "Finished",
	CallFlagBlocked:       "Blocked",
	CallFlagFaultInjected: "FaultInjected",
}

var EnumValuesCallFlag = map[string]CallFlag{
	"Executed":      CallFlagExecuted,
	"Finished":      CallFlagFinished,
	"Blocked":       CallFlagBlocked,
	"FaultInjected": CallFlagFaultInjected,
}

func (v CallFlag) String() string {
	if s, ok := EnumNamesCallFlag[v]; ok {
		return s
	}
	return "CallFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ConnectRequestRawT struct {
	Name        string `json:"name"`
	Arch        string `json:"arch"`
	GitRevision string `json:"git_revision"`
	SyzRevision string `json:"syz_revision"`
}

func (t *ConnectRequestRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	archOffset := builder.CreateString(t.Arch)
	gitRevisionOffset := builder.CreateString(t.GitRevision)
	syzRevisionOffset := builder.CreateString(t.SyzRevision)
	ConnectRequestRawStart(builder)
	ConnectRequestRawAddName(builder, nameOffset)
	ConnectRequestRawAddArch(builder, archOffset)
	ConnectRequestRawAddGitRevision(builder, gitRevisionOffset)
	ConnectRequestRawAddSyzRevision(builder, syzRevisionOffset)
	return ConnectRequestRawEnd(builder)
}

func (rcv *ConnectRequestRaw) UnPackTo(t *ConnectRequestRawT) {
	t.Name = string(rcv.Name())
	t.Arch = string(rcv.Arch())
	t.GitRevision = string(rcv.GitRevision())
	t.SyzRevision = string(rcv.SyzRevision())
}

func (rcv *ConnectRequestRaw) UnPack() *ConnectRequestRawT {
	if rcv == nil {
		return nil
	}
	t := &ConnectRequestRawT{}
	rcv.UnPackTo(t)
	return t
}

type ConnectRequestRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsConnectRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *ConnectRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ConnectRequestRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsConnectRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *ConnectRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ConnectRequestRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ConnectRequestRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ConnectRequestRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ConnectRequestRaw) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequestRaw) Arch() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequestRaw) GitRevision() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequestRaw) SyzRevision() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ConnectRequestRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ConnectRequestRawAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func ConnectRequestRawAddArch(builder *flatbuffers.Builder, arch flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(arch), 0)
}
func ConnectRequestRawAddGitRevision(builder *flatbuffers.Builder, gitRevision flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(gitRevision), 0)
}
func ConnectRequestRawAddSyzRevision(builder *flatbuffers.Builder, syzRevision flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(syzRevision), 0)
}
func ConnectRequestRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ConnectReplyRawT struct {
	LeakFrames []string `json:"leak_frames"`
	RaceFrames []string `json:"race_frames"`
	Features   Feature  `json:"features"`
	Files      []string `json:"files"`
	Globs      []string `json:"globs"`
}

func (t *ConnectReplyRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	leakFramesOffset := flatbuffers.UOffsetT(0)
	if t.LeakFrames != nil {
		leakFramesLength := len(t.LeakFrames)
		leakFramesOffsets := make([]flatbuffers.UOffsetT, leakFramesLength)
		for j := 0; j < leakFramesLength; j++ {
			leakFramesOffsets[j] = builder.CreateString(t.LeakFrames[j])
		}
		ConnectReplyRawStartLeakFramesVector(builder, leakFramesLength)
		for j := leakFramesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(leakFramesOffsets[j])
		}
		leakFramesOffset = builder.EndVector(leakFramesLength)
	}
	raceFramesOffset := flatbuffers.UOffsetT(0)
	if t.RaceFrames != nil {
		raceFramesLength := len(t.RaceFrames)
		raceFramesOffsets := make([]flatbuffers.UOffsetT, raceFramesLength)
		for j := 0; j < raceFramesLength; j++ {
			raceFramesOffsets[j] = builder.CreateString(t.RaceFrames[j])
		}
		ConnectReplyRawStartRaceFramesVector(builder, raceFramesLength)
		for j := raceFramesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(raceFramesOffsets[j])
		}
		raceFramesOffset = builder.EndVector(raceFramesLength)
	}
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = builder.CreateString(t.Files[j])
		}
		ConnectReplyRawStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	globsOffset := flatbuffers.UOffsetT(0)
	if t.Globs != nil {
		globsLength := len(t.Globs)
		globsOffsets := make([]flatbuffers.UOffsetT, globsLength)
		for j := 0; j < globsLength; j++ {
			globsOffsets[j] = builder.CreateString(t.Globs[j])
		}
		ConnectReplyRawStartGlobsVector(builder, globsLength)
		for j := globsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(globsOffsets[j])
		}
		globsOffset = builder.EndVector(globsLength)
	}
	ConnectReplyRawStart(builder)
	ConnectReplyRawAddLeakFrames(builder, leakFramesOffset)
	ConnectReplyRawAddRaceFrames(builder, raceFramesOffset)
	ConnectReplyRawAddFeatures(builder, t.Features)
	ConnectReplyRawAddFiles(builder, filesOffset)
	ConnectReplyRawAddGlobs(builder, globsOffset)
	return ConnectReplyRawEnd(builder)
}

func (rcv *ConnectReplyRaw) UnPackTo(t *ConnectReplyRawT) {
	leakFramesLength := rcv.LeakFramesLength()
	t.LeakFrames = make([]string, leakFramesLength)
	for j := 0; j < leakFramesLength; j++ {
		t.LeakFrames[j] = string(rcv.LeakFrames(j))
	}
	raceFramesLength := rcv.RaceFramesLength()
	t.RaceFrames = make([]string, raceFramesLength)
	for j := 0; j < raceFramesLength; j++ {
		t.RaceFrames[j] = string(rcv.RaceFrames(j))
	}
	t.Features = rcv.Features()
	filesLength := rcv.FilesLength()
	t.Files = make([]string, filesLength)
	for j := 0; j < filesLength; j++ {
		t.Files[j] = string(rcv.Files(j))
	}
	globsLength := rcv.GlobsLength()
	t.Globs = make([]string, globsLength)
	for j := 0; j < globsLength; j++ {
		t.Globs[j] = string(rcv.Globs(j))
	}
}

func (rcv *ConnectReplyRaw) UnPack() *ConnectReplyRawT {
	if rcv == nil {
		return nil
	}
	t := &ConnectReplyRawT{}
	rcv.UnPackTo(t)
	return t
}

type ConnectReplyRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsConnectReplyRaw(buf []byte, offset flatbuffers.UOffsetT) *ConnectReplyRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ConnectReplyRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsConnectReplyRaw(buf []byte, offset flatbuffers.UOffsetT) *ConnectReplyRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ConnectReplyRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ConnectReplyRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ConnectReplyRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ConnectReplyRaw) LeakFrames(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReplyRaw) LeakFramesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReplyRaw) RaceFrames(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReplyRaw) RaceFramesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReplyRaw) Features() Feature {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Feature(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ConnectReplyRaw) MutateFeatures(n Feature) bool {
	return rcv._tab.MutateUint64Slot(8, uint64(n))
}

func (rcv *ConnectReplyRaw) Files(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReplyRaw) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReplyRaw) Globs(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReplyRaw) GlobsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ConnectReplyRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ConnectReplyRawAddLeakFrames(builder *flatbuffers.Builder, leakFrames flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(leakFrames), 0)
}
func ConnectReplyRawStartLeakFramesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyRawAddRaceFrames(builder *flatbuffers.Builder, raceFrames flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(raceFrames), 0)
}
func ConnectReplyRawStartRaceFramesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyRawAddFeatures(builder *flatbuffers.Builder, features Feature) {
	builder.PrependUint64Slot(2, uint64(features), 0)
}
func ConnectReplyRawAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(files), 0)
}
func ConnectReplyRawStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyRawAddGlobs(builder *flatbuffers.Builder, globs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(globs), 0)
}
func ConnectReplyRawStartGlobsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type InfoRequestRawT struct {
	Error    string             `json:"error"`
	Features []*FeatureInfoRawT `json:"features"`
	Files    []*FileInfoRawT    `json:"files"`
	Globs    []*GlobInfoRawT    `json:"globs"`
}

func (t *InfoRequestRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	errorOffset := builder.CreateString(t.Error)
	featuresOffset := flatbuffers.UOffsetT(0)
	if t.Features != nil {
		featuresLength := len(t.Features)
		featuresOffsets := make([]flatbuffers.UOffsetT, featuresLength)
		for j := 0; j < featuresLength; j++ {
			featuresOffsets[j] = t.Features[j].Pack(builder)
		}
		InfoRequestRawStartFeaturesVector(builder, featuresLength)
		for j := featuresLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(featuresOffsets[j])
		}
		featuresOffset = builder.EndVector(featuresLength)
	}
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = t.Files[j].Pack(builder)
		}
		InfoRequestRawStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	globsOffset := flatbuffers.UOffsetT(0)
	if t.Globs != nil {
		globsLength := len(t.Globs)
		globsOffsets := make([]flatbuffers.UOffsetT, globsLength)
		for j := 0; j < globsLength; j++ {
			globsOffsets[j] = t.Globs[j].Pack(builder)
		}
		InfoRequestRawStartGlobsVector(builder, globsLength)
		for j := globsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(globsOffsets[j])
		}
		globsOffset = builder.EndVector(globsLength)
	}
	InfoRequestRawStart(builder)
	InfoRequestRawAddError(builder, errorOffset)
	InfoRequestRawAddFeatures(builder, featuresOffset)
	InfoRequestRawAddFiles(builder, filesOffset)
	InfoRequestRawAddGlobs(builder, globsOffset)
	return InfoRequestRawEnd(builder)
}

func (rcv *InfoRequestRaw) UnPackTo(t *InfoRequestRawT) {
	t.Error = string(rcv.Error())
	featuresLength := rcv.FeaturesLength()
	t.Features = make([]*FeatureInfoRawT, featuresLength)
	for j := 0; j < featuresLength; j++ {
		x := FeatureInfoRaw{}
		rcv.Features(&x, j)
		t.Features[j] = x.UnPack()
	}
	filesLength := rcv.FilesLength()
	t.Files = make([]*FileInfoRawT, filesLength)
	for j := 0; j < filesLength; j++ {
		x := FileInfoRaw{}
		rcv.Files(&x, j)
		t.Files[j] = x.UnPack()
	}
	globsLength := rcv.GlobsLength()
	t.Globs = make([]*GlobInfoRawT, globsLength)
	for j := 0; j < globsLength; j++ {
		x := GlobInfoRaw{}
		rcv.Globs(&x, j)
		t.Globs[j] = x.UnPack()
	}
}

func (rcv *InfoRequestRaw) UnPack() *InfoRequestRawT {
	if rcv == nil {
		return nil
	}
	t := &InfoRequestRawT{}
	rcv.UnPackTo(t)
	return t
}

type InfoRequestRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsInfoRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *InfoRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &InfoRequestRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsInfoRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *InfoRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &InfoRequestRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *InfoRequestRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *InfoRequestRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *InfoRequestRaw) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *InfoRequestRaw) Features(obj *FeatureInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *InfoRequestRaw) FeaturesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *InfoRequestRaw) Files(obj *FileInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *InfoRequestRaw) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *InfoRequestRaw) Globs(obj *GlobInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *InfoRequestRaw) GlobsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func InfoRequestRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func InfoRequestRawAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(error), 0)
}
func InfoRequestRawAddFeatures(builder *flatbuffers.Builder, features flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(features), 0)
}
func InfoRequestRawStartFeaturesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoRequestRawAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(files), 0)
}
func InfoRequestRawStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoRequestRawAddGlobs(builder *flatbuffers.Builder, globs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(globs), 0)
}
func InfoRequestRawStartGlobsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoRequestRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type InfoReplyRawT struct {
	CoverFilter []uint32 `json:"cover_filter"`
}

func (t *InfoReplyRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	coverFilterOffset := flatbuffers.UOffsetT(0)
	if t.CoverFilter != nil {
		coverFilterLength := len(t.CoverFilter)
		InfoReplyRawStartCoverFilterVector(builder, coverFilterLength)
		for j := coverFilterLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.CoverFilter[j])
		}
		coverFilterOffset = builder.EndVector(coverFilterLength)
	}
	InfoReplyRawStart(builder)
	InfoReplyRawAddCoverFilter(builder, coverFilterOffset)
	return InfoReplyRawEnd(builder)
}

func (rcv *InfoReplyRaw) UnPackTo(t *InfoReplyRawT) {
	coverFilterLength := rcv.CoverFilterLength()
	t.CoverFilter = make([]uint32, coverFilterLength)
	for j := 0; j < coverFilterLength; j++ {
		t.CoverFilter[j] = rcv.CoverFilter(j)
	}
}

func (rcv *InfoReplyRaw) UnPack() *InfoReplyRawT {
	if rcv == nil {
		return nil
	}
	t := &InfoReplyRawT{}
	rcv.UnPackTo(t)
	return t
}

type InfoReplyRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsInfoReplyRaw(buf []byte, offset flatbuffers.UOffsetT) *InfoReplyRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &InfoReplyRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsInfoReplyRaw(buf []byte, offset flatbuffers.UOffsetT) *InfoReplyRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &InfoReplyRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *InfoReplyRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *InfoReplyRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *InfoReplyRaw) CoverFilter(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *InfoReplyRaw) CoverFilterLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *InfoReplyRaw) MutateCoverFilter(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func InfoReplyRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func InfoReplyRawAddCoverFilter(builder *flatbuffers.Builder, coverFilter flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(coverFilter), 0)
}
func InfoReplyRawStartCoverFilterVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoReplyRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FileInfoRawT struct {
	Name   string `json:"name"`
	Exists bool   `json:"exists"`
	Error  string `json:"error"`
	Data   []byte `json:"data"`
}

func (t *FileInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	errorOffset := builder.CreateString(t.Error)
	dataOffset := flatbuffers.UOffsetT(0)
	if t.Data != nil {
		dataOffset = builder.CreateByteString(t.Data)
	}
	FileInfoRawStart(builder)
	FileInfoRawAddName(builder, nameOffset)
	FileInfoRawAddExists(builder, t.Exists)
	FileInfoRawAddError(builder, errorOffset)
	FileInfoRawAddData(builder, dataOffset)
	return FileInfoRawEnd(builder)
}

func (rcv *FileInfoRaw) UnPackTo(t *FileInfoRawT) {
	t.Name = string(rcv.Name())
	t.Exists = rcv.Exists()
	t.Error = string(rcv.Error())
	t.Data = rcv.DataBytes()
}

func (rcv *FileInfoRaw) UnPack() *FileInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &FileInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type FileInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsFileInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *FileInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FileInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFileInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *FileInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FileInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FileInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FileInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FileInfoRaw) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfoRaw) Exists() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *FileInfoRaw) MutateExists(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *FileInfoRaw) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfoRaw) Data(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *FileInfoRaw) DataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *FileInfoRaw) DataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfoRaw) MutateData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func FileInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func FileInfoRawAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func FileInfoRawAddExists(builder *flatbuffers.Builder, exists bool) {
	builder.PrependBoolSlot(1, exists, false)
}
func FileInfoRawAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(error), 0)
}
func FileInfoRawAddData(builder *flatbuffers.Builder, data flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(data), 0)
}
func FileInfoRawStartDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func FileInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type GlobInfoRawT struct {
	Name  string   `json:"name"`
	Files []string `json:"files"`
}

func (t *GlobInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = builder.CreateString(t.Files[j])
		}
		GlobInfoRawStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	GlobInfoRawStart(builder)
	GlobInfoRawAddName(builder, nameOffset)
	GlobInfoRawAddFiles(builder, filesOffset)
	return GlobInfoRawEnd(builder)
}

func (rcv *GlobInfoRaw) UnPackTo(t *GlobInfoRawT) {
	t.Name = string(rcv.Name())
	filesLength := rcv.FilesLength()
	t.Files = make([]string, filesLength)
	for j := 0; j < filesLength; j++ {
		t.Files[j] = string(rcv.Files(j))
	}
}

func (rcv *GlobInfoRaw) UnPack() *GlobInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &GlobInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type GlobInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsGlobInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *GlobInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GlobInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsGlobInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *GlobInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &GlobInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *GlobInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GlobInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GlobInfoRaw) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GlobInfoRaw) Files(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *GlobInfoRaw) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func GlobInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func GlobInfoRawAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func GlobInfoRawAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(files), 0)
}
func GlobInfoRawStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GlobInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FeatureInfoRawT struct {
	Id        Feature `json:"id"`
	NeedSetup bool    `json:"need_setup"`
	Reason    string  `json:"reason"`
}

func (t *FeatureInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	reasonOffset := builder.CreateString(t.Reason)
	FeatureInfoRawStart(builder)
	FeatureInfoRawAddId(builder, t.Id)
	FeatureInfoRawAddNeedSetup(builder, t.NeedSetup)
	FeatureInfoRawAddReason(builder, reasonOffset)
	return FeatureInfoRawEnd(builder)
}

func (rcv *FeatureInfoRaw) UnPackTo(t *FeatureInfoRawT) {
	t.Id = rcv.Id()
	t.NeedSetup = rcv.NeedSetup()
	t.Reason = string(rcv.Reason())
}

func (rcv *FeatureInfoRaw) UnPack() *FeatureInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &FeatureInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type FeatureInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsFeatureInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *FeatureInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FeatureInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFeatureInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *FeatureInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FeatureInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FeatureInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FeatureInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FeatureInfoRaw) Id() Feature {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return Feature(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *FeatureInfoRaw) MutateId(n Feature) bool {
	return rcv._tab.MutateUint64Slot(4, uint64(n))
}

func (rcv *FeatureInfoRaw) NeedSetup() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *FeatureInfoRaw) MutateNeedSetup(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *FeatureInfoRaw) Reason() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func FeatureInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func FeatureInfoRawAddId(builder *flatbuffers.Builder, id Feature) {
	builder.PrependUint64Slot(0, uint64(id), 0)
}
func FeatureInfoRawAddNeedSetup(builder *flatbuffers.Builder, needSetup bool) {
	builder.PrependBoolSlot(1, needSetup, false)
}
func FeatureInfoRawAddReason(builder *flatbuffers.Builder, reason flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(reason), 0)
}
func FeatureInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type HostMessageRawT struct {
	Msg *HostMessagesRawT `json:"msg"`
}

func (t *HostMessageRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	msgOffset := t.Msg.Pack(builder)

	HostMessageRawStart(builder)
	if t.Msg != nil {
		HostMessageRawAddMsgType(builder, t.Msg.Type)
	}
	HostMessageRawAddMsg(builder, msgOffset)
	return HostMessageRawEnd(builder)
}

func (rcv *HostMessageRaw) UnPackTo(t *HostMessageRawT) {
	msgTable := flatbuffers.Table{}
	if rcv.Msg(&msgTable) {
		t.Msg = rcv.MsgType().UnPack(msgTable)
	}
}

func (rcv *HostMessageRaw) UnPack() *HostMessageRawT {
	if rcv == nil {
		return nil
	}
	t := &HostMessageRawT{}
	rcv.UnPackTo(t)
	return t
}

type HostMessageRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsHostMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *HostMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &HostMessageRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsHostMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *HostMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &HostMessageRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *HostMessageRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *HostMessageRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *HostMessageRaw) MsgType() HostMessagesRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return HostMessagesRaw(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *HostMessageRaw) MutateMsgType(n HostMessagesRaw) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *HostMessageRaw) Msg(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func HostMessageRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func HostMessageRawAddMsgType(builder *flatbuffers.Builder, msgType HostMessagesRaw) {
	builder.PrependByteSlot(0, byte(msgType), 0)
}
func HostMessageRawAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func HostMessageRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecutorMessageRawT struct {
	Msg *ExecutorMessagesRawT `json:"msg"`
}

func (t *ExecutorMessageRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	msgOffset := t.Msg.Pack(builder)

	ExecutorMessageRawStart(builder)
	if t.Msg != nil {
		ExecutorMessageRawAddMsgType(builder, t.Msg.Type)
	}
	ExecutorMessageRawAddMsg(builder, msgOffset)
	return ExecutorMessageRawEnd(builder)
}

func (rcv *ExecutorMessageRaw) UnPackTo(t *ExecutorMessageRawT) {
	msgTable := flatbuffers.Table{}
	if rcv.Msg(&msgTable) {
		t.Msg = rcv.MsgType().UnPack(msgTable)
	}
}

func (rcv *ExecutorMessageRaw) UnPack() *ExecutorMessageRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecutorMessageRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecutorMessageRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsExecutorMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecutorMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecutorMessageRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecutorMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecutorMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecutorMessageRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecutorMessageRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecutorMessageRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecutorMessageRaw) MsgType() ExecutorMessagesRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return ExecutorMessagesRaw(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecutorMessageRaw) MutateMsgType(n ExecutorMessagesRaw) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *ExecutorMessageRaw) Msg(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ExecutorMessageRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ExecutorMessageRawAddMsgType(builder *flatbuffers.Builder, msgType ExecutorMessagesRaw) {
	builder.PrependByteSlot(0, byte(msgType), 0)
}
func ExecutorMessageRawAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func ExecutorMessageRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecRequestRawT struct {
	Id               int64       `json:"id"`
	ProgData         []byte      `json:"prog_data"`
	Flags            RequestFlag `json:"flags"`
	ExecEnv          ExecEnv     `json:"exec_env"`
	ExecFlags        ExecFlag    `json:"exec_flags"`
	SandboxArg       int64       `json:"sandbox_arg"`
	SignalFilter     []uint32    `json:"signal_filter"`
	SignalFilterCall int32       `json:"signal_filter_call"`
	Repeat           int32       `json:"repeat"`
}

func (t *ExecRequestRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	progDataOffset := flatbuffers.UOffsetT(0)
	if t.ProgData != nil {
		progDataOffset = builder.CreateByteString(t.ProgData)
	}
	signalFilterOffset := flatbuffers.UOffsetT(0)
	if t.SignalFilter != nil {
		signalFilterLength := len(t.SignalFilter)
		ExecRequestRawStartSignalFilterVector(builder, signalFilterLength)
		for j := signalFilterLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.SignalFilter[j])
		}
		signalFilterOffset = builder.EndVector(signalFilterLength)
	}
	ExecRequestRawStart(builder)
	ExecRequestRawAddId(builder, t.Id)
	ExecRequestRawAddProgData(builder, progDataOffset)
	ExecRequestRawAddFlags(builder, t.Flags)
	ExecRequestRawAddExecEnv(builder, t.ExecEnv)
	ExecRequestRawAddExecFlags(builder, t.ExecFlags)
	ExecRequestRawAddSandboxArg(builder, t.SandboxArg)
	ExecRequestRawAddSignalFilter(builder, signalFilterOffset)
	ExecRequestRawAddSignalFilterCall(builder, t.SignalFilterCall)
	ExecRequestRawAddRepeat(builder, t.Repeat)
	return ExecRequestRawEnd(builder)
}

func (rcv *ExecRequestRaw) UnPackTo(t *ExecRequestRawT) {
	t.Id = rcv.Id()
	t.ProgData = rcv.ProgDataBytes()
	t.Flags = rcv.Flags()
	t.ExecEnv = rcv.ExecEnv()
	t.ExecFlags = rcv.ExecFlags()
	t.SandboxArg = rcv.SandboxArg()
	signalFilterLength := rcv.SignalFilterLength()
	t.SignalFilter = make([]uint32, signalFilterLength)
	for j := 0; j < signalFilterLength; j++ {
		t.SignalFilter[j] = rcv.SignalFilter(j)
	}
	t.SignalFilterCall = rcv.SignalFilterCall()
	t.Repeat = rcv.Repeat()
}

func (rcv *ExecRequestRaw) UnPack() *ExecRequestRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecRequestRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecRequestRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsExecRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecRequestRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecRequestRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecRequestRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecRequestRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecRequestRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecRequestRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecRequestRaw) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *ExecRequestRaw) ProgData(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ExecRequestRaw) ProgDataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecRequestRaw) ProgDataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecRequestRaw) MutateProgData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *ExecRequestRaw) Flags() RequestFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return RequestFlag(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateFlags(n RequestFlag) bool {
	return rcv._tab.MutateUint64Slot(8, uint64(n))
}

func (rcv *ExecRequestRaw) ExecEnv() ExecEnv {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return ExecEnv(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateExecEnv(n ExecEnv) bool {
	return rcv._tab.MutateUint64Slot(10, uint64(n))
}

func (rcv *ExecRequestRaw) ExecFlags() ExecFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return ExecFlag(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateExecFlags(n ExecFlag) bool {
	return rcv._tab.MutateUint64Slot(12, uint64(n))
}

func (rcv *ExecRequestRaw) SandboxArg() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateSandboxArg(n int64) bool {
	return rcv._tab.MutateInt64Slot(14, n)
}

func (rcv *ExecRequestRaw) SignalFilter(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *ExecRequestRaw) SignalFilterLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateSignalFilter(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *ExecRequestRaw) SignalFilterCall() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateSignalFilterCall(n int32) bool {
	return rcv._tab.MutateInt32Slot(18, n)
}

func (rcv *ExecRequestRaw) Repeat() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequestRaw) MutateRepeat(n int32) bool {
	return rcv._tab.MutateInt32Slot(20, n)
}

func ExecRequestRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(9)
}
func ExecRequestRawAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(0, id, 0)
}
func ExecRequestRawAddProgData(builder *flatbuffers.Builder, progData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(progData), 0)
}
func ExecRequestRawStartProgDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ExecRequestRawAddFlags(builder *flatbuffers.Builder, flags RequestFlag) {
	builder.PrependUint64Slot(2, uint64(flags), 0)
}
func ExecRequestRawAddExecEnv(builder *flatbuffers.Builder, execEnv ExecEnv) {
	builder.PrependUint64Slot(3, uint64(execEnv), 0)
}
func ExecRequestRawAddExecFlags(builder *flatbuffers.Builder, execFlags ExecFlag) {
	builder.PrependUint64Slot(4, uint64(execFlags), 0)
}
func ExecRequestRawAddSandboxArg(builder *flatbuffers.Builder, sandboxArg int64) {
	builder.PrependInt64Slot(5, sandboxArg, 0)
}
func ExecRequestRawAddSignalFilter(builder *flatbuffers.Builder, signalFilter flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(signalFilter), 0)
}
func ExecRequestRawStartSignalFilterVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ExecRequestRawAddSignalFilterCall(builder *flatbuffers.Builder, signalFilterCall int32) {
	builder.PrependInt32Slot(7, signalFilterCall, 0)
}
func ExecRequestRawAddRepeat(builder *flatbuffers.Builder, repeat int32) {
	builder.PrependInt32Slot(8, repeat, 0)
}
func ExecRequestRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type SignalUpdateRawT struct {
	NewMax  []uint32 `json:"new_max"`
	DropMax []uint32 `json:"drop_max"`
}

func (t *SignalUpdateRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	newMaxOffset := flatbuffers.UOffsetT(0)
	if t.NewMax != nil {
		newMaxLength := len(t.NewMax)
		SignalUpdateRawStartNewMaxVector(builder, newMaxLength)
		for j := newMaxLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.NewMax[j])
		}
		newMaxOffset = builder.EndVector(newMaxLength)
	}
	dropMaxOffset := flatbuffers.UOffsetT(0)
	if t.DropMax != nil {
		dropMaxLength := len(t.DropMax)
		SignalUpdateRawStartDropMaxVector(builder, dropMaxLength)
		for j := dropMaxLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.DropMax[j])
		}
		dropMaxOffset = builder.EndVector(dropMaxLength)
	}
	SignalUpdateRawStart(builder)
	SignalUpdateRawAddNewMax(builder, newMaxOffset)
	SignalUpdateRawAddDropMax(builder, dropMaxOffset)
	return SignalUpdateRawEnd(builder)
}

func (rcv *SignalUpdateRaw) UnPackTo(t *SignalUpdateRawT) {
	newMaxLength := rcv.NewMaxLength()
	t.NewMax = make([]uint32, newMaxLength)
	for j := 0; j < newMaxLength; j++ {
		t.NewMax[j] = rcv.NewMax(j)
	}
	dropMaxLength := rcv.DropMaxLength()
	t.DropMax = make([]uint32, dropMaxLength)
	for j := 0; j < dropMaxLength; j++ {
		t.DropMax[j] = rcv.DropMax(j)
	}
}

func (rcv *SignalUpdateRaw) UnPack() *SignalUpdateRawT {
	if rcv == nil {
		return nil
	}
	t := &SignalUpdateRawT{}
	rcv.UnPackTo(t)
	return t
}

type SignalUpdateRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsSignalUpdateRaw(buf []byte, offset flatbuffers.UOffsetT) *SignalUpdateRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SignalUpdateRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSignalUpdateRaw(buf []byte, offset flatbuffers.UOffsetT) *SignalUpdateRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SignalUpdateRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SignalUpdateRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SignalUpdateRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SignalUpdateRaw) NewMax(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SignalUpdateRaw) NewMaxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SignalUpdateRaw) MutateNewMax(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *SignalUpdateRaw) DropMax(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SignalUpdateRaw) DropMaxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SignalUpdateRaw) MutateDropMax(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func SignalUpdateRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func SignalUpdateRawAddNewMax(builder *flatbuffers.Builder, newMax flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(newMax), 0)
}
func SignalUpdateRawStartNewMaxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SignalUpdateRawAddDropMax(builder *flatbuffers.Builder, dropMax flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(dropMax), 0)
}
func SignalUpdateRawStartDropMaxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SignalUpdateRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecutingMessageRawT struct {
	Id     int64 `json:"id"`
	ProcId int32 `json:"proc_id"`
	Try    int32 `json:"try"`
}

func (t *ExecutingMessageRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	ExecutingMessageRawStart(builder)
	ExecutingMessageRawAddId(builder, t.Id)
	ExecutingMessageRawAddProcId(builder, t.ProcId)
	ExecutingMessageRawAddTry(builder, t.Try)
	return ExecutingMessageRawEnd(builder)
}

func (rcv *ExecutingMessageRaw) UnPackTo(t *ExecutingMessageRawT) {
	t.Id = rcv.Id()
	t.ProcId = rcv.ProcId()
	t.Try = rcv.Try()
}

func (rcv *ExecutingMessageRaw) UnPack() *ExecutingMessageRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecutingMessageRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecutingMessageRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsExecutingMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecutingMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecutingMessageRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecutingMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecutingMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecutingMessageRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecutingMessageRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecutingMessageRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecutingMessageRaw) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessageRaw) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *ExecutingMessageRaw) ProcId() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessageRaw) MutateProcId(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ExecutingMessageRaw) Try() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessageRaw) MutateTry(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func ExecutingMessageRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ExecutingMessageRawAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(0, id, 0)
}
func ExecutingMessageRawAddProcId(builder *flatbuffers.Builder, procId int32) {
	builder.PrependInt32Slot(1, procId, 0)
}
func ExecutingMessageRawAddTry(builder *flatbuffers.Builder, try int32) {
	builder.PrependInt32Slot(2, try, 0)
}
func ExecutingMessageRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type StatsMessageRawT struct {
	NoexecCount    int64 `json:"noexec_count"`
	NoexecDuration int64 `json:"noexec_duration"`
}

func (t *StatsMessageRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	StatsMessageRawStart(builder)
	StatsMessageRawAddNoexecCount(builder, t.NoexecCount)
	StatsMessageRawAddNoexecDuration(builder, t.NoexecDuration)
	return StatsMessageRawEnd(builder)
}

func (rcv *StatsMessageRaw) UnPackTo(t *StatsMessageRawT) {
	t.NoexecCount = rcv.NoexecCount()
	t.NoexecDuration = rcv.NoexecDuration()
}

func (rcv *StatsMessageRaw) UnPack() *StatsMessageRawT {
	if rcv == nil {
		return nil
	}
	t := &StatsMessageRawT{}
	rcv.UnPackTo(t)
	return t
}

type StatsMessageRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsStatsMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *StatsMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StatsMessageRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsStatsMessageRaw(buf []byte, offset flatbuffers.UOffsetT) *StatsMessageRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &StatsMessageRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *StatsMessageRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StatsMessageRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *StatsMessageRaw) NoexecCount() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *StatsMessageRaw) MutateNoexecCount(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *StatsMessageRaw) NoexecDuration() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *StatsMessageRaw) MutateNoexecDuration(n int64) bool {
	return rcv._tab.MutateInt64Slot(6, n)
}

func StatsMessageRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func StatsMessageRawAddNoexecCount(builder *flatbuffers.Builder, noexecCount int64) {
	builder.PrependInt64Slot(0, noexecCount, 0)
}
func StatsMessageRawAddNoexecDuration(builder *flatbuffers.Builder, noexecDuration int64) {
	builder.PrependInt64Slot(1, noexecDuration, 0)
}
func StatsMessageRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type CallInfoRawT struct {
	Flags  CallFlag          `json:"flags"`
	Error  int32             `json:"error"`
	Signal []uint32          `json:"signal"`
	Cover  []uint32          `json:"cover"`
	Comps  []*ComparisonRawT `json:"comps"`
}

func (t *CallInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	signalOffset := flatbuffers.UOffsetT(0)
	if t.Signal != nil {
		signalLength := len(t.Signal)
		CallInfoRawStartSignalVector(builder, signalLength)
		for j := signalLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.Signal[j])
		}
		signalOffset = builder.EndVector(signalLength)
	}
	coverOffset := flatbuffers.UOffsetT(0)
	if t.Cover != nil {
		coverLength := len(t.Cover)
		CallInfoRawStartCoverVector(builder, coverLength)
		for j := coverLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.Cover[j])
		}
		coverOffset = builder.EndVector(coverLength)
	}
	compsOffset := flatbuffers.UOffsetT(0)
	if t.Comps != nil {
		compsLength := len(t.Comps)
		CallInfoRawStartCompsVector(builder, compsLength)
		for j := compsLength - 1; j >= 0; j-- {
			t.Comps[j].Pack(builder)
		}
		compsOffset = builder.EndVector(compsLength)
	}
	CallInfoRawStart(builder)
	CallInfoRawAddFlags(builder, t.Flags)
	CallInfoRawAddError(builder, t.Error)
	CallInfoRawAddSignal(builder, signalOffset)
	CallInfoRawAddCover(builder, coverOffset)
	CallInfoRawAddComps(builder, compsOffset)
	return CallInfoRawEnd(builder)
}

func (rcv *CallInfoRaw) UnPackTo(t *CallInfoRawT) {
	t.Flags = rcv.Flags()
	t.Error = rcv.Error()
	signalLength := rcv.SignalLength()
	t.Signal = make([]uint32, signalLength)
	for j := 0; j < signalLength; j++ {
		t.Signal[j] = rcv.Signal(j)
	}
	coverLength := rcv.CoverLength()
	t.Cover = make([]uint32, coverLength)
	for j := 0; j < coverLength; j++ {
		t.Cover[j] = rcv.Cover(j)
	}
	compsLength := rcv.CompsLength()
	t.Comps = make([]*ComparisonRawT, compsLength)
	for j := 0; j < compsLength; j++ {
		x := ComparisonRaw{}
		rcv.Comps(&x, j)
		t.Comps[j] = x.UnPack()
	}
}

func (rcv *CallInfoRaw) UnPack() *CallInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &CallInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type CallInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsCallInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *CallInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CallInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCallInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *CallInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CallInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CallInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CallInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *CallInfoRaw) Flags() CallFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return CallFlag(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *CallInfoRaw) MutateFlags(n CallFlag) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *CallInfoRaw) Error() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CallInfoRaw) MutateError(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *CallInfoRaw) Signal(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *CallInfoRaw) SignalLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *CallInfoRaw) MutateSignal(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *CallInfoRaw) Cover(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *CallInfoRaw) CoverLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *CallInfoRaw) MutateCover(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *CallInfoRaw) Comps(obj *ComparisonRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 16
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *CallInfoRaw) CompsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func CallInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func CallInfoRawAddFlags(builder *flatbuffers.Builder, flags CallFlag) {
	builder.PrependByteSlot(0, byte(flags), 0)
}
func CallInfoRawAddError(builder *flatbuffers.Builder, error int32) {
	builder.PrependInt32Slot(1, error, 0)
}
func CallInfoRawAddSignal(builder *flatbuffers.Builder, signal flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(signal), 0)
}
func CallInfoRawStartSignalVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func CallInfoRawAddCover(builder *flatbuffers.Builder, cover flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(cover), 0)
}
func CallInfoRawStartCoverVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func CallInfoRawAddComps(builder *flatbuffers.Builder, comps flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(comps), 0)
}
func CallInfoRawStartCompsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(16, numElems, 8)
}
func CallInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ComparisonRawT struct {
	Op1 uint64 `json:"op1"`
	Op2 uint64 `json:"op2"`
}

func (t *ComparisonRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	return CreateComparisonRaw(builder, t.Op1, t.Op2)
}
func (rcv *ComparisonRaw) UnPackTo(t *ComparisonRawT) {
	t.Op1 = rcv.Op1()
	t.Op2 = rcv.Op2()
}

func (rcv *ComparisonRaw) UnPack() *ComparisonRawT {
	if rcv == nil {
		return nil
	}
	t := &ComparisonRawT{}
	rcv.UnPackTo(t)
	return t
}

type ComparisonRaw struct {
	_tab flatbuffers.Struct
}

func (rcv *ComparisonRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ComparisonRaw) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *ComparisonRaw) Op1() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *ComparisonRaw) MutateOp1(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *ComparisonRaw) Op2() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
func (rcv *ComparisonRaw) MutateOp2(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func CreateComparisonRaw(builder *flatbuffers.Builder, op1 uint64, op2 uint64) flatbuffers.UOffsetT {
	builder.Prep(8, 16)
	builder.PrependUint64(op2)
	builder.PrependUint64(op1)
	return builder.Offset()
}

type ProgInfoRawT struct {
	Calls     []*CallInfoRawT `json:"calls"`
	Extra     *CallInfoRawT   `json:"extra"`
	Elapsed   uint64          `json:"elapsed"`
	Freshness uint64          `json:"freshness"`
}

func (t *ProgInfoRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	callsOffset := flatbuffers.UOffsetT(0)
	if t.Calls != nil {
		callsLength := len(t.Calls)
		callsOffsets := make([]flatbuffers.UOffsetT, callsLength)
		for j := 0; j < callsLength; j++ {
			callsOffsets[j] = t.Calls[j].Pack(builder)
		}
		ProgInfoRawStartCallsVector(builder, callsLength)
		for j := callsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(callsOffsets[j])
		}
		callsOffset = builder.EndVector(callsLength)
	}
	extraOffset := t.Extra.Pack(builder)
	ProgInfoRawStart(builder)
	ProgInfoRawAddCalls(builder, callsOffset)
	ProgInfoRawAddExtra(builder, extraOffset)
	ProgInfoRawAddElapsed(builder, t.Elapsed)
	ProgInfoRawAddFreshness(builder, t.Freshness)
	return ProgInfoRawEnd(builder)
}

func (rcv *ProgInfoRaw) UnPackTo(t *ProgInfoRawT) {
	callsLength := rcv.CallsLength()
	t.Calls = make([]*CallInfoRawT, callsLength)
	for j := 0; j < callsLength; j++ {
		x := CallInfoRaw{}
		rcv.Calls(&x, j)
		t.Calls[j] = x.UnPack()
	}
	t.Extra = rcv.Extra(nil).UnPack()
	t.Elapsed = rcv.Elapsed()
	t.Freshness = rcv.Freshness()
}

func (rcv *ProgInfoRaw) UnPack() *ProgInfoRawT {
	if rcv == nil {
		return nil
	}
	t := &ProgInfoRawT{}
	rcv.UnPackTo(t)
	return t
}

type ProgInfoRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsProgInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *ProgInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ProgInfoRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsProgInfoRaw(buf []byte, offset flatbuffers.UOffsetT) *ProgInfoRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ProgInfoRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ProgInfoRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ProgInfoRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ProgInfoRaw) Calls(obj *CallInfoRaw, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ProgInfoRaw) CallsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ProgInfoRaw) Extra(obj *CallInfoRaw) *CallInfoRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CallInfoRaw)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ProgInfoRaw) Elapsed() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ProgInfoRaw) MutateElapsed(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *ProgInfoRaw) Freshness() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ProgInfoRaw) MutateFreshness(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

func ProgInfoRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ProgInfoRawAddCalls(builder *flatbuffers.Builder, calls flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(calls), 0)
}
func ProgInfoRawStartCallsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ProgInfoRawAddExtra(builder *flatbuffers.Builder, extra flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(extra), 0)
}
func ProgInfoRawAddElapsed(builder *flatbuffers.Builder, elapsed uint64) {
	builder.PrependUint64Slot(2, elapsed, 0)
}
func ProgInfoRawAddFreshness(builder *flatbuffers.Builder, freshness uint64) {
	builder.PrependUint64Slot(3, freshness, 0)
}
func ProgInfoRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecResultRawT struct {
	Executing *ExecutingMessageRawT `json:"executing"`
	Output    []byte                `json:"output"`
	Error     string                `json:"error"`
	Info      *ProgInfoRawT         `json:"info"`
}

func (t *ExecResultRawT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	executingOffset := t.Executing.Pack(builder)
	outputOffset := flatbuffers.UOffsetT(0)
	if t.Output != nil {
		outputOffset = builder.CreateByteString(t.Output)
	}
	errorOffset := builder.CreateString(t.Error)
	infoOffset := t.Info.Pack(builder)
	ExecResultRawStart(builder)
	ExecResultRawAddExecuting(builder, executingOffset)
	ExecResultRawAddOutput(builder, outputOffset)
	ExecResultRawAddError(builder, errorOffset)
	ExecResultRawAddInfo(builder, infoOffset)
	return ExecResultRawEnd(builder)
}

func (rcv *ExecResultRaw) UnPackTo(t *ExecResultRawT) {
	t.Executing = rcv.Executing(nil).UnPack()
	t.Output = rcv.OutputBytes()
	t.Error = string(rcv.Error())
	t.Info = rcv.Info(nil).UnPack()
}

func (rcv *ExecResultRaw) UnPack() *ExecResultRawT {
	if rcv == nil {
		return nil
	}
	t := &ExecResultRawT{}
	rcv.UnPackTo(t)
	return t
}

type ExecResultRaw struct {
	_tab flatbuffers.Table
}

func GetRootAsExecResultRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecResultRaw {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecResultRaw{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecResultRaw(buf []byte, offset flatbuffers.UOffsetT) *ExecResultRaw {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecResultRaw{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecResultRaw) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecResultRaw) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecResultRaw) Executing(obj *ExecutingMessageRaw) *ExecutingMessageRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ExecutingMessageRaw)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ExecResultRaw) Output(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ExecResultRaw) OutputLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecResultRaw) OutputBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecResultRaw) MutateOutput(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *ExecResultRaw) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecResultRaw) Info(obj *ProgInfoRaw) *ProgInfoRaw {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ProgInfoRaw)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func ExecResultRawStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ExecResultRawAddExecuting(builder *flatbuffers.Builder, executing flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(executing), 0)
}
func ExecResultRawAddOutput(builder *flatbuffers.Builder, output flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(output), 0)
}
func ExecResultRawStartOutputVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ExecResultRawAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(error), 0)
}
func ExecResultRawAddInfo(builder *flatbuffers.Builder, info flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(info), 0)
}
func ExecResultRawEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
