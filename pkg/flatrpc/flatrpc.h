// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATRPC_RPC_H_
#define FLATBUFFERS_GENERATED_FLATRPC_RPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace rpc {

struct ConnectRequestRaw;
struct ConnectRequestRawBuilder;
struct ConnectRequestRawT;

struct ConnectReplyRaw;
struct ConnectReplyRawBuilder;
struct ConnectReplyRawT;

struct InfoRequestRaw;
struct InfoRequestRawBuilder;
struct InfoRequestRawT;

struct InfoReplyRaw;
struct InfoReplyRawBuilder;
struct InfoReplyRawT;

struct FileInfoRaw;
struct FileInfoRawBuilder;
struct FileInfoRawT;

struct GlobInfoRaw;
struct GlobInfoRawBuilder;
struct GlobInfoRawT;

struct FeatureInfoRaw;
struct FeatureInfoRawBuilder;
struct FeatureInfoRawT;

struct HostMessageRaw;
struct HostMessageRawBuilder;
struct HostMessageRawT;

struct ExecutorMessageRaw;
struct ExecutorMessageRawBuilder;
struct ExecutorMessageRawT;

struct ExecOptsRaw;

struct ExecRequestRaw;
struct ExecRequestRawBuilder;
struct ExecRequestRawT;

struct SignalUpdateRaw;
struct SignalUpdateRawBuilder;
struct SignalUpdateRawT;

struct StartLeakChecksRaw;
struct StartLeakChecksRawBuilder;
struct StartLeakChecksRawT;

struct ExecutingMessageRaw;
struct ExecutingMessageRawBuilder;
struct ExecutingMessageRawT;

struct CallInfoRaw;
struct CallInfoRawBuilder;
struct CallInfoRawT;

struct ComparisonRaw;

struct ProgInfoRaw;
struct ProgInfoRawBuilder;
struct ProgInfoRawT;

struct ExecResultRaw;
struct ExecResultRawBuilder;
struct ExecResultRawT;

enum class Feature : uint64_t {
  Coverage = 1ULL,
  Comparisons = 2ULL,
  ExtraCoverage = 4ULL,
  DelayKcovMmap = 8ULL,
  SandboxSetuid = 16ULL,
  SandboxNamespace = 32ULL,
  SandboxAndroid = 64ULL,
  Fault = 128ULL,
  Leak = 256ULL,
  NetInjection = 512ULL,
  NetDevices = 1024ULL,
  KCSAN = 2048ULL,
  DevlinkPCI = 4096ULL,
  NicVF = 8192ULL,
  USBEmulation = 16384ULL,
  VhciInjection = 32768ULL,
  WifiEmulation = 65536ULL,
  LRWPANEmulation = 131072ULL,
  BinFmtMisc = 262144ULL,
  Swap = 524288ULL,
  NONE = 0,
  ANY = 1048575ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(Feature, uint64_t)

inline const Feature (&EnumValuesFeature())[20] {
  static const Feature values[] = {
    Feature::Coverage,
    Feature::Comparisons,
    Feature::ExtraCoverage,
    Feature::DelayKcovMmap,
    Feature::SandboxSetuid,
    Feature::SandboxNamespace,
    Feature::SandboxAndroid,
    Feature::Fault,
    Feature::Leak,
    Feature::NetInjection,
    Feature::NetDevices,
    Feature::KCSAN,
    Feature::DevlinkPCI,
    Feature::NicVF,
    Feature::USBEmulation,
    Feature::VhciInjection,
    Feature::WifiEmulation,
    Feature::LRWPANEmulation,
    Feature::BinFmtMisc,
    Feature::Swap
  };
  return values;
}

inline const char *EnumNameFeature(Feature e) {
  switch (e) {
    case Feature::Coverage: return "Coverage";
    case Feature::Comparisons: return "Comparisons";
    case Feature::ExtraCoverage: return "ExtraCoverage";
    case Feature::DelayKcovMmap: return "DelayKcovMmap";
    case Feature::SandboxSetuid: return "SandboxSetuid";
    case Feature::SandboxNamespace: return "SandboxNamespace";
    case Feature::SandboxAndroid: return "SandboxAndroid";
    case Feature::Fault: return "Fault";
    case Feature::Leak: return "Leak";
    case Feature::NetInjection: return "NetInjection";
    case Feature::NetDevices: return "NetDevices";
    case Feature::KCSAN: return "KCSAN";
    case Feature::DevlinkPCI: return "DevlinkPCI";
    case Feature::NicVF: return "NicVF";
    case Feature::USBEmulation: return "USBEmulation";
    case Feature::VhciInjection: return "VhciInjection";
    case Feature::WifiEmulation: return "WifiEmulation";
    case Feature::LRWPANEmulation: return "LRWPANEmulation";
    case Feature::BinFmtMisc: return "BinFmtMisc";
    case Feature::Swap: return "Swap";
    default: return "";
  }
}

enum class HostMessagesRaw : uint8_t {
  NONE = 0,
  ExecRequest = 1,
  SignalUpdate = 2,
  StartLeakChecks = 3,
  MIN = NONE,
  MAX = StartLeakChecks
};

inline const HostMessagesRaw (&EnumValuesHostMessagesRaw())[4] {
  static const HostMessagesRaw values[] = {
    HostMessagesRaw::NONE,
    HostMessagesRaw::ExecRequest,
    HostMessagesRaw::SignalUpdate,
    HostMessagesRaw::StartLeakChecks
  };
  return values;
}

inline const char * const *EnumNamesHostMessagesRaw() {
  static const char * const names[5] = {
    "NONE",
    "ExecRequest",
    "SignalUpdate",
    "StartLeakChecks",
    nullptr
  };
  return names;
}

inline const char *EnumNameHostMessagesRaw(HostMessagesRaw e) {
  if (flatbuffers::IsOutRange(e, HostMessagesRaw::NONE, HostMessagesRaw::StartLeakChecks)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHostMessagesRaw()[index];
}

template<typename T> struct HostMessagesRawTraits {
  static const HostMessagesRaw enum_value = HostMessagesRaw::NONE;
};

template<> struct HostMessagesRawTraits<rpc::ExecRequestRaw> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::ExecRequest;
};

template<> struct HostMessagesRawTraits<rpc::SignalUpdateRaw> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::SignalUpdate;
};

template<> struct HostMessagesRawTraits<rpc::StartLeakChecksRaw> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::StartLeakChecks;
};

template<typename T> struct HostMessagesRawUnionTraits {
  static const HostMessagesRaw enum_value = HostMessagesRaw::NONE;
};

template<> struct HostMessagesRawUnionTraits<rpc::ExecRequestRawT> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::ExecRequest;
};

template<> struct HostMessagesRawUnionTraits<rpc::SignalUpdateRawT> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::SignalUpdate;
};

template<> struct HostMessagesRawUnionTraits<rpc::StartLeakChecksRawT> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::StartLeakChecks;
};

struct HostMessagesRawUnion {
  HostMessagesRaw type;
  void *value;

  HostMessagesRawUnion() : type(HostMessagesRaw::NONE), value(nullptr) {}
  HostMessagesRawUnion(HostMessagesRawUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(HostMessagesRaw::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  HostMessagesRawUnion(const HostMessagesRawUnion &);
  HostMessagesRawUnion &operator=(const HostMessagesRawUnion &u)
    { HostMessagesRawUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  HostMessagesRawUnion &operator=(HostMessagesRawUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~HostMessagesRawUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = HostMessagesRawUnionTraits<RT>::enum_value;
    if (type != HostMessagesRaw::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, HostMessagesRaw type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  rpc::ExecRequestRawT *AsExecRequest() {
    return type == HostMessagesRaw::ExecRequest ?
      reinterpret_cast<rpc::ExecRequestRawT *>(value) : nullptr;
  }
  const rpc::ExecRequestRawT *AsExecRequest() const {
    return type == HostMessagesRaw::ExecRequest ?
      reinterpret_cast<const rpc::ExecRequestRawT *>(value) : nullptr;
  }
  rpc::SignalUpdateRawT *AsSignalUpdate() {
    return type == HostMessagesRaw::SignalUpdate ?
      reinterpret_cast<rpc::SignalUpdateRawT *>(value) : nullptr;
  }
  const rpc::SignalUpdateRawT *AsSignalUpdate() const {
    return type == HostMessagesRaw::SignalUpdate ?
      reinterpret_cast<const rpc::SignalUpdateRawT *>(value) : nullptr;
  }
  rpc::StartLeakChecksRawT *AsStartLeakChecks() {
    return type == HostMessagesRaw::StartLeakChecks ?
      reinterpret_cast<rpc::StartLeakChecksRawT *>(value) : nullptr;
  }
  const rpc::StartLeakChecksRawT *AsStartLeakChecks() const {
    return type == HostMessagesRaw::StartLeakChecks ?
      reinterpret_cast<const rpc::StartLeakChecksRawT *>(value) : nullptr;
  }
};

bool VerifyHostMessagesRaw(flatbuffers::Verifier &verifier, const void *obj, HostMessagesRaw type);
bool VerifyHostMessagesRawVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<HostMessagesRaw> *types);

enum class ExecutorMessagesRaw : uint8_t {
  NONE = 0,
  ExecResult = 1,
  Executing = 2,
  MIN = NONE,
  MAX = Executing
};

inline const ExecutorMessagesRaw (&EnumValuesExecutorMessagesRaw())[3] {
  static const ExecutorMessagesRaw values[] = {
    ExecutorMessagesRaw::NONE,
    ExecutorMessagesRaw::ExecResult,
    ExecutorMessagesRaw::Executing
  };
  return values;
}

inline const char * const *EnumNamesExecutorMessagesRaw() {
  static const char * const names[4] = {
    "NONE",
    "ExecResult",
    "Executing",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecutorMessagesRaw(ExecutorMessagesRaw e) {
  if (flatbuffers::IsOutRange(e, ExecutorMessagesRaw::NONE, ExecutorMessagesRaw::Executing)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutorMessagesRaw()[index];
}

template<typename T> struct ExecutorMessagesRawTraits {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::NONE;
};

template<> struct ExecutorMessagesRawTraits<rpc::ExecResultRaw> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::ExecResult;
};

template<> struct ExecutorMessagesRawTraits<rpc::ExecutingMessageRaw> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::Executing;
};

template<typename T> struct ExecutorMessagesRawUnionTraits {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::NONE;
};

template<> struct ExecutorMessagesRawUnionTraits<rpc::ExecResultRawT> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::ExecResult;
};

template<> struct ExecutorMessagesRawUnionTraits<rpc::ExecutingMessageRawT> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::Executing;
};

struct ExecutorMessagesRawUnion {
  ExecutorMessagesRaw type;
  void *value;

  ExecutorMessagesRawUnion() : type(ExecutorMessagesRaw::NONE), value(nullptr) {}
  ExecutorMessagesRawUnion(ExecutorMessagesRawUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ExecutorMessagesRaw::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ExecutorMessagesRawUnion(const ExecutorMessagesRawUnion &);
  ExecutorMessagesRawUnion &operator=(const ExecutorMessagesRawUnion &u)
    { ExecutorMessagesRawUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ExecutorMessagesRawUnion &operator=(ExecutorMessagesRawUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ExecutorMessagesRawUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ExecutorMessagesRawUnionTraits<RT>::enum_value;
    if (type != ExecutorMessagesRaw::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ExecutorMessagesRaw type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  rpc::ExecResultRawT *AsExecResult() {
    return type == ExecutorMessagesRaw::ExecResult ?
      reinterpret_cast<rpc::ExecResultRawT *>(value) : nullptr;
  }
  const rpc::ExecResultRawT *AsExecResult() const {
    return type == ExecutorMessagesRaw::ExecResult ?
      reinterpret_cast<const rpc::ExecResultRawT *>(value) : nullptr;
  }
  rpc::ExecutingMessageRawT *AsExecuting() {
    return type == ExecutorMessagesRaw::Executing ?
      reinterpret_cast<rpc::ExecutingMessageRawT *>(value) : nullptr;
  }
  const rpc::ExecutingMessageRawT *AsExecuting() const {
    return type == ExecutorMessagesRaw::Executing ?
      reinterpret_cast<const rpc::ExecutingMessageRawT *>(value) : nullptr;
  }
};

bool VerifyExecutorMessagesRaw(flatbuffers::Verifier &verifier, const void *obj, ExecutorMessagesRaw type);
bool VerifyExecutorMessagesRawVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ExecutorMessagesRaw> *types);

enum class RequestFlag : uint64_t {
  IsBinary = 1ULL,
  ResetState = 2ULL,
  ReturnOutput = 4ULL,
  ReturnError = 8ULL,
  NONE = 0,
  ANY = 15ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(RequestFlag, uint64_t)

inline const RequestFlag (&EnumValuesRequestFlag())[4] {
  static const RequestFlag values[] = {
    RequestFlag::IsBinary,
    RequestFlag::ResetState,
    RequestFlag::ReturnOutput,
    RequestFlag::ReturnError
  };
  return values;
}

inline const char * const *EnumNamesRequestFlag() {
  static const char * const names[9] = {
    "IsBinary",
    "ResetState",
    "",
    "ReturnOutput",
    "",
    "",
    "",
    "ReturnError",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestFlag(RequestFlag e) {
  if (flatbuffers::IsOutRange(e, RequestFlag::IsBinary, RequestFlag::ReturnError)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(RequestFlag::IsBinary);
  return EnumNamesRequestFlag()[index];
}

enum class ExecEnv : uint64_t {
  Debug = 1ULL,
  Signal = 2ULL,
  SandboxSetuid = 4ULL,
  SandboxNamespace = 8ULL,
  SandboxAndroid = 16ULL,
  ExtraCover = 32ULL,
  EnableTun = 64ULL,
  EnableNetDev = 128ULL,
  EnableNetReset = 256ULL,
  EnableCgroups = 512ULL,
  EnableCloseFds = 1024ULL,
  EnableDevlinkPCI = 2048ULL,
  EnableVhciInjection = 4096ULL,
  EnableWifi = 8192ULL,
  DelayKcovMmap = 16384ULL,
  EnableNicVF = 32768ULL,
  NONE = 0,
  ANY = 65535ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(ExecEnv, uint64_t)

inline const ExecEnv (&EnumValuesExecEnv())[16] {
  static const ExecEnv values[] = {
    ExecEnv::Debug,
    ExecEnv::Signal,
    ExecEnv::SandboxSetuid,
    ExecEnv::SandboxNamespace,
    ExecEnv::SandboxAndroid,
    ExecEnv::ExtraCover,
    ExecEnv::EnableTun,
    ExecEnv::EnableNetDev,
    ExecEnv::EnableNetReset,
    ExecEnv::EnableCgroups,
    ExecEnv::EnableCloseFds,
    ExecEnv::EnableDevlinkPCI,
    ExecEnv::EnableVhciInjection,
    ExecEnv::EnableWifi,
    ExecEnv::DelayKcovMmap,
    ExecEnv::EnableNicVF
  };
  return values;
}

inline const char *EnumNameExecEnv(ExecEnv e) {
  switch (e) {
    case ExecEnv::Debug: return "Debug";
    case ExecEnv::Signal: return "Signal";
    case ExecEnv::SandboxSetuid: return "SandboxSetuid";
    case ExecEnv::SandboxNamespace: return "SandboxNamespace";
    case ExecEnv::SandboxAndroid: return "SandboxAndroid";
    case ExecEnv::ExtraCover: return "ExtraCover";
    case ExecEnv::EnableTun: return "EnableTun";
    case ExecEnv::EnableNetDev: return "EnableNetDev";
    case ExecEnv::EnableNetReset: return "EnableNetReset";
    case ExecEnv::EnableCgroups: return "EnableCgroups";
    case ExecEnv::EnableCloseFds: return "EnableCloseFds";
    case ExecEnv::EnableDevlinkPCI: return "EnableDevlinkPCI";
    case ExecEnv::EnableVhciInjection: return "EnableVhciInjection";
    case ExecEnv::EnableWifi: return "EnableWifi";
    case ExecEnv::DelayKcovMmap: return "DelayKcovMmap";
    case ExecEnv::EnableNicVF: return "EnableNicVF";
    default: return "";
  }
}

enum class ExecFlag : uint64_t {
  CollectSignal = 1ULL,
  CollectCover = 2ULL,
  DedupCover = 4ULL,
  CollectComps = 8ULL,
  Threaded = 16ULL,
  CoverFilter = 32ULL,
  NONE = 0,
  ANY = 63ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(ExecFlag, uint64_t)

inline const ExecFlag (&EnumValuesExecFlag())[6] {
  static const ExecFlag values[] = {
    ExecFlag::CollectSignal,
    ExecFlag::CollectCover,
    ExecFlag::DedupCover,
    ExecFlag::CollectComps,
    ExecFlag::Threaded,
    ExecFlag::CoverFilter
  };
  return values;
}

inline const char *EnumNameExecFlag(ExecFlag e) {
  switch (e) {
    case ExecFlag::CollectSignal: return "CollectSignal";
    case ExecFlag::CollectCover: return "CollectCover";
    case ExecFlag::DedupCover: return "DedupCover";
    case ExecFlag::CollectComps: return "CollectComps";
    case ExecFlag::Threaded: return "Threaded";
    case ExecFlag::CoverFilter: return "CoverFilter";
    default: return "";
  }
}

enum class CallFlag : uint8_t {
  Executed = 1,
  Finished = 2,
  Blocked = 4,
  FaultInjected = 8,
  NONE = 0,
  ANY = 15
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(CallFlag, uint8_t)

inline const CallFlag (&EnumValuesCallFlag())[4] {
  static const CallFlag values[] = {
    CallFlag::Executed,
    CallFlag::Finished,
    CallFlag::Blocked,
    CallFlag::FaultInjected
  };
  return values;
}

inline const char * const *EnumNamesCallFlag() {
  static const char * const names[9] = {
    "Executed",
    "Finished",
    "",
    "Blocked",
    "",
    "",
    "",
    "FaultInjected",
    nullptr
  };
  return names;
}

inline const char *EnumNameCallFlag(CallFlag e) {
  if (flatbuffers::IsOutRange(e, CallFlag::Executed, CallFlag::FaultInjected)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(CallFlag::Executed);
  return EnumNamesCallFlag()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ExecOptsRaw FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t env_flags_;
  uint64_t exec_flags_;
  int64_t sandbox_arg_;

 public:
  ExecOptsRaw()
      : env_flags_(0),
        exec_flags_(0),
        sandbox_arg_(0) {
  }
  ExecOptsRaw(rpc::ExecEnv _env_flags, rpc::ExecFlag _exec_flags, int64_t _sandbox_arg)
      : env_flags_(flatbuffers::EndianScalar(static_cast<uint64_t>(_env_flags))),
        exec_flags_(flatbuffers::EndianScalar(static_cast<uint64_t>(_exec_flags))),
        sandbox_arg_(flatbuffers::EndianScalar(_sandbox_arg)) {
  }
  rpc::ExecEnv env_flags() const {
    return static_cast<rpc::ExecEnv>(flatbuffers::EndianScalar(env_flags_));
  }
  rpc::ExecFlag exec_flags() const {
    return static_cast<rpc::ExecFlag>(flatbuffers::EndianScalar(exec_flags_));
  }
  int64_t sandbox_arg() const {
    return flatbuffers::EndianScalar(sandbox_arg_);
  }
};
FLATBUFFERS_STRUCT_END(ExecOptsRaw, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ComparisonRaw FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t op1_;
  uint64_t op2_;

 public:
  ComparisonRaw()
      : op1_(0),
        op2_(0) {
  }
  ComparisonRaw(uint64_t _op1, uint64_t _op2)
      : op1_(flatbuffers::EndianScalar(_op1)),
        op2_(flatbuffers::EndianScalar(_op2)) {
  }
  uint64_t op1() const {
    return flatbuffers::EndianScalar(op1_);
  }
  uint64_t op2() const {
    return flatbuffers::EndianScalar(op2_);
  }
};
FLATBUFFERS_STRUCT_END(ComparisonRaw, 16);

struct ConnectRequestRawT : public flatbuffers::NativeTable {
  typedef ConnectRequestRaw TableType;
  std::string name{};
  std::string arch{};
  std::string git_revision{};
  std::string syz_revision{};
};

struct ConnectRequestRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectRequestRawT NativeTableType;
  typedef ConnectRequestRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ARCH = 6,
    VT_GIT_REVISION = 8,
    VT_SYZ_REVISION = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *arch() const {
    return GetPointer<const flatbuffers::String *>(VT_ARCH);
  }
  const flatbuffers::String *git_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_GIT_REVISION);
  }
  const flatbuffers::String *syz_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_SYZ_REVISION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ARCH) &&
           verifier.VerifyString(arch()) &&
           VerifyOffset(verifier, VT_GIT_REVISION) &&
           verifier.VerifyString(git_revision()) &&
           VerifyOffset(verifier, VT_SYZ_REVISION) &&
           verifier.VerifyString(syz_revision()) &&
           verifier.EndTable();
  }
  ConnectRequestRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConnectRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConnectRequestRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConnectRequestRawBuilder {
  typedef ConnectRequestRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ConnectRequestRaw::VT_NAME, name);
  }
  void add_arch(flatbuffers::Offset<flatbuffers::String> arch) {
    fbb_.AddOffset(ConnectRequestRaw::VT_ARCH, arch);
  }
  void add_git_revision(flatbuffers::Offset<flatbuffers::String> git_revision) {
    fbb_.AddOffset(ConnectRequestRaw::VT_GIT_REVISION, git_revision);
  }
  void add_syz_revision(flatbuffers::Offset<flatbuffers::String> syz_revision) {
    fbb_.AddOffset(ConnectRequestRaw::VT_SYZ_REVISION, syz_revision);
  }
  explicit ConnectRequestRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectRequestRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectRequestRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectRequestRaw> CreateConnectRequestRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> arch = 0,
    flatbuffers::Offset<flatbuffers::String> git_revision = 0,
    flatbuffers::Offset<flatbuffers::String> syz_revision = 0) {
  ConnectRequestRawBuilder builder_(_fbb);
  builder_.add_syz_revision(syz_revision);
  builder_.add_git_revision(git_revision);
  builder_.add_arch(arch);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectRequestRaw> CreateConnectRequestRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *arch = nullptr,
    const char *git_revision = nullptr,
    const char *syz_revision = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto arch__ = arch ? _fbb.CreateString(arch) : 0;
  auto git_revision__ = git_revision ? _fbb.CreateString(git_revision) : 0;
  auto syz_revision__ = syz_revision ? _fbb.CreateString(syz_revision) : 0;
  return rpc::CreateConnectRequestRaw(
      _fbb,
      name__,
      arch__,
      git_revision__,
      syz_revision__);
}

flatbuffers::Offset<ConnectRequestRaw> CreateConnectRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConnectReplyRawT : public flatbuffers::NativeTable {
  typedef ConnectReplyRaw TableType;
  bool debug = false;
  int32_t procs = 0;
  int32_t slowdown = 0;
  std::vector<std::string> leak_frames{};
  std::vector<std::string> race_frames{};
  rpc::Feature features = static_cast<rpc::Feature>(0);
  std::vector<std::string> files{};
  std::vector<std::string> globs{};
};

struct ConnectReplyRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectReplyRawT NativeTableType;
  typedef ConnectReplyRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEBUG = 4,
    VT_PROCS = 6,
    VT_SLOWDOWN = 8,
    VT_LEAK_FRAMES = 10,
    VT_RACE_FRAMES = 12,
    VT_FEATURES = 14,
    VT_FILES = 16,
    VT_GLOBS = 18
  };
  bool debug() const {
    return GetField<uint8_t>(VT_DEBUG, 0) != 0;
  }
  int32_t procs() const {
    return GetField<int32_t>(VT_PROCS, 0);
  }
  int32_t slowdown() const {
    return GetField<int32_t>(VT_SLOWDOWN, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *leak_frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LEAK_FRAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *race_frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_RACE_FRAMES);
  }
  rpc::Feature features() const {
    return static_cast<rpc::Feature>(GetField<uint64_t>(VT_FEATURES, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *globs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_GLOBS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DEBUG, 1) &&
           VerifyField<int32_t>(verifier, VT_PROCS, 4) &&
           VerifyField<int32_t>(verifier, VT_SLOWDOWN, 4) &&
           VerifyOffset(verifier, VT_LEAK_FRAMES) &&
           verifier.VerifyVector(leak_frames()) &&
           verifier.VerifyVectorOfStrings(leak_frames()) &&
           VerifyOffset(verifier, VT_RACE_FRAMES) &&
           verifier.VerifyVector(race_frames()) &&
           verifier.VerifyVectorOfStrings(race_frames()) &&
           VerifyField<uint64_t>(verifier, VT_FEATURES, 8) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           VerifyOffset(verifier, VT_GLOBS) &&
           verifier.VerifyVector(globs()) &&
           verifier.VerifyVectorOfStrings(globs()) &&
           verifier.EndTable();
  }
  ConnectReplyRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConnectReplyRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConnectReplyRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConnectReplyRawBuilder {
  typedef ConnectReplyRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debug(bool debug) {
    fbb_.AddElement<uint8_t>(ConnectReplyRaw::VT_DEBUG, static_cast<uint8_t>(debug), 0);
  }
  void add_procs(int32_t procs) {
    fbb_.AddElement<int32_t>(ConnectReplyRaw::VT_PROCS, procs, 0);
  }
  void add_slowdown(int32_t slowdown) {
    fbb_.AddElement<int32_t>(ConnectReplyRaw::VT_SLOWDOWN, slowdown, 0);
  }
  void add_leak_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> leak_frames) {
    fbb_.AddOffset(ConnectReplyRaw::VT_LEAK_FRAMES, leak_frames);
  }
  void add_race_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> race_frames) {
    fbb_.AddOffset(ConnectReplyRaw::VT_RACE_FRAMES, race_frames);
  }
  void add_features(rpc::Feature features) {
    fbb_.AddElement<uint64_t>(ConnectReplyRaw::VT_FEATURES, static_cast<uint64_t>(features), 0);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) {
    fbb_.AddOffset(ConnectReplyRaw::VT_FILES, files);
  }
  void add_globs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> globs) {
    fbb_.AddOffset(ConnectReplyRaw::VT_GLOBS, globs);
  }
  explicit ConnectReplyRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectReplyRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectReplyRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectReplyRaw> CreateConnectReplyRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool debug = false,
    int32_t procs = 0,
    int32_t slowdown = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> leak_frames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> race_frames = 0,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> globs = 0) {
  ConnectReplyRawBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_globs(globs);
  builder_.add_files(files);
  builder_.add_race_frames(race_frames);
  builder_.add_leak_frames(leak_frames);
  builder_.add_slowdown(slowdown);
  builder_.add_procs(procs);
  builder_.add_debug(debug);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectReplyRaw> CreateConnectReplyRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool debug = false,
    int32_t procs = 0,
    int32_t slowdown = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *leak_frames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *race_frames = nullptr,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *globs = nullptr) {
  auto leak_frames__ = leak_frames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*leak_frames) : 0;
  auto race_frames__ = race_frames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*race_frames) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0;
  auto globs__ = globs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*globs) : 0;
  return rpc::CreateConnectReplyRaw(
      _fbb,
      debug,
      procs,
      slowdown,
      leak_frames__,
      race_frames__,
      features,
      files__,
      globs__);
}

flatbuffers::Offset<ConnectReplyRaw> CreateConnectReplyRaw(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InfoRequestRawT : public flatbuffers::NativeTable {
  typedef InfoRequestRaw TableType;
  std::string error{};
  std::vector<std::unique_ptr<rpc::FeatureInfoRawT>> features{};
  std::vector<std::unique_ptr<rpc::FileInfoRawT>> files{};
  std::vector<std::unique_ptr<rpc::GlobInfoRawT>> globs{};
  InfoRequestRawT() = default;
  InfoRequestRawT(const InfoRequestRawT &o);
  InfoRequestRawT(InfoRequestRawT&&) FLATBUFFERS_NOEXCEPT = default;
  InfoRequestRawT &operator=(InfoRequestRawT o) FLATBUFFERS_NOEXCEPT;
};

struct InfoRequestRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InfoRequestRawT NativeTableType;
  typedef InfoRequestRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_FEATURES = 6,
    VT_FILES = 8,
    VT_GLOBS = 10
  };
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::FeatureInfoRaw>> *features() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::FeatureInfoRaw>> *>(VT_FEATURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfoRaw>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfoRaw>> *>(VT_FILES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfoRaw>> *globs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfoRaw>> *>(VT_GLOBS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           VerifyOffset(verifier, VT_GLOBS) &&
           verifier.VerifyVector(globs()) &&
           verifier.VerifyVectorOfTables(globs()) &&
           verifier.EndTable();
  }
  InfoRequestRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InfoRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InfoRequestRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InfoRequestRawBuilder {
  typedef InfoRequestRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(InfoRequestRaw::VT_ERROR, error);
  }
  void add_features(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FeatureInfoRaw>>> features) {
    fbb_.AddOffset(InfoRequestRaw::VT_FEATURES, features);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfoRaw>>> files) {
    fbb_.AddOffset(InfoRequestRaw::VT_FILES, files);
  }
  void add_globs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfoRaw>>> globs) {
    fbb_.AddOffset(InfoRequestRaw::VT_GLOBS, globs);
  }
  explicit InfoRequestRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InfoRequestRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfoRequestRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfoRequestRaw> CreateInfoRequestRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FeatureInfoRaw>>> features = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfoRaw>>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfoRaw>>> globs = 0) {
  InfoRequestRawBuilder builder_(_fbb);
  builder_.add_globs(globs);
  builder_.add_files(files);
  builder_.add_features(features);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<InfoRequestRaw> CreateInfoRequestRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    const std::vector<flatbuffers::Offset<rpc::FeatureInfoRaw>> *features = nullptr,
    const std::vector<flatbuffers::Offset<rpc::FileInfoRaw>> *files = nullptr,
    const std::vector<flatbuffers::Offset<rpc::GlobInfoRaw>> *globs = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto features__ = features ? _fbb.CreateVector<flatbuffers::Offset<rpc::FeatureInfoRaw>>(*features) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<rpc::FileInfoRaw>>(*files) : 0;
  auto globs__ = globs ? _fbb.CreateVector<flatbuffers::Offset<rpc::GlobInfoRaw>>(*globs) : 0;
  return rpc::CreateInfoRequestRaw(
      _fbb,
      error__,
      features__,
      files__,
      globs__);
}

flatbuffers::Offset<InfoRequestRaw> CreateInfoRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InfoReplyRawT : public flatbuffers::NativeTable {
  typedef InfoReplyRaw TableType;
  std::vector<uint8_t> cover_filter{};
};

struct InfoReplyRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InfoReplyRawT NativeTableType;
  typedef InfoReplyRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COVER_FILTER = 4
  };
  const flatbuffers::Vector<uint8_t> *cover_filter() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_COVER_FILTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COVER_FILTER) &&
           verifier.VerifyVector(cover_filter()) &&
           verifier.EndTable();
  }
  InfoReplyRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InfoReplyRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InfoReplyRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InfoReplyRawBuilder {
  typedef InfoReplyRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cover_filter(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cover_filter) {
    fbb_.AddOffset(InfoReplyRaw::VT_COVER_FILTER, cover_filter);
  }
  explicit InfoReplyRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InfoReplyRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfoReplyRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfoReplyRaw> CreateInfoReplyRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cover_filter = 0) {
  InfoReplyRawBuilder builder_(_fbb);
  builder_.add_cover_filter(cover_filter);
  return builder_.Finish();
}

inline flatbuffers::Offset<InfoReplyRaw> CreateInfoReplyRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *cover_filter = nullptr) {
  auto cover_filter__ = cover_filter ? _fbb.CreateVector<uint8_t>(*cover_filter) : 0;
  return rpc::CreateInfoReplyRaw(
      _fbb,
      cover_filter__);
}

flatbuffers::Offset<InfoReplyRaw> CreateInfoReplyRaw(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileInfoRawT : public flatbuffers::NativeTable {
  typedef FileInfoRaw TableType;
  std::string name{};
  bool exists = false;
  std::string error{};
  std::vector<uint8_t> data{};
};

struct FileInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileInfoRawT NativeTableType;
  typedef FileInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_EXISTS = 6,
    VT_ERROR = 8,
    VT_DATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool exists() const {
    return GetField<uint8_t>(VT_EXISTS, 0) != 0;
  }
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_EXISTS, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  FileInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FileInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileInfoRawBuilder {
  typedef FileInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FileInfoRaw::VT_NAME, name);
  }
  void add_exists(bool exists) {
    fbb_.AddElement<uint8_t>(FileInfoRaw::VT_EXISTS, static_cast<uint8_t>(exists), 0);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(FileInfoRaw::VT_ERROR, error);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(FileInfoRaw::VT_DATA, data);
  }
  explicit FileInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileInfoRaw> CreateFileInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool exists = false,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  FileInfoRawBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_error(error);
  builder_.add_name(name);
  builder_.add_exists(exists);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileInfoRaw> CreateFileInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool exists = false,
    const char *error = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return rpc::CreateFileInfoRaw(
      _fbb,
      name__,
      exists,
      error__,
      data__);
}

flatbuffers::Offset<FileInfoRaw> CreateFileInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GlobInfoRawT : public flatbuffers::NativeTable {
  typedef GlobInfoRaw TableType;
  std::string name{};
  std::vector<std::string> files{};
};

struct GlobInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GlobInfoRawT NativeTableType;
  typedef GlobInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FILES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           verifier.EndTable();
  }
  GlobInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GlobInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GlobInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GlobInfoRawBuilder {
  typedef GlobInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GlobInfoRaw::VT_NAME, name);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) {
    fbb_.AddOffset(GlobInfoRaw::VT_FILES, files);
  }
  explicit GlobInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GlobInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GlobInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<GlobInfoRaw> CreateGlobInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0) {
  GlobInfoRawBuilder builder_(_fbb);
  builder_.add_files(files);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<GlobInfoRaw> CreateGlobInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0;
  return rpc::CreateGlobInfoRaw(
      _fbb,
      name__,
      files__);
}

flatbuffers::Offset<GlobInfoRaw> CreateGlobInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FeatureInfoRawT : public flatbuffers::NativeTable {
  typedef FeatureInfoRaw TableType;
  rpc::Feature id = static_cast<rpc::Feature>(0);
  bool need_setup = false;
  std::string reason{};
};

struct FeatureInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FeatureInfoRawT NativeTableType;
  typedef FeatureInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NEED_SETUP = 6,
    VT_REASON = 8
  };
  rpc::Feature id() const {
    return static_cast<rpc::Feature>(GetField<uint64_t>(VT_ID, 0));
  }
  bool need_setup() const {
    return GetField<uint8_t>(VT_NEED_SETUP, 0) != 0;
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_NEED_SETUP, 1) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
  FeatureInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FeatureInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FeatureInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FeatureInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FeatureInfoRawBuilder {
  typedef FeatureInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(rpc::Feature id) {
    fbb_.AddElement<uint64_t>(FeatureInfoRaw::VT_ID, static_cast<uint64_t>(id), 0);
  }
  void add_need_setup(bool need_setup) {
    fbb_.AddElement<uint8_t>(FeatureInfoRaw::VT_NEED_SETUP, static_cast<uint8_t>(need_setup), 0);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(FeatureInfoRaw::VT_REASON, reason);
  }
  explicit FeatureInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FeatureInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FeatureInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<FeatureInfoRaw> CreateFeatureInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::Feature id = static_cast<rpc::Feature>(0),
    bool need_setup = false,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  FeatureInfoRawBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_reason(reason);
  builder_.add_need_setup(need_setup);
  return builder_.Finish();
}

inline flatbuffers::Offset<FeatureInfoRaw> CreateFeatureInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::Feature id = static_cast<rpc::Feature>(0),
    bool need_setup = false,
    const char *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return rpc::CreateFeatureInfoRaw(
      _fbb,
      id,
      need_setup,
      reason__);
}

flatbuffers::Offset<FeatureInfoRaw> CreateFeatureInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const FeatureInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostMessageRawT : public flatbuffers::NativeTable {
  typedef HostMessageRaw TableType;
  rpc::HostMessagesRawUnion msg{};
};

struct HostMessageRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostMessageRawT NativeTableType;
  typedef HostMessageRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  rpc::HostMessagesRaw msg_type() const {
    return static_cast<rpc::HostMessagesRaw>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const rpc::ExecRequestRaw *msg_as_ExecRequest() const {
    return msg_type() == rpc::HostMessagesRaw::ExecRequest ? static_cast<const rpc::ExecRequestRaw *>(msg()) : nullptr;
  }
  const rpc::SignalUpdateRaw *msg_as_SignalUpdate() const {
    return msg_type() == rpc::HostMessagesRaw::SignalUpdate ? static_cast<const rpc::SignalUpdateRaw *>(msg()) : nullptr;
  }
  const rpc::StartLeakChecksRaw *msg_as_StartLeakChecks() const {
    return msg_type() == rpc::HostMessagesRaw::StartLeakChecks ? static_cast<const rpc::StartLeakChecksRaw *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyHostMessagesRaw(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  HostMessageRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostMessageRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const rpc::ExecRequestRaw *HostMessageRaw::msg_as<rpc::ExecRequestRaw>() const {
  return msg_as_ExecRequest();
}

template<> inline const rpc::SignalUpdateRaw *HostMessageRaw::msg_as<rpc::SignalUpdateRaw>() const {
  return msg_as_SignalUpdate();
}

template<> inline const rpc::StartLeakChecksRaw *HostMessageRaw::msg_as<rpc::StartLeakChecksRaw>() const {
  return msg_as_StartLeakChecks();
}

struct HostMessageRawBuilder {
  typedef HostMessageRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(rpc::HostMessagesRaw msg_type) {
    fbb_.AddElement<uint8_t>(HostMessageRaw::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(HostMessageRaw::VT_MSG, msg);
  }
  explicit HostMessageRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HostMessageRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostMessageRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostMessageRaw> CreateHostMessageRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::HostMessagesRaw msg_type = rpc::HostMessagesRaw::NONE,
    flatbuffers::Offset<void> msg = 0) {
  HostMessageRawBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<HostMessageRaw> CreateHostMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecutorMessageRawT : public flatbuffers::NativeTable {
  typedef ExecutorMessageRaw TableType;
  rpc::ExecutorMessagesRawUnion msg{};
};

struct ExecutorMessageRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutorMessageRawT NativeTableType;
  typedef ExecutorMessageRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  rpc::ExecutorMessagesRaw msg_type() const {
    return static_cast<rpc::ExecutorMessagesRaw>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const rpc::ExecResultRaw *msg_as_ExecResult() const {
    return msg_type() == rpc::ExecutorMessagesRaw::ExecResult ? static_cast<const rpc::ExecResultRaw *>(msg()) : nullptr;
  }
  const rpc::ExecutingMessageRaw *msg_as_Executing() const {
    return msg_type() == rpc::ExecutorMessagesRaw::Executing ? static_cast<const rpc::ExecutingMessageRaw *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyExecutorMessagesRaw(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  ExecutorMessageRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecutorMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecutorMessageRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const rpc::ExecResultRaw *ExecutorMessageRaw::msg_as<rpc::ExecResultRaw>() const {
  return msg_as_ExecResult();
}

template<> inline const rpc::ExecutingMessageRaw *ExecutorMessageRaw::msg_as<rpc::ExecutingMessageRaw>() const {
  return msg_as_Executing();
}

struct ExecutorMessageRawBuilder {
  typedef ExecutorMessageRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(rpc::ExecutorMessagesRaw msg_type) {
    fbb_.AddElement<uint8_t>(ExecutorMessageRaw::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(ExecutorMessageRaw::VT_MSG, msg);
  }
  explicit ExecutorMessageRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutorMessageRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutorMessageRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutorMessageRaw> CreateExecutorMessageRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::ExecutorMessagesRaw msg_type = rpc::ExecutorMessagesRaw::NONE,
    flatbuffers::Offset<void> msg = 0) {
  ExecutorMessageRawBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<ExecutorMessageRaw> CreateExecutorMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecRequestRawT : public flatbuffers::NativeTable {
  typedef ExecRequestRaw TableType;
  int64_t id = 0;
  std::vector<uint8_t> prog_data{};
  std::unique_ptr<rpc::ExecOptsRaw> exec_opts{};
  rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0);
  std::vector<uint64_t> signal_filter{};
  int32_t signal_filter_call = 0;
  std::vector<int32_t> all_signal{};
  int32_t repeat = 0;
  ExecRequestRawT() = default;
  ExecRequestRawT(const ExecRequestRawT &o);
  ExecRequestRawT(ExecRequestRawT&&) FLATBUFFERS_NOEXCEPT = default;
  ExecRequestRawT &operator=(ExecRequestRawT o) FLATBUFFERS_NOEXCEPT;
};

struct ExecRequestRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecRequestRawT NativeTableType;
  typedef ExecRequestRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PROG_DATA = 6,
    VT_EXEC_OPTS = 8,
    VT_FLAGS = 10,
    VT_SIGNAL_FILTER = 12,
    VT_SIGNAL_FILTER_CALL = 14,
    VT_ALL_SIGNAL = 16,
    VT_REPEAT = 18
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *prog_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PROG_DATA);
  }
  const rpc::ExecOptsRaw *exec_opts() const {
    return GetStruct<const rpc::ExecOptsRaw *>(VT_EXEC_OPTS);
  }
  rpc::RequestFlag flags() const {
    return static_cast<rpc::RequestFlag>(GetField<uint64_t>(VT_FLAGS, 0));
  }
  const flatbuffers::Vector<uint64_t> *signal_filter() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_SIGNAL_FILTER);
  }
  int32_t signal_filter_call() const {
    return GetField<int32_t>(VT_SIGNAL_FILTER_CALL, 0);
  }
  const flatbuffers::Vector<int32_t> *all_signal() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ALL_SIGNAL);
  }
  int32_t repeat() const {
    return GetField<int32_t>(VT_REPEAT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_PROG_DATA) &&
           verifier.VerifyVector(prog_data()) &&
           VerifyField<rpc::ExecOptsRaw>(verifier, VT_EXEC_OPTS, 8) &&
           VerifyField<uint64_t>(verifier, VT_FLAGS, 8) &&
           VerifyOffset(verifier, VT_SIGNAL_FILTER) &&
           verifier.VerifyVector(signal_filter()) &&
           VerifyField<int32_t>(verifier, VT_SIGNAL_FILTER_CALL, 4) &&
           VerifyOffset(verifier, VT_ALL_SIGNAL) &&
           verifier.VerifyVector(all_signal()) &&
           VerifyField<int32_t>(verifier, VT_REPEAT, 4) &&
           verifier.EndTable();
  }
  ExecRequestRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecRequestRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecRequestRawBuilder {
  typedef ExecRequestRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ExecRequestRaw::VT_ID, id, 0);
  }
  void add_prog_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prog_data) {
    fbb_.AddOffset(ExecRequestRaw::VT_PROG_DATA, prog_data);
  }
  void add_exec_opts(const rpc::ExecOptsRaw *exec_opts) {
    fbb_.AddStruct(ExecRequestRaw::VT_EXEC_OPTS, exec_opts);
  }
  void add_flags(rpc::RequestFlag flags) {
    fbb_.AddElement<uint64_t>(ExecRequestRaw::VT_FLAGS, static_cast<uint64_t>(flags), 0);
  }
  void add_signal_filter(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> signal_filter) {
    fbb_.AddOffset(ExecRequestRaw::VT_SIGNAL_FILTER, signal_filter);
  }
  void add_signal_filter_call(int32_t signal_filter_call) {
    fbb_.AddElement<int32_t>(ExecRequestRaw::VT_SIGNAL_FILTER_CALL, signal_filter_call, 0);
  }
  void add_all_signal(flatbuffers::Offset<flatbuffers::Vector<int32_t>> all_signal) {
    fbb_.AddOffset(ExecRequestRaw::VT_ALL_SIGNAL, all_signal);
  }
  void add_repeat(int32_t repeat) {
    fbb_.AddElement<int32_t>(ExecRequestRaw::VT_REPEAT, repeat, 0);
  }
  explicit ExecRequestRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecRequestRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecRequestRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecRequestRaw> CreateExecRequestRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prog_data = 0,
    const rpc::ExecOptsRaw *exec_opts = nullptr,
    rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0),
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> signal_filter = 0,
    int32_t signal_filter_call = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> all_signal = 0,
    int32_t repeat = 0) {
  ExecRequestRawBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_id(id);
  builder_.add_repeat(repeat);
  builder_.add_all_signal(all_signal);
  builder_.add_signal_filter_call(signal_filter_call);
  builder_.add_signal_filter(signal_filter);
  builder_.add_exec_opts(exec_opts);
  builder_.add_prog_data(prog_data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecRequestRaw> CreateExecRequestRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    const std::vector<uint8_t> *prog_data = nullptr,
    const rpc::ExecOptsRaw *exec_opts = nullptr,
    rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0),
    const std::vector<uint64_t> *signal_filter = nullptr,
    int32_t signal_filter_call = 0,
    const std::vector<int32_t> *all_signal = nullptr,
    int32_t repeat = 0) {
  auto prog_data__ = prog_data ? _fbb.CreateVector<uint8_t>(*prog_data) : 0;
  auto signal_filter__ = signal_filter ? _fbb.CreateVector<uint64_t>(*signal_filter) : 0;
  auto all_signal__ = all_signal ? _fbb.CreateVector<int32_t>(*all_signal) : 0;
  return rpc::CreateExecRequestRaw(
      _fbb,
      id,
      prog_data__,
      exec_opts,
      flags,
      signal_filter__,
      signal_filter_call,
      all_signal__,
      repeat);
}

flatbuffers::Offset<ExecRequestRaw> CreateExecRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignalUpdateRawT : public flatbuffers::NativeTable {
  typedef SignalUpdateRaw TableType;
  std::vector<uint64_t> new_max{};
  std::vector<uint64_t> drop_max{};
};

struct SignalUpdateRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalUpdateRawT NativeTableType;
  typedef SignalUpdateRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_MAX = 4,
    VT_DROP_MAX = 6
  };
  const flatbuffers::Vector<uint64_t> *new_max() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_NEW_MAX);
  }
  const flatbuffers::Vector<uint64_t> *drop_max() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_DROP_MAX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_MAX) &&
           verifier.VerifyVector(new_max()) &&
           VerifyOffset(verifier, VT_DROP_MAX) &&
           verifier.VerifyVector(drop_max()) &&
           verifier.EndTable();
  }
  SignalUpdateRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalUpdateRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignalUpdateRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignalUpdateRawBuilder {
  typedef SignalUpdateRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_max(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> new_max) {
    fbb_.AddOffset(SignalUpdateRaw::VT_NEW_MAX, new_max);
  }
  void add_drop_max(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> drop_max) {
    fbb_.AddOffset(SignalUpdateRaw::VT_DROP_MAX, drop_max);
  }
  explicit SignalUpdateRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalUpdateRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalUpdateRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalUpdateRaw> CreateSignalUpdateRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> new_max = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> drop_max = 0) {
  SignalUpdateRawBuilder builder_(_fbb);
  builder_.add_drop_max(drop_max);
  builder_.add_new_max(new_max);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalUpdateRaw> CreateSignalUpdateRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *new_max = nullptr,
    const std::vector<uint64_t> *drop_max = nullptr) {
  auto new_max__ = new_max ? _fbb.CreateVector<uint64_t>(*new_max) : 0;
  auto drop_max__ = drop_max ? _fbb.CreateVector<uint64_t>(*drop_max) : 0;
  return rpc::CreateSignalUpdateRaw(
      _fbb,
      new_max__,
      drop_max__);
}

flatbuffers::Offset<SignalUpdateRaw> CreateSignalUpdateRaw(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartLeakChecksRawT : public flatbuffers::NativeTable {
  typedef StartLeakChecksRaw TableType;
};

struct StartLeakChecksRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StartLeakChecksRawT NativeTableType;
  typedef StartLeakChecksRawBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StartLeakChecksRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartLeakChecksRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StartLeakChecksRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StartLeakChecksRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StartLeakChecksRawBuilder {
  typedef StartLeakChecksRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StartLeakChecksRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StartLeakChecksRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartLeakChecksRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<StartLeakChecksRaw> CreateStartLeakChecksRaw(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StartLeakChecksRawBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<StartLeakChecksRaw> CreateStartLeakChecksRaw(flatbuffers::FlatBufferBuilder &_fbb, const StartLeakChecksRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecutingMessageRawT : public flatbuffers::NativeTable {
  typedef ExecutingMessageRaw TableType;
  int64_t id = 0;
  int32_t proc_id = 0;
  int32_t try_ = 0;
  int64_t wait_duration = 0;
};

struct ExecutingMessageRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutingMessageRawT NativeTableType;
  typedef ExecutingMessageRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PROC_ID = 6,
    VT_TRY_ = 8,
    VT_WAIT_DURATION = 10
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int32_t proc_id() const {
    return GetField<int32_t>(VT_PROC_ID, 0);
  }
  int32_t try_() const {
    return GetField<int32_t>(VT_TRY_, 0);
  }
  int64_t wait_duration() const {
    return GetField<int64_t>(VT_WAIT_DURATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyField<int32_t>(verifier, VT_PROC_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TRY_, 4) &&
           VerifyField<int64_t>(verifier, VT_WAIT_DURATION, 8) &&
           verifier.EndTable();
  }
  ExecutingMessageRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecutingMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecutingMessageRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecutingMessageRawBuilder {
  typedef ExecutingMessageRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ExecutingMessageRaw::VT_ID, id, 0);
  }
  void add_proc_id(int32_t proc_id) {
    fbb_.AddElement<int32_t>(ExecutingMessageRaw::VT_PROC_ID, proc_id, 0);
  }
  void add_try_(int32_t try_) {
    fbb_.AddElement<int32_t>(ExecutingMessageRaw::VT_TRY_, try_, 0);
  }
  void add_wait_duration(int64_t wait_duration) {
    fbb_.AddElement<int64_t>(ExecutingMessageRaw::VT_WAIT_DURATION, wait_duration, 0);
  }
  explicit ExecutingMessageRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutingMessageRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutingMessageRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutingMessageRaw> CreateExecutingMessageRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int32_t proc_id = 0,
    int32_t try_ = 0,
    int64_t wait_duration = 0) {
  ExecutingMessageRawBuilder builder_(_fbb);
  builder_.add_wait_duration(wait_duration);
  builder_.add_id(id);
  builder_.add_try_(try_);
  builder_.add_proc_id(proc_id);
  return builder_.Finish();
}

flatbuffers::Offset<ExecutingMessageRaw> CreateExecutingMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallInfoRawT : public flatbuffers::NativeTable {
  typedef CallInfoRaw TableType;
  rpc::CallFlag flags = static_cast<rpc::CallFlag>(0);
  int32_t error = 0;
  std::vector<uint64_t> signal{};
  std::vector<uint64_t> cover{};
  std::vector<rpc::ComparisonRaw> comps{};
};

struct CallInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallInfoRawT NativeTableType;
  typedef CallInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_ERROR = 6,
    VT_SIGNAL = 8,
    VT_COVER = 10,
    VT_COMPS = 12
  };
  rpc::CallFlag flags() const {
    return static_cast<rpc::CallFlag>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const flatbuffers::Vector<uint64_t> *signal() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_SIGNAL);
  }
  const flatbuffers::Vector<uint64_t> *cover() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_COVER);
  }
  const flatbuffers::Vector<const rpc::ComparisonRaw *> *comps() const {
    return GetPointer<const flatbuffers::Vector<const rpc::ComparisonRaw *> *>(VT_COMPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyField<int32_t>(verifier, VT_ERROR, 4) &&
           VerifyOffset(verifier, VT_SIGNAL) &&
           verifier.VerifyVector(signal()) &&
           VerifyOffset(verifier, VT_COVER) &&
           verifier.VerifyVector(cover()) &&
           VerifyOffset(verifier, VT_COMPS) &&
           verifier.VerifyVector(comps()) &&
           verifier.EndTable();
  }
  CallInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallInfoRawBuilder {
  typedef CallInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(rpc::CallFlag flags) {
    fbb_.AddElement<uint8_t>(CallInfoRaw::VT_FLAGS, static_cast<uint8_t>(flags), 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(CallInfoRaw::VT_ERROR, error, 0);
  }
  void add_signal(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> signal) {
    fbb_.AddOffset(CallInfoRaw::VT_SIGNAL, signal);
  }
  void add_cover(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cover) {
    fbb_.AddOffset(CallInfoRaw::VT_COVER, cover);
  }
  void add_comps(flatbuffers::Offset<flatbuffers::Vector<const rpc::ComparisonRaw *>> comps) {
    fbb_.AddOffset(CallInfoRaw::VT_COMPS, comps);
  }
  explicit CallInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CallInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallInfoRaw> CreateCallInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::CallFlag flags = static_cast<rpc::CallFlag>(0),
    int32_t error = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> signal = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cover = 0,
    flatbuffers::Offset<flatbuffers::Vector<const rpc::ComparisonRaw *>> comps = 0) {
  CallInfoRawBuilder builder_(_fbb);
  builder_.add_comps(comps);
  builder_.add_cover(cover);
  builder_.add_signal(signal);
  builder_.add_error(error);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<CallInfoRaw> CreateCallInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::CallFlag flags = static_cast<rpc::CallFlag>(0),
    int32_t error = 0,
    const std::vector<uint64_t> *signal = nullptr,
    const std::vector<uint64_t> *cover = nullptr,
    const std::vector<rpc::ComparisonRaw> *comps = nullptr) {
  auto signal__ = signal ? _fbb.CreateVector<uint64_t>(*signal) : 0;
  auto cover__ = cover ? _fbb.CreateVector<uint64_t>(*cover) : 0;
  auto comps__ = comps ? _fbb.CreateVectorOfStructs<rpc::ComparisonRaw>(*comps) : 0;
  return rpc::CreateCallInfoRaw(
      _fbb,
      flags,
      error,
      signal__,
      cover__,
      comps__);
}

flatbuffers::Offset<CallInfoRaw> CreateCallInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProgInfoRawT : public flatbuffers::NativeTable {
  typedef ProgInfoRaw TableType;
  std::vector<std::unique_ptr<rpc::CallInfoRawT>> calls{};
  std::unique_ptr<rpc::CallInfoRawT> extra{};
  uint64_t elapsed = 0;
  uint64_t freshness = 0;
  ProgInfoRawT() = default;
  ProgInfoRawT(const ProgInfoRawT &o);
  ProgInfoRawT(ProgInfoRawT&&) FLATBUFFERS_NOEXCEPT = default;
  ProgInfoRawT &operator=(ProgInfoRawT o) FLATBUFFERS_NOEXCEPT;
};

struct ProgInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgInfoRawT NativeTableType;
  typedef ProgInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALLS = 4,
    VT_EXTRA = 6,
    VT_ELAPSED = 8,
    VT_FRESHNESS = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>> *calls() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>> *>(VT_CALLS);
  }
  const rpc::CallInfoRaw *extra() const {
    return GetPointer<const rpc::CallInfoRaw *>(VT_EXTRA);
  }
  uint64_t elapsed() const {
    return GetField<uint64_t>(VT_ELAPSED, 0);
  }
  uint64_t freshness() const {
    return GetField<uint64_t>(VT_FRESHNESS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALLS) &&
           verifier.VerifyVector(calls()) &&
           verifier.VerifyVectorOfTables(calls()) &&
           VerifyOffset(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           VerifyField<uint64_t>(verifier, VT_ELAPSED, 8) &&
           VerifyField<uint64_t>(verifier, VT_FRESHNESS, 8) &&
           verifier.EndTable();
  }
  ProgInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProgInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProgInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProgInfoRawBuilder {
  typedef ProgInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_calls(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>>> calls) {
    fbb_.AddOffset(ProgInfoRaw::VT_CALLS, calls);
  }
  void add_extra(flatbuffers::Offset<rpc::CallInfoRaw> extra) {
    fbb_.AddOffset(ProgInfoRaw::VT_EXTRA, extra);
  }
  void add_elapsed(uint64_t elapsed) {
    fbb_.AddElement<uint64_t>(ProgInfoRaw::VT_ELAPSED, elapsed, 0);
  }
  void add_freshness(uint64_t freshness) {
    fbb_.AddElement<uint64_t>(ProgInfoRaw::VT_FRESHNESS, freshness, 0);
  }
  explicit ProgInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProgInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgInfoRaw> CreateProgInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>>> calls = 0,
    flatbuffers::Offset<rpc::CallInfoRaw> extra = 0,
    uint64_t elapsed = 0,
    uint64_t freshness = 0) {
  ProgInfoRawBuilder builder_(_fbb);
  builder_.add_freshness(freshness);
  builder_.add_elapsed(elapsed);
  builder_.add_extra(extra);
  builder_.add_calls(calls);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgInfoRaw> CreateProgInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<rpc::CallInfoRaw>> *calls = nullptr,
    flatbuffers::Offset<rpc::CallInfoRaw> extra = 0,
    uint64_t elapsed = 0,
    uint64_t freshness = 0) {
  auto calls__ = calls ? _fbb.CreateVector<flatbuffers::Offset<rpc::CallInfoRaw>>(*calls) : 0;
  return rpc::CreateProgInfoRaw(
      _fbb,
      calls__,
      extra,
      elapsed,
      freshness);
}

flatbuffers::Offset<ProgInfoRaw> CreateProgInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecResultRawT : public flatbuffers::NativeTable {
  typedef ExecResultRaw TableType;
  int64_t id = 0;
  std::vector<uint8_t> output{};
  std::string error{};
  std::unique_ptr<rpc::ProgInfoRawT> info{};
  ExecResultRawT() = default;
  ExecResultRawT(const ExecResultRawT &o);
  ExecResultRawT(ExecResultRawT&&) FLATBUFFERS_NOEXCEPT = default;
  ExecResultRawT &operator=(ExecResultRawT o) FLATBUFFERS_NOEXCEPT;
};

struct ExecResultRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecResultRawT NativeTableType;
  typedef ExecResultRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_OUTPUT = 6,
    VT_ERROR = 8,
    VT_INFO = 10
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *output() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTPUT);
  }
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const rpc::ProgInfoRaw *info() const {
    return GetPointer<const rpc::ProgInfoRaw *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
  ExecResultRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecResultRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecResultRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecResultRawBuilder {
  typedef ExecResultRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ExecResultRaw::VT_ID, id, 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output) {
    fbb_.AddOffset(ExecResultRaw::VT_OUTPUT, output);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(ExecResultRaw::VT_ERROR, error);
  }
  void add_info(flatbuffers::Offset<rpc::ProgInfoRaw> info) {
    fbb_.AddOffset(ExecResultRaw::VT_INFO, info);
  }
  explicit ExecResultRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecResultRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecResultRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecResultRaw> CreateExecResultRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<rpc::ProgInfoRaw> info = 0) {
  ExecResultRawBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_info(info);
  builder_.add_error(error);
  builder_.add_output(output);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecResultRaw> CreateExecResultRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    const std::vector<uint8_t> *output = nullptr,
    const char *error = nullptr,
    flatbuffers::Offset<rpc::ProgInfoRaw> info = 0) {
  auto output__ = output ? _fbb.CreateVector<uint8_t>(*output) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return rpc::CreateExecResultRaw(
      _fbb,
      id,
      output__,
      error__,
      info);
}

flatbuffers::Offset<ExecResultRaw> CreateExecResultRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ConnectRequestRawT *ConnectRequestRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConnectRequestRawT>(new ConnectRequestRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConnectRequestRaw::UnPackTo(ConnectRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = arch(); if (_e) _o->arch = _e->str(); }
  { auto _e = git_revision(); if (_e) _o->git_revision = _e->str(); }
  { auto _e = syz_revision(); if (_e) _o->syz_revision = _e->str(); }
}

inline flatbuffers::Offset<ConnectRequestRaw> ConnectRequestRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConnectRequestRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConnectRequestRaw> CreateConnectRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConnectRequestRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _arch = _o->arch.empty() ? 0 : _fbb.CreateString(_o->arch);
  auto _git_revision = _o->git_revision.empty() ? 0 : _fbb.CreateString(_o->git_revision);
  auto _syz_revision = _o->syz_revision.empty() ? 0 : _fbb.CreateString(_o->syz_revision);
  return rpc::CreateConnectRequestRaw(
      _fbb,
      _name,
      _arch,
      _git_revision,
      _syz_revision);
}

inline ConnectReplyRawT *ConnectReplyRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConnectReplyRawT>(new ConnectReplyRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConnectReplyRaw::UnPackTo(ConnectReplyRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = debug(); _o->debug = _e; }
  { auto _e = procs(); _o->procs = _e; }
  { auto _e = slowdown(); _o->slowdown = _e; }
  { auto _e = leak_frames(); if (_e) { _o->leak_frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->leak_frames[_i] = _e->Get(_i)->str(); } } }
  { auto _e = race_frames(); if (_e) { _o->race_frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->race_frames[_i] = _e->Get(_i)->str(); } } }
  { auto _e = features(); _o->features = _e; }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = _e->Get(_i)->str(); } } }
  { auto _e = globs(); if (_e) { _o->globs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->globs[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<ConnectReplyRaw> ConnectReplyRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConnectReplyRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConnectReplyRaw> CreateConnectReplyRaw(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConnectReplyRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _debug = _o->debug;
  auto _procs = _o->procs;
  auto _slowdown = _o->slowdown;
  auto _leak_frames = _o->leak_frames.size() ? _fbb.CreateVectorOfStrings(_o->leak_frames) : 0;
  auto _race_frames = _o->race_frames.size() ? _fbb.CreateVectorOfStrings(_o->race_frames) : 0;
  auto _features = _o->features;
  auto _files = _o->files.size() ? _fbb.CreateVectorOfStrings(_o->files) : 0;
  auto _globs = _o->globs.size() ? _fbb.CreateVectorOfStrings(_o->globs) : 0;
  return rpc::CreateConnectReplyRaw(
      _fbb,
      _debug,
      _procs,
      _slowdown,
      _leak_frames,
      _race_frames,
      _features,
      _files,
      _globs);
}

inline InfoRequestRawT::InfoRequestRawT(const InfoRequestRawT &o)
      : error(o.error) {
  features.reserve(o.features.size());
  for (const auto &features_ : o.features) { features.emplace_back((features_) ? new rpc::FeatureInfoRawT(*features_) : nullptr); }
  files.reserve(o.files.size());
  for (const auto &files_ : o.files) { files.emplace_back((files_) ? new rpc::FileInfoRawT(*files_) : nullptr); }
  globs.reserve(o.globs.size());
  for (const auto &globs_ : o.globs) { globs.emplace_back((globs_) ? new rpc::GlobInfoRawT(*globs_) : nullptr); }
}

inline InfoRequestRawT &InfoRequestRawT::operator=(InfoRequestRawT o) FLATBUFFERS_NOEXCEPT {
  std::swap(error, o.error);
  std::swap(features, o.features);
  std::swap(files, o.files);
  std::swap(globs, o.globs);
  return *this;
}

inline InfoRequestRawT *InfoRequestRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InfoRequestRawT>(new InfoRequestRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InfoRequestRaw::UnPackTo(InfoRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = features(); if (_e) { _o->features.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->features[_i] = std::unique_ptr<rpc::FeatureInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = std::unique_ptr<rpc::FileInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = globs(); if (_e) { _o->globs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->globs[_i] = std::unique_ptr<rpc::GlobInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<InfoRequestRaw> InfoRequestRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInfoRequestRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InfoRequestRaw> CreateInfoRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InfoRequestRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _features = _o->features.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::FeatureInfoRaw>> (_o->features.size(), [](size_t i, _VectorArgs *__va) { return CreateFeatureInfoRaw(*__va->__fbb, __va->__o->features[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _files = _o->files.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::FileInfoRaw>> (_o->files.size(), [](size_t i, _VectorArgs *__va) { return CreateFileInfoRaw(*__va->__fbb, __va->__o->files[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _globs = _o->globs.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::GlobInfoRaw>> (_o->globs.size(), [](size_t i, _VectorArgs *__va) { return CreateGlobInfoRaw(*__va->__fbb, __va->__o->globs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return rpc::CreateInfoRequestRaw(
      _fbb,
      _error,
      _features,
      _files,
      _globs);
}

inline InfoReplyRawT *InfoReplyRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InfoReplyRawT>(new InfoReplyRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InfoReplyRaw::UnPackTo(InfoReplyRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cover_filter(); if (_e) { _o->cover_filter.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->cover_filter.begin()); } }
}

inline flatbuffers::Offset<InfoReplyRaw> InfoReplyRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInfoReplyRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InfoReplyRaw> CreateInfoReplyRaw(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InfoReplyRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cover_filter = _o->cover_filter.size() ? _fbb.CreateVector(_o->cover_filter) : 0;
  return rpc::CreateInfoReplyRaw(
      _fbb,
      _cover_filter);
}

inline FileInfoRawT *FileInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileInfoRawT>(new FileInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileInfoRaw::UnPackTo(FileInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = exists(); _o->exists = _e; }
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline flatbuffers::Offset<FileInfoRaw> FileInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FileInfoRaw> CreateFileInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FileInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _exists = _o->exists;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return rpc::CreateFileInfoRaw(
      _fbb,
      _name,
      _exists,
      _error,
      _data);
}

inline GlobInfoRawT *GlobInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GlobInfoRawT>(new GlobInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GlobInfoRaw::UnPackTo(GlobInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<GlobInfoRaw> GlobInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGlobInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GlobInfoRaw> CreateGlobInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GlobInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _files = _o->files.size() ? _fbb.CreateVectorOfStrings(_o->files) : 0;
  return rpc::CreateGlobInfoRaw(
      _fbb,
      _name,
      _files);
}

inline FeatureInfoRawT *FeatureInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FeatureInfoRawT>(new FeatureInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FeatureInfoRaw::UnPackTo(FeatureInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = need_setup(); _o->need_setup = _e; }
  { auto _e = reason(); if (_e) _o->reason = _e->str(); }
}

inline flatbuffers::Offset<FeatureInfoRaw> FeatureInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FeatureInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFeatureInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FeatureInfoRaw> CreateFeatureInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const FeatureInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FeatureInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _need_setup = _o->need_setup;
  auto _reason = _o->reason.empty() ? 0 : _fbb.CreateString(_o->reason);
  return rpc::CreateFeatureInfoRaw(
      _fbb,
      _id,
      _need_setup,
      _reason);
}

inline HostMessageRawT *HostMessageRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HostMessageRawT>(new HostMessageRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostMessageRaw::UnPackTo(HostMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg_type(); _o->msg.type = _e; }
  { auto _e = msg(); if (_e) _o->msg.value = rpc::HostMessagesRawUnion::UnPack(_e, msg_type(), _resolver); }
}

inline flatbuffers::Offset<HostMessageRaw> HostMessageRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostMessageRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostMessageRaw> CreateHostMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostMessageRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return rpc::CreateHostMessageRaw(
      _fbb,
      _msg_type,
      _msg);
}

inline ExecutorMessageRawT *ExecutorMessageRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecutorMessageRawT>(new ExecutorMessageRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecutorMessageRaw::UnPackTo(ExecutorMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg_type(); _o->msg.type = _e; }
  { auto _e = msg(); if (_e) _o->msg.value = rpc::ExecutorMessagesRawUnion::UnPack(_e, msg_type(), _resolver); }
}

inline flatbuffers::Offset<ExecutorMessageRaw> ExecutorMessageRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecutorMessageRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecutorMessageRaw> CreateExecutorMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecutorMessageRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return rpc::CreateExecutorMessageRaw(
      _fbb,
      _msg_type,
      _msg);
}

inline ExecRequestRawT::ExecRequestRawT(const ExecRequestRawT &o)
      : id(o.id),
        prog_data(o.prog_data),
        exec_opts((o.exec_opts) ? new rpc::ExecOptsRaw(*o.exec_opts) : nullptr),
        flags(o.flags),
        signal_filter(o.signal_filter),
        signal_filter_call(o.signal_filter_call),
        all_signal(o.all_signal),
        repeat(o.repeat) {
}

inline ExecRequestRawT &ExecRequestRawT::operator=(ExecRequestRawT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(prog_data, o.prog_data);
  std::swap(exec_opts, o.exec_opts);
  std::swap(flags, o.flags);
  std::swap(signal_filter, o.signal_filter);
  std::swap(signal_filter_call, o.signal_filter_call);
  std::swap(all_signal, o.all_signal);
  std::swap(repeat, o.repeat);
  return *this;
}

inline ExecRequestRawT *ExecRequestRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecRequestRawT>(new ExecRequestRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecRequestRaw::UnPackTo(ExecRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = prog_data(); if (_e) { _o->prog_data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->prog_data.begin()); } }
  { auto _e = exec_opts(); if (_e) _o->exec_opts = std::unique_ptr<rpc::ExecOptsRaw>(new rpc::ExecOptsRaw(*_e)); }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = signal_filter(); if (_e) { _o->signal_filter.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->signal_filter[_i] = _e->Get(_i); } } }
  { auto _e = signal_filter_call(); _o->signal_filter_call = _e; }
  { auto _e = all_signal(); if (_e) { _o->all_signal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->all_signal[_i] = _e->Get(_i); } } }
  { auto _e = repeat(); _o->repeat = _e; }
}

inline flatbuffers::Offset<ExecRequestRaw> ExecRequestRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecRequestRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecRequestRaw> CreateExecRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecRequestRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _prog_data = _o->prog_data.size() ? _fbb.CreateVector(_o->prog_data) : 0;
  auto _exec_opts = _o->exec_opts ? _o->exec_opts.get() : nullptr;
  auto _flags = _o->flags;
  auto _signal_filter = _o->signal_filter.size() ? _fbb.CreateVector(_o->signal_filter) : 0;
  auto _signal_filter_call = _o->signal_filter_call;
  auto _all_signal = _o->all_signal.size() ? _fbb.CreateVector(_o->all_signal) : 0;
  auto _repeat = _o->repeat;
  return rpc::CreateExecRequestRaw(
      _fbb,
      _id,
      _prog_data,
      _exec_opts,
      _flags,
      _signal_filter,
      _signal_filter_call,
      _all_signal,
      _repeat);
}

inline SignalUpdateRawT *SignalUpdateRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignalUpdateRawT>(new SignalUpdateRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignalUpdateRaw::UnPackTo(SignalUpdateRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = new_max(); if (_e) { _o->new_max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_max[_i] = _e->Get(_i); } } }
  { auto _e = drop_max(); if (_e) { _o->drop_max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->drop_max[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SignalUpdateRaw> SignalUpdateRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignalUpdateRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignalUpdateRaw> CreateSignalUpdateRaw(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignalUpdateRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _new_max = _o->new_max.size() ? _fbb.CreateVector(_o->new_max) : 0;
  auto _drop_max = _o->drop_max.size() ? _fbb.CreateVector(_o->drop_max) : 0;
  return rpc::CreateSignalUpdateRaw(
      _fbb,
      _new_max,
      _drop_max);
}

inline StartLeakChecksRawT *StartLeakChecksRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StartLeakChecksRawT>(new StartLeakChecksRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartLeakChecksRaw::UnPackTo(StartLeakChecksRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<StartLeakChecksRaw> StartLeakChecksRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StartLeakChecksRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartLeakChecksRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StartLeakChecksRaw> CreateStartLeakChecksRaw(flatbuffers::FlatBufferBuilder &_fbb, const StartLeakChecksRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StartLeakChecksRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return rpc::CreateStartLeakChecksRaw(
      _fbb);
}

inline ExecutingMessageRawT *ExecutingMessageRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecutingMessageRawT>(new ExecutingMessageRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecutingMessageRaw::UnPackTo(ExecutingMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = proc_id(); _o->proc_id = _e; }
  { auto _e = try_(); _o->try_ = _e; }
  { auto _e = wait_duration(); _o->wait_duration = _e; }
}

inline flatbuffers::Offset<ExecutingMessageRaw> ExecutingMessageRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecutingMessageRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecutingMessageRaw> CreateExecutingMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecutingMessageRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _proc_id = _o->proc_id;
  auto _try_ = _o->try_;
  auto _wait_duration = _o->wait_duration;
  return rpc::CreateExecutingMessageRaw(
      _fbb,
      _id,
      _proc_id,
      _try_,
      _wait_duration);
}

inline CallInfoRawT *CallInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CallInfoRawT>(new CallInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallInfoRaw::UnPackTo(CallInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = error(); _o->error = _e; }
  { auto _e = signal(); if (_e) { _o->signal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->signal[_i] = _e->Get(_i); } } }
  { auto _e = cover(); if (_e) { _o->cover.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cover[_i] = _e->Get(_i); } } }
  { auto _e = comps(); if (_e) { _o->comps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->comps[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<CallInfoRaw> CallInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallInfoRaw> CreateCallInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  auto _error = _o->error;
  auto _signal = _o->signal.size() ? _fbb.CreateVector(_o->signal) : 0;
  auto _cover = _o->cover.size() ? _fbb.CreateVector(_o->cover) : 0;
  auto _comps = _o->comps.size() ? _fbb.CreateVectorOfStructs(_o->comps) : 0;
  return rpc::CreateCallInfoRaw(
      _fbb,
      _flags,
      _error,
      _signal,
      _cover,
      _comps);
}

inline ProgInfoRawT::ProgInfoRawT(const ProgInfoRawT &o)
      : extra((o.extra) ? new rpc::CallInfoRawT(*o.extra) : nullptr),
        elapsed(o.elapsed),
        freshness(o.freshness) {
  calls.reserve(o.calls.size());
  for (const auto &calls_ : o.calls) { calls.emplace_back((calls_) ? new rpc::CallInfoRawT(*calls_) : nullptr); }
}

inline ProgInfoRawT &ProgInfoRawT::operator=(ProgInfoRawT o) FLATBUFFERS_NOEXCEPT {
  std::swap(calls, o.calls);
  std::swap(extra, o.extra);
  std::swap(elapsed, o.elapsed);
  std::swap(freshness, o.freshness);
  return *this;
}

inline ProgInfoRawT *ProgInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProgInfoRawT>(new ProgInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProgInfoRaw::UnPackTo(ProgInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = calls(); if (_e) { _o->calls.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->calls[_i] = std::unique_ptr<rpc::CallInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = extra(); if (_e) _o->extra = std::unique_ptr<rpc::CallInfoRawT>(_e->UnPack(_resolver)); }
  { auto _e = elapsed(); _o->elapsed = _e; }
  { auto _e = freshness(); _o->freshness = _e; }
}

inline flatbuffers::Offset<ProgInfoRaw> ProgInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProgInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProgInfoRaw> CreateProgInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProgInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _calls = _o->calls.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::CallInfoRaw>> (_o->calls.size(), [](size_t i, _VectorArgs *__va) { return CreateCallInfoRaw(*__va->__fbb, __va->__o->calls[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extra = _o->extra ? CreateCallInfoRaw(_fbb, _o->extra.get(), _rehasher) : 0;
  auto _elapsed = _o->elapsed;
  auto _freshness = _o->freshness;
  return rpc::CreateProgInfoRaw(
      _fbb,
      _calls,
      _extra,
      _elapsed,
      _freshness);
}

inline ExecResultRawT::ExecResultRawT(const ExecResultRawT &o)
      : id(o.id),
        output(o.output),
        error(o.error),
        info((o.info) ? new rpc::ProgInfoRawT(*o.info) : nullptr) {
}

inline ExecResultRawT &ExecResultRawT::operator=(ExecResultRawT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(output, o.output);
  std::swap(error, o.error);
  std::swap(info, o.info);
  return *this;
}

inline ExecResultRawT *ExecResultRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecResultRawT>(new ExecResultRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecResultRaw::UnPackTo(ExecResultRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = output(); if (_e) { _o->output.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->output.begin()); } }
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = info(); if (_e) _o->info = std::unique_ptr<rpc::ProgInfoRawT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ExecResultRaw> ExecResultRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecResultRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecResultRaw> CreateExecResultRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecResultRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _output = _o->output.size() ? _fbb.CreateVector(_o->output) : 0;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _info = _o->info ? CreateProgInfoRaw(_fbb, _o->info.get(), _rehasher) : 0;
  return rpc::CreateExecResultRaw(
      _fbb,
      _id,
      _output,
      _error,
      _info);
}

inline bool VerifyHostMessagesRaw(flatbuffers::Verifier &verifier, const void *obj, HostMessagesRaw type) {
  switch (type) {
    case HostMessagesRaw::NONE: {
      return true;
    }
    case HostMessagesRaw::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequestRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostMessagesRaw::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdateRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostMessagesRaw::StartLeakChecks: {
      auto ptr = reinterpret_cast<const rpc::StartLeakChecksRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyHostMessagesRawVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<HostMessagesRaw> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyHostMessagesRaw(
        verifier,  values->Get(i), types->GetEnum<HostMessagesRaw>(i))) {
      return false;
    }
  }
  return true;
}

inline void *HostMessagesRawUnion::UnPack(const void *obj, HostMessagesRaw type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case HostMessagesRaw::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequestRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    case HostMessagesRaw::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdateRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    case HostMessagesRaw::StartLeakChecks: {
      auto ptr = reinterpret_cast<const rpc::StartLeakChecksRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> HostMessagesRawUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case HostMessagesRaw::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequestRawT *>(value);
      return CreateExecRequestRaw(_fbb, ptr, _rehasher).Union();
    }
    case HostMessagesRaw::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdateRawT *>(value);
      return CreateSignalUpdateRaw(_fbb, ptr, _rehasher).Union();
    }
    case HostMessagesRaw::StartLeakChecks: {
      auto ptr = reinterpret_cast<const rpc::StartLeakChecksRawT *>(value);
      return CreateStartLeakChecksRaw(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline HostMessagesRawUnion::HostMessagesRawUnion(const HostMessagesRawUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case HostMessagesRaw::ExecRequest: {
      value = new rpc::ExecRequestRawT(*reinterpret_cast<rpc::ExecRequestRawT *>(u.value));
      break;
    }
    case HostMessagesRaw::SignalUpdate: {
      value = new rpc::SignalUpdateRawT(*reinterpret_cast<rpc::SignalUpdateRawT *>(u.value));
      break;
    }
    case HostMessagesRaw::StartLeakChecks: {
      value = new rpc::StartLeakChecksRawT(*reinterpret_cast<rpc::StartLeakChecksRawT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void HostMessagesRawUnion::Reset() {
  switch (type) {
    case HostMessagesRaw::ExecRequest: {
      auto ptr = reinterpret_cast<rpc::ExecRequestRawT *>(value);
      delete ptr;
      break;
    }
    case HostMessagesRaw::SignalUpdate: {
      auto ptr = reinterpret_cast<rpc::SignalUpdateRawT *>(value);
      delete ptr;
      break;
    }
    case HostMessagesRaw::StartLeakChecks: {
      auto ptr = reinterpret_cast<rpc::StartLeakChecksRawT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = HostMessagesRaw::NONE;
}

inline bool VerifyExecutorMessagesRaw(flatbuffers::Verifier &verifier, const void *obj, ExecutorMessagesRaw type) {
  switch (type) {
    case ExecutorMessagesRaw::NONE: {
      return true;
    }
    case ExecutorMessagesRaw::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResultRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExecutorMessagesRaw::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessageRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExecutorMessagesRawVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ExecutorMessagesRaw> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExecutorMessagesRaw(
        verifier,  values->Get(i), types->GetEnum<ExecutorMessagesRaw>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ExecutorMessagesRawUnion::UnPack(const void *obj, ExecutorMessagesRaw type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ExecutorMessagesRaw::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResultRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    case ExecutorMessagesRaw::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessageRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ExecutorMessagesRawUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ExecutorMessagesRaw::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResultRawT *>(value);
      return CreateExecResultRaw(_fbb, ptr, _rehasher).Union();
    }
    case ExecutorMessagesRaw::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessageRawT *>(value);
      return CreateExecutingMessageRaw(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ExecutorMessagesRawUnion::ExecutorMessagesRawUnion(const ExecutorMessagesRawUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ExecutorMessagesRaw::ExecResult: {
      value = new rpc::ExecResultRawT(*reinterpret_cast<rpc::ExecResultRawT *>(u.value));
      break;
    }
    case ExecutorMessagesRaw::Executing: {
      value = new rpc::ExecutingMessageRawT(*reinterpret_cast<rpc::ExecutingMessageRawT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ExecutorMessagesRawUnion::Reset() {
  switch (type) {
    case ExecutorMessagesRaw::ExecResult: {
      auto ptr = reinterpret_cast<rpc::ExecResultRawT *>(value);
      delete ptr;
      break;
    }
    case ExecutorMessagesRaw::Executing: {
      auto ptr = reinterpret_cast<rpc::ExecutingMessageRawT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ExecutorMessagesRaw::NONE;
}

}  // namespace rpc

#endif  // FLATBUFFERS_GENERATED_FLATRPC_RPC_H_
