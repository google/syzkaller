// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATRPC_RPC_H_
#define FLATBUFFERS_GENERATED_FLATRPC_RPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace rpc {

struct ConnectRequestRaw;
struct ConnectRequestRawBuilder;
struct ConnectRequestRawT;

struct ConnectReplyRaw;
struct ConnectReplyRawBuilder;
struct ConnectReplyRawT;

struct InfoRequestRaw;
struct InfoRequestRawBuilder;
struct InfoRequestRawT;

struct InfoReplyRaw;
struct InfoReplyRawBuilder;
struct InfoReplyRawT;

struct FileInfoRaw;
struct FileInfoRawBuilder;
struct FileInfoRawT;

struct GlobInfoRaw;
struct GlobInfoRawBuilder;
struct GlobInfoRawT;

struct FeatureInfoRaw;
struct FeatureInfoRawBuilder;
struct FeatureInfoRawT;

struct HostMessageRaw;
struct HostMessageRawBuilder;
struct HostMessageRawT;

struct ExecutorMessageRaw;
struct ExecutorMessageRawBuilder;
struct ExecutorMessageRawT;

struct ExecOptsRaw;

struct ExecRequestRaw;
struct ExecRequestRawBuilder;
struct ExecRequestRawT;

struct SignalUpdateRaw;
struct SignalUpdateRawBuilder;
struct SignalUpdateRawT;

struct CorpusTriagedRaw;
struct CorpusTriagedRawBuilder;
struct CorpusTriagedRawT;

struct StateRequestRaw;
struct StateRequestRawBuilder;
struct StateRequestRawT;

struct ExecutingMessageRaw;
struct ExecutingMessageRawBuilder;
struct ExecutingMessageRawT;

struct CallInfoRaw;
struct CallInfoRawBuilder;
struct CallInfoRawT;

struct ComparisonRaw;

struct ProgInfoRaw;
struct ProgInfoRawBuilder;
struct ProgInfoRawT;

struct ExecResultRaw;
struct ExecResultRawBuilder;
struct ExecResultRawT;

struct StateResultRaw;
struct StateResultRawBuilder;
struct StateResultRawT;

struct SnapshotHeader;
struct SnapshotHeaderBuilder;
struct SnapshotHeaderT;

struct SnapshotHandshake;
struct SnapshotHandshakeBuilder;
struct SnapshotHandshakeT;

struct SnapshotRequest;
struct SnapshotRequestBuilder;
struct SnapshotRequestT;

enum class Const : uint64_t {
  SnapshotDoorbellSize = 4096ULL,
  MaxInputSize = 4198400ULL,
  MaxOutputSize = 14680064ULL,
  SnapshotShmemSize = 33554432ULL,
  MIN = SnapshotDoorbellSize,
  MAX = SnapshotShmemSize
};

inline const Const (&EnumValuesConst())[4] {
  static const Const values[] = {
    Const::SnapshotDoorbellSize,
    Const::MaxInputSize,
    Const::MaxOutputSize,
    Const::SnapshotShmemSize
  };
  return values;
}

inline const char *EnumNameConst(Const e) {
  switch (e) {
    case Const::SnapshotDoorbellSize: return "SnapshotDoorbellSize";
    case Const::MaxInputSize: return "MaxInputSize";
    case Const::MaxOutputSize: return "MaxOutputSize";
    case Const::SnapshotShmemSize: return "SnapshotShmemSize";
    default: return "";
  }
}

enum class Feature : uint64_t {
  Coverage = 1ULL,
  Comparisons = 2ULL,
  ExtraCoverage = 4ULL,
  DelayKcovMmap = 8ULL,
  SandboxNone = 16ULL,
  SandboxSetuid = 32ULL,
  SandboxNamespace = 64ULL,
  SandboxAndroid = 128ULL,
  Fault = 256ULL,
  Leak = 512ULL,
  NetInjection = 1024ULL,
  NetDevices = 2048ULL,
  KCSAN = 4096ULL,
  DevlinkPCI = 8192ULL,
  NicVF = 16384ULL,
  USBEmulation = 32768ULL,
  VhciInjection = 65536ULL,
  WifiEmulation = 131072ULL,
  LRWPANEmulation = 262144ULL,
  BinFmtMisc = 524288ULL,
  Swap = 1048576ULL,
  NONE = 0,
  ANY = 2097151ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(Feature, uint64_t)

inline const Feature (&EnumValuesFeature())[21] {
  static const Feature values[] = {
    Feature::Coverage,
    Feature::Comparisons,
    Feature::ExtraCoverage,
    Feature::DelayKcovMmap,
    Feature::SandboxNone,
    Feature::SandboxSetuid,
    Feature::SandboxNamespace,
    Feature::SandboxAndroid,
    Feature::Fault,
    Feature::Leak,
    Feature::NetInjection,
    Feature::NetDevices,
    Feature::KCSAN,
    Feature::DevlinkPCI,
    Feature::NicVF,
    Feature::USBEmulation,
    Feature::VhciInjection,
    Feature::WifiEmulation,
    Feature::LRWPANEmulation,
    Feature::BinFmtMisc,
    Feature::Swap
  };
  return values;
}

inline const char *EnumNameFeature(Feature e) {
  switch (e) {
    case Feature::Coverage: return "Coverage";
    case Feature::Comparisons: return "Comparisons";
    case Feature::ExtraCoverage: return "ExtraCoverage";
    case Feature::DelayKcovMmap: return "DelayKcovMmap";
    case Feature::SandboxNone: return "SandboxNone";
    case Feature::SandboxSetuid: return "SandboxSetuid";
    case Feature::SandboxNamespace: return "SandboxNamespace";
    case Feature::SandboxAndroid: return "SandboxAndroid";
    case Feature::Fault: return "Fault";
    case Feature::Leak: return "Leak";
    case Feature::NetInjection: return "NetInjection";
    case Feature::NetDevices: return "NetDevices";
    case Feature::KCSAN: return "KCSAN";
    case Feature::DevlinkPCI: return "DevlinkPCI";
    case Feature::NicVF: return "NicVF";
    case Feature::USBEmulation: return "USBEmulation";
    case Feature::VhciInjection: return "VhciInjection";
    case Feature::WifiEmulation: return "WifiEmulation";
    case Feature::LRWPANEmulation: return "LRWPANEmulation";
    case Feature::BinFmtMisc: return "BinFmtMisc";
    case Feature::Swap: return "Swap";
    default: return "";
  }
}

enum class HostMessagesRaw : uint8_t {
  NONE = 0,
  ExecRequest = 1,
  SignalUpdate = 2,
  CorpusTriaged = 3,
  StateRequest = 4,
  MIN = NONE,
  MAX = StateRequest
};

inline const HostMessagesRaw (&EnumValuesHostMessagesRaw())[5] {
  static const HostMessagesRaw values[] = {
    HostMessagesRaw::NONE,
    HostMessagesRaw::ExecRequest,
    HostMessagesRaw::SignalUpdate,
    HostMessagesRaw::CorpusTriaged,
    HostMessagesRaw::StateRequest
  };
  return values;
}

inline const char * const *EnumNamesHostMessagesRaw() {
  static const char * const names[6] = {
    "NONE",
    "ExecRequest",
    "SignalUpdate",
    "CorpusTriaged",
    "StateRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameHostMessagesRaw(HostMessagesRaw e) {
  if (flatbuffers::IsOutRange(e, HostMessagesRaw::NONE, HostMessagesRaw::StateRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHostMessagesRaw()[index];
}

template<typename T> struct HostMessagesRawTraits {
  static const HostMessagesRaw enum_value = HostMessagesRaw::NONE;
};

template<> struct HostMessagesRawTraits<rpc::ExecRequestRaw> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::ExecRequest;
};

template<> struct HostMessagesRawTraits<rpc::SignalUpdateRaw> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::SignalUpdate;
};

template<> struct HostMessagesRawTraits<rpc::CorpusTriagedRaw> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::CorpusTriaged;
};

template<> struct HostMessagesRawTraits<rpc::StateRequestRaw> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::StateRequest;
};

template<typename T> struct HostMessagesRawUnionTraits {
  static const HostMessagesRaw enum_value = HostMessagesRaw::NONE;
};

template<> struct HostMessagesRawUnionTraits<rpc::ExecRequestRawT> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::ExecRequest;
};

template<> struct HostMessagesRawUnionTraits<rpc::SignalUpdateRawT> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::SignalUpdate;
};

template<> struct HostMessagesRawUnionTraits<rpc::CorpusTriagedRawT> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::CorpusTriaged;
};

template<> struct HostMessagesRawUnionTraits<rpc::StateRequestRawT> {
  static const HostMessagesRaw enum_value = HostMessagesRaw::StateRequest;
};

struct HostMessagesRawUnion {
  HostMessagesRaw type;
  void *value;

  HostMessagesRawUnion() : type(HostMessagesRaw::NONE), value(nullptr) {}
  HostMessagesRawUnion(HostMessagesRawUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(HostMessagesRaw::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  HostMessagesRawUnion(const HostMessagesRawUnion &);
  HostMessagesRawUnion &operator=(const HostMessagesRawUnion &u)
    { HostMessagesRawUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  HostMessagesRawUnion &operator=(HostMessagesRawUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~HostMessagesRawUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = HostMessagesRawUnionTraits<RT>::enum_value;
    if (type != HostMessagesRaw::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, HostMessagesRaw type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  rpc::ExecRequestRawT *AsExecRequest() {
    return type == HostMessagesRaw::ExecRequest ?
      reinterpret_cast<rpc::ExecRequestRawT *>(value) : nullptr;
  }
  const rpc::ExecRequestRawT *AsExecRequest() const {
    return type == HostMessagesRaw::ExecRequest ?
      reinterpret_cast<const rpc::ExecRequestRawT *>(value) : nullptr;
  }
  rpc::SignalUpdateRawT *AsSignalUpdate() {
    return type == HostMessagesRaw::SignalUpdate ?
      reinterpret_cast<rpc::SignalUpdateRawT *>(value) : nullptr;
  }
  const rpc::SignalUpdateRawT *AsSignalUpdate() const {
    return type == HostMessagesRaw::SignalUpdate ?
      reinterpret_cast<const rpc::SignalUpdateRawT *>(value) : nullptr;
  }
  rpc::CorpusTriagedRawT *AsCorpusTriaged() {
    return type == HostMessagesRaw::CorpusTriaged ?
      reinterpret_cast<rpc::CorpusTriagedRawT *>(value) : nullptr;
  }
  const rpc::CorpusTriagedRawT *AsCorpusTriaged() const {
    return type == HostMessagesRaw::CorpusTriaged ?
      reinterpret_cast<const rpc::CorpusTriagedRawT *>(value) : nullptr;
  }
  rpc::StateRequestRawT *AsStateRequest() {
    return type == HostMessagesRaw::StateRequest ?
      reinterpret_cast<rpc::StateRequestRawT *>(value) : nullptr;
  }
  const rpc::StateRequestRawT *AsStateRequest() const {
    return type == HostMessagesRaw::StateRequest ?
      reinterpret_cast<const rpc::StateRequestRawT *>(value) : nullptr;
  }
};

bool VerifyHostMessagesRaw(flatbuffers::Verifier &verifier, const void *obj, HostMessagesRaw type);
bool VerifyHostMessagesRawVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<HostMessagesRaw> *types);

enum class ExecutorMessagesRaw : uint8_t {
  NONE = 0,
  ExecResult = 1,
  Executing = 2,
  State = 3,
  MIN = NONE,
  MAX = State
};

inline const ExecutorMessagesRaw (&EnumValuesExecutorMessagesRaw())[4] {
  static const ExecutorMessagesRaw values[] = {
    ExecutorMessagesRaw::NONE,
    ExecutorMessagesRaw::ExecResult,
    ExecutorMessagesRaw::Executing,
    ExecutorMessagesRaw::State
  };
  return values;
}

inline const char * const *EnumNamesExecutorMessagesRaw() {
  static const char * const names[5] = {
    "NONE",
    "ExecResult",
    "Executing",
    "State",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecutorMessagesRaw(ExecutorMessagesRaw e) {
  if (flatbuffers::IsOutRange(e, ExecutorMessagesRaw::NONE, ExecutorMessagesRaw::State)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutorMessagesRaw()[index];
}

template<typename T> struct ExecutorMessagesRawTraits {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::NONE;
};

template<> struct ExecutorMessagesRawTraits<rpc::ExecResultRaw> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::ExecResult;
};

template<> struct ExecutorMessagesRawTraits<rpc::ExecutingMessageRaw> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::Executing;
};

template<> struct ExecutorMessagesRawTraits<rpc::StateResultRaw> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::State;
};

template<typename T> struct ExecutorMessagesRawUnionTraits {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::NONE;
};

template<> struct ExecutorMessagesRawUnionTraits<rpc::ExecResultRawT> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::ExecResult;
};

template<> struct ExecutorMessagesRawUnionTraits<rpc::ExecutingMessageRawT> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::Executing;
};

template<> struct ExecutorMessagesRawUnionTraits<rpc::StateResultRawT> {
  static const ExecutorMessagesRaw enum_value = ExecutorMessagesRaw::State;
};

struct ExecutorMessagesRawUnion {
  ExecutorMessagesRaw type;
  void *value;

  ExecutorMessagesRawUnion() : type(ExecutorMessagesRaw::NONE), value(nullptr) {}
  ExecutorMessagesRawUnion(ExecutorMessagesRawUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ExecutorMessagesRaw::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ExecutorMessagesRawUnion(const ExecutorMessagesRawUnion &);
  ExecutorMessagesRawUnion &operator=(const ExecutorMessagesRawUnion &u)
    { ExecutorMessagesRawUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ExecutorMessagesRawUnion &operator=(ExecutorMessagesRawUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ExecutorMessagesRawUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ExecutorMessagesRawUnionTraits<RT>::enum_value;
    if (type != ExecutorMessagesRaw::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ExecutorMessagesRaw type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  rpc::ExecResultRawT *AsExecResult() {
    return type == ExecutorMessagesRaw::ExecResult ?
      reinterpret_cast<rpc::ExecResultRawT *>(value) : nullptr;
  }
  const rpc::ExecResultRawT *AsExecResult() const {
    return type == ExecutorMessagesRaw::ExecResult ?
      reinterpret_cast<const rpc::ExecResultRawT *>(value) : nullptr;
  }
  rpc::ExecutingMessageRawT *AsExecuting() {
    return type == ExecutorMessagesRaw::Executing ?
      reinterpret_cast<rpc::ExecutingMessageRawT *>(value) : nullptr;
  }
  const rpc::ExecutingMessageRawT *AsExecuting() const {
    return type == ExecutorMessagesRaw::Executing ?
      reinterpret_cast<const rpc::ExecutingMessageRawT *>(value) : nullptr;
  }
  rpc::StateResultRawT *AsState() {
    return type == ExecutorMessagesRaw::State ?
      reinterpret_cast<rpc::StateResultRawT *>(value) : nullptr;
  }
  const rpc::StateResultRawT *AsState() const {
    return type == ExecutorMessagesRaw::State ?
      reinterpret_cast<const rpc::StateResultRawT *>(value) : nullptr;
  }
};

bool VerifyExecutorMessagesRaw(flatbuffers::Verifier &verifier, const void *obj, ExecutorMessagesRaw type);
bool VerifyExecutorMessagesRawVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ExecutorMessagesRaw> *types);

enum class RequestFlag : uint64_t {
  IsBinary = 1ULL,
  ReturnOutput = 2ULL,
  ReturnError = 4ULL,
  NONE = 0,
  ANY = 7ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(RequestFlag, uint64_t)

inline const RequestFlag (&EnumValuesRequestFlag())[3] {
  static const RequestFlag values[] = {
    RequestFlag::IsBinary,
    RequestFlag::ReturnOutput,
    RequestFlag::ReturnError
  };
  return values;
}

inline const char * const *EnumNamesRequestFlag() {
  static const char * const names[5] = {
    "IsBinary",
    "ReturnOutput",
    "",
    "ReturnError",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestFlag(RequestFlag e) {
  if (flatbuffers::IsOutRange(e, RequestFlag::IsBinary, RequestFlag::ReturnError)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(RequestFlag::IsBinary);
  return EnumNamesRequestFlag()[index];
}

enum class ExecEnv : uint64_t {
  Debug = 1ULL,
  Signal = 2ULL,
  ResetState = 4ULL,
  SandboxNone = 8ULL,
  SandboxSetuid = 16ULL,
  SandboxNamespace = 32ULL,
  SandboxAndroid = 64ULL,
  ExtraCover = 128ULL,
  EnableTun = 256ULL,
  EnableNetDev = 512ULL,
  EnableNetReset = 1024ULL,
  EnableCgroups = 2048ULL,
  EnableCloseFds = 4096ULL,
  EnableDevlinkPCI = 8192ULL,
  EnableVhciInjection = 16384ULL,
  EnableWifi = 32768ULL,
  DelayKcovMmap = 65536ULL,
  EnableNicVF = 131072ULL,
  NONE = 0,
  ANY = 262143ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(ExecEnv, uint64_t)

inline const ExecEnv (&EnumValuesExecEnv())[18] {
  static const ExecEnv values[] = {
    ExecEnv::Debug,
    ExecEnv::Signal,
    ExecEnv::ResetState,
    ExecEnv::SandboxNone,
    ExecEnv::SandboxSetuid,
    ExecEnv::SandboxNamespace,
    ExecEnv::SandboxAndroid,
    ExecEnv::ExtraCover,
    ExecEnv::EnableTun,
    ExecEnv::EnableNetDev,
    ExecEnv::EnableNetReset,
    ExecEnv::EnableCgroups,
    ExecEnv::EnableCloseFds,
    ExecEnv::EnableDevlinkPCI,
    ExecEnv::EnableVhciInjection,
    ExecEnv::EnableWifi,
    ExecEnv::DelayKcovMmap,
    ExecEnv::EnableNicVF
  };
  return values;
}

inline const char *EnumNameExecEnv(ExecEnv e) {
  switch (e) {
    case ExecEnv::Debug: return "Debug";
    case ExecEnv::Signal: return "Signal";
    case ExecEnv::ResetState: return "ResetState";
    case ExecEnv::SandboxNone: return "SandboxNone";
    case ExecEnv::SandboxSetuid: return "SandboxSetuid";
    case ExecEnv::SandboxNamespace: return "SandboxNamespace";
    case ExecEnv::SandboxAndroid: return "SandboxAndroid";
    case ExecEnv::ExtraCover: return "ExtraCover";
    case ExecEnv::EnableTun: return "EnableTun";
    case ExecEnv::EnableNetDev: return "EnableNetDev";
    case ExecEnv::EnableNetReset: return "EnableNetReset";
    case ExecEnv::EnableCgroups: return "EnableCgroups";
    case ExecEnv::EnableCloseFds: return "EnableCloseFds";
    case ExecEnv::EnableDevlinkPCI: return "EnableDevlinkPCI";
    case ExecEnv::EnableVhciInjection: return "EnableVhciInjection";
    case ExecEnv::EnableWifi: return "EnableWifi";
    case ExecEnv::DelayKcovMmap: return "DelayKcovMmap";
    case ExecEnv::EnableNicVF: return "EnableNicVF";
    default: return "";
  }
}

enum class ExecFlag : uint64_t {
  CollectSignal = 1ULL,
  CollectCover = 2ULL,
  DedupCover = 4ULL,
  CollectComps = 8ULL,
  Threaded = 16ULL,
  NONE = 0,
  ANY = 31ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(ExecFlag, uint64_t)

inline const ExecFlag (&EnumValuesExecFlag())[5] {
  static const ExecFlag values[] = {
    ExecFlag::CollectSignal,
    ExecFlag::CollectCover,
    ExecFlag::DedupCover,
    ExecFlag::CollectComps,
    ExecFlag::Threaded
  };
  return values;
}

inline const char * const *EnumNamesExecFlag() {
  static const char * const names[17] = {
    "CollectSignal",
    "CollectCover",
    "",
    "DedupCover",
    "",
    "",
    "",
    "CollectComps",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Threaded",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecFlag(ExecFlag e) {
  if (flatbuffers::IsOutRange(e, ExecFlag::CollectSignal, ExecFlag::Threaded)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ExecFlag::CollectSignal);
  return EnumNamesExecFlag()[index];
}

enum class CallFlag : uint8_t {
  Executed = 1,
  Finished = 2,
  Blocked = 4,
  FaultInjected = 8,
  CoverageOverflow = 16,
  NONE = 0,
  ANY = 31
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(CallFlag, uint8_t)

inline const CallFlag (&EnumValuesCallFlag())[5] {
  static const CallFlag values[] = {
    CallFlag::Executed,
    CallFlag::Finished,
    CallFlag::Blocked,
    CallFlag::FaultInjected,
    CallFlag::CoverageOverflow
  };
  return values;
}

inline const char * const *EnumNamesCallFlag() {
  static const char * const names[17] = {
    "Executed",
    "Finished",
    "",
    "Blocked",
    "",
    "",
    "",
    "FaultInjected",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "CoverageOverflow",
    nullptr
  };
  return names;
}

inline const char *EnumNameCallFlag(CallFlag e) {
  if (flatbuffers::IsOutRange(e, CallFlag::Executed, CallFlag::CoverageOverflow)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(CallFlag::Executed);
  return EnumNamesCallFlag()[index];
}

enum class SnapshotState : uint64_t {
  Initial = 0,
  Handshake = 1ULL,
  Ready = 2ULL,
  Snapshotted = 3ULL,
  Execute = 4ULL,
  Executed = 5ULL,
  Failed = 6ULL,
  MIN = Initial,
  MAX = Failed
};

inline const SnapshotState (&EnumValuesSnapshotState())[7] {
  static const SnapshotState values[] = {
    SnapshotState::Initial,
    SnapshotState::Handshake,
    SnapshotState::Ready,
    SnapshotState::Snapshotted,
    SnapshotState::Execute,
    SnapshotState::Executed,
    SnapshotState::Failed
  };
  return values;
}

inline const char * const *EnumNamesSnapshotState() {
  static const char * const names[8] = {
    "Initial",
    "Handshake",
    "Ready",
    "Snapshotted",
    "Execute",
    "Executed",
    "Failed",
    nullptr
  };
  return names;
}

inline const char *EnumNameSnapshotState(SnapshotState e) {
  if (flatbuffers::IsOutRange(e, SnapshotState::Initial, SnapshotState::Failed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSnapshotState()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ExecOptsRaw FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t env_flags_;
  uint64_t exec_flags_;
  int64_t sandbox_arg_;

 public:
  ExecOptsRaw()
      : env_flags_(0),
        exec_flags_(0),
        sandbox_arg_(0) {
  }
  ExecOptsRaw(rpc::ExecEnv _env_flags, rpc::ExecFlag _exec_flags, int64_t _sandbox_arg)
      : env_flags_(flatbuffers::EndianScalar(static_cast<uint64_t>(_env_flags))),
        exec_flags_(flatbuffers::EndianScalar(static_cast<uint64_t>(_exec_flags))),
        sandbox_arg_(flatbuffers::EndianScalar(_sandbox_arg)) {
  }
  rpc::ExecEnv env_flags() const {
    return static_cast<rpc::ExecEnv>(flatbuffers::EndianScalar(env_flags_));
  }
  rpc::ExecFlag exec_flags() const {
    return static_cast<rpc::ExecFlag>(flatbuffers::EndianScalar(exec_flags_));
  }
  int64_t sandbox_arg() const {
    return flatbuffers::EndianScalar(sandbox_arg_);
  }
};
FLATBUFFERS_STRUCT_END(ExecOptsRaw, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ComparisonRaw FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t pc_;
  uint64_t op1_;
  uint64_t op2_;
  uint8_t is_const_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  ComparisonRaw()
      : pc_(0),
        op1_(0),
        op2_(0),
        is_const_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  ComparisonRaw(uint64_t _pc, uint64_t _op1, uint64_t _op2, bool _is_const)
      : pc_(flatbuffers::EndianScalar(_pc)),
        op1_(flatbuffers::EndianScalar(_op1)),
        op2_(flatbuffers::EndianScalar(_op2)),
        is_const_(flatbuffers::EndianScalar(static_cast<uint8_t>(_is_const))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  uint64_t pc() const {
    return flatbuffers::EndianScalar(pc_);
  }
  uint64_t op1() const {
    return flatbuffers::EndianScalar(op1_);
  }
  uint64_t op2() const {
    return flatbuffers::EndianScalar(op2_);
  }
  bool is_const() const {
    return flatbuffers::EndianScalar(is_const_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(ComparisonRaw, 32);

struct ConnectRequestRawT : public flatbuffers::NativeTable {
  typedef ConnectRequestRaw TableType;
  int64_t id = 0;
  std::string arch{};
  std::string git_revision{};
  std::string syz_revision{};
};

struct ConnectRequestRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectRequestRawT NativeTableType;
  typedef ConnectRequestRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ARCH = 6,
    VT_GIT_REVISION = 8,
    VT_SYZ_REVISION = 10
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  const flatbuffers::String *arch() const {
    return GetPointer<const flatbuffers::String *>(VT_ARCH);
  }
  const flatbuffers::String *git_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_GIT_REVISION);
  }
  const flatbuffers::String *syz_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_SYZ_REVISION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_ARCH) &&
           verifier.VerifyString(arch()) &&
           VerifyOffset(verifier, VT_GIT_REVISION) &&
           verifier.VerifyString(git_revision()) &&
           VerifyOffset(verifier, VT_SYZ_REVISION) &&
           verifier.VerifyString(syz_revision()) &&
           verifier.EndTable();
  }
  ConnectRequestRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConnectRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConnectRequestRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConnectRequestRawBuilder {
  typedef ConnectRequestRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ConnectRequestRaw::VT_ID, id, 0);
  }
  void add_arch(flatbuffers::Offset<flatbuffers::String> arch) {
    fbb_.AddOffset(ConnectRequestRaw::VT_ARCH, arch);
  }
  void add_git_revision(flatbuffers::Offset<flatbuffers::String> git_revision) {
    fbb_.AddOffset(ConnectRequestRaw::VT_GIT_REVISION, git_revision);
  }
  void add_syz_revision(flatbuffers::Offset<flatbuffers::String> syz_revision) {
    fbb_.AddOffset(ConnectRequestRaw::VT_SYZ_REVISION, syz_revision);
  }
  explicit ConnectRequestRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectRequestRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectRequestRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectRequestRaw> CreateConnectRequestRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    flatbuffers::Offset<flatbuffers::String> arch = 0,
    flatbuffers::Offset<flatbuffers::String> git_revision = 0,
    flatbuffers::Offset<flatbuffers::String> syz_revision = 0) {
  ConnectRequestRawBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_syz_revision(syz_revision);
  builder_.add_git_revision(git_revision);
  builder_.add_arch(arch);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectRequestRaw> CreateConnectRequestRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    const char *arch = nullptr,
    const char *git_revision = nullptr,
    const char *syz_revision = nullptr) {
  auto arch__ = arch ? _fbb.CreateString(arch) : 0;
  auto git_revision__ = git_revision ? _fbb.CreateString(git_revision) : 0;
  auto syz_revision__ = syz_revision ? _fbb.CreateString(syz_revision) : 0;
  return rpc::CreateConnectRequestRaw(
      _fbb,
      id,
      arch__,
      git_revision__,
      syz_revision__);
}

flatbuffers::Offset<ConnectRequestRaw> CreateConnectRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConnectReplyRawT : public flatbuffers::NativeTable {
  typedef ConnectReplyRaw TableType;
  bool debug = false;
  bool cover = false;
  bool cover_edges = false;
  bool kernel_64_bit = false;
  int32_t procs = 0;
  int32_t slowdown = 0;
  int32_t syscall_timeout_ms = 0;
  int32_t program_timeout_ms = 0;
  std::vector<std::string> leak_frames{};
  std::vector<std::string> race_frames{};
  rpc::Feature features = static_cast<rpc::Feature>(0);
  std::vector<std::string> files{};
  std::vector<std::string> globs{};
};

struct ConnectReplyRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectReplyRawT NativeTableType;
  typedef ConnectReplyRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEBUG = 4,
    VT_COVER = 6,
    VT_COVER_EDGES = 8,
    VT_KERNEL_64_BIT = 10,
    VT_PROCS = 12,
    VT_SLOWDOWN = 14,
    VT_SYSCALL_TIMEOUT_MS = 16,
    VT_PROGRAM_TIMEOUT_MS = 18,
    VT_LEAK_FRAMES = 20,
    VT_RACE_FRAMES = 22,
    VT_FEATURES = 24,
    VT_FILES = 26,
    VT_GLOBS = 28
  };
  bool debug() const {
    return GetField<uint8_t>(VT_DEBUG, 0) != 0;
  }
  bool cover() const {
    return GetField<uint8_t>(VT_COVER, 0) != 0;
  }
  bool cover_edges() const {
    return GetField<uint8_t>(VT_COVER_EDGES, 0) != 0;
  }
  bool kernel_64_bit() const {
    return GetField<uint8_t>(VT_KERNEL_64_BIT, 0) != 0;
  }
  int32_t procs() const {
    return GetField<int32_t>(VT_PROCS, 0);
  }
  int32_t slowdown() const {
    return GetField<int32_t>(VT_SLOWDOWN, 0);
  }
  int32_t syscall_timeout_ms() const {
    return GetField<int32_t>(VT_SYSCALL_TIMEOUT_MS, 0);
  }
  int32_t program_timeout_ms() const {
    return GetField<int32_t>(VT_PROGRAM_TIMEOUT_MS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *leak_frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LEAK_FRAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *race_frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_RACE_FRAMES);
  }
  rpc::Feature features() const {
    return static_cast<rpc::Feature>(GetField<uint64_t>(VT_FEATURES, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *globs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_GLOBS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DEBUG, 1) &&
           VerifyField<uint8_t>(verifier, VT_COVER, 1) &&
           VerifyField<uint8_t>(verifier, VT_COVER_EDGES, 1) &&
           VerifyField<uint8_t>(verifier, VT_KERNEL_64_BIT, 1) &&
           VerifyField<int32_t>(verifier, VT_PROCS, 4) &&
           VerifyField<int32_t>(verifier, VT_SLOWDOWN, 4) &&
           VerifyField<int32_t>(verifier, VT_SYSCALL_TIMEOUT_MS, 4) &&
           VerifyField<int32_t>(verifier, VT_PROGRAM_TIMEOUT_MS, 4) &&
           VerifyOffset(verifier, VT_LEAK_FRAMES) &&
           verifier.VerifyVector(leak_frames()) &&
           verifier.VerifyVectorOfStrings(leak_frames()) &&
           VerifyOffset(verifier, VT_RACE_FRAMES) &&
           verifier.VerifyVector(race_frames()) &&
           verifier.VerifyVectorOfStrings(race_frames()) &&
           VerifyField<uint64_t>(verifier, VT_FEATURES, 8) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           VerifyOffset(verifier, VT_GLOBS) &&
           verifier.VerifyVector(globs()) &&
           verifier.VerifyVectorOfStrings(globs()) &&
           verifier.EndTable();
  }
  ConnectReplyRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConnectReplyRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConnectReplyRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConnectReplyRawBuilder {
  typedef ConnectReplyRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debug(bool debug) {
    fbb_.AddElement<uint8_t>(ConnectReplyRaw::VT_DEBUG, static_cast<uint8_t>(debug), 0);
  }
  void add_cover(bool cover) {
    fbb_.AddElement<uint8_t>(ConnectReplyRaw::VT_COVER, static_cast<uint8_t>(cover), 0);
  }
  void add_cover_edges(bool cover_edges) {
    fbb_.AddElement<uint8_t>(ConnectReplyRaw::VT_COVER_EDGES, static_cast<uint8_t>(cover_edges), 0);
  }
  void add_kernel_64_bit(bool kernel_64_bit) {
    fbb_.AddElement<uint8_t>(ConnectReplyRaw::VT_KERNEL_64_BIT, static_cast<uint8_t>(kernel_64_bit), 0);
  }
  void add_procs(int32_t procs) {
    fbb_.AddElement<int32_t>(ConnectReplyRaw::VT_PROCS, procs, 0);
  }
  void add_slowdown(int32_t slowdown) {
    fbb_.AddElement<int32_t>(ConnectReplyRaw::VT_SLOWDOWN, slowdown, 0);
  }
  void add_syscall_timeout_ms(int32_t syscall_timeout_ms) {
    fbb_.AddElement<int32_t>(ConnectReplyRaw::VT_SYSCALL_TIMEOUT_MS, syscall_timeout_ms, 0);
  }
  void add_program_timeout_ms(int32_t program_timeout_ms) {
    fbb_.AddElement<int32_t>(ConnectReplyRaw::VT_PROGRAM_TIMEOUT_MS, program_timeout_ms, 0);
  }
  void add_leak_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> leak_frames) {
    fbb_.AddOffset(ConnectReplyRaw::VT_LEAK_FRAMES, leak_frames);
  }
  void add_race_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> race_frames) {
    fbb_.AddOffset(ConnectReplyRaw::VT_RACE_FRAMES, race_frames);
  }
  void add_features(rpc::Feature features) {
    fbb_.AddElement<uint64_t>(ConnectReplyRaw::VT_FEATURES, static_cast<uint64_t>(features), 0);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) {
    fbb_.AddOffset(ConnectReplyRaw::VT_FILES, files);
  }
  void add_globs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> globs) {
    fbb_.AddOffset(ConnectReplyRaw::VT_GLOBS, globs);
  }
  explicit ConnectReplyRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectReplyRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectReplyRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectReplyRaw> CreateConnectReplyRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool debug = false,
    bool cover = false,
    bool cover_edges = false,
    bool kernel_64_bit = false,
    int32_t procs = 0,
    int32_t slowdown = 0,
    int32_t syscall_timeout_ms = 0,
    int32_t program_timeout_ms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> leak_frames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> race_frames = 0,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> globs = 0) {
  ConnectReplyRawBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_globs(globs);
  builder_.add_files(files);
  builder_.add_race_frames(race_frames);
  builder_.add_leak_frames(leak_frames);
  builder_.add_program_timeout_ms(program_timeout_ms);
  builder_.add_syscall_timeout_ms(syscall_timeout_ms);
  builder_.add_slowdown(slowdown);
  builder_.add_procs(procs);
  builder_.add_kernel_64_bit(kernel_64_bit);
  builder_.add_cover_edges(cover_edges);
  builder_.add_cover(cover);
  builder_.add_debug(debug);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectReplyRaw> CreateConnectReplyRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool debug = false,
    bool cover = false,
    bool cover_edges = false,
    bool kernel_64_bit = false,
    int32_t procs = 0,
    int32_t slowdown = 0,
    int32_t syscall_timeout_ms = 0,
    int32_t program_timeout_ms = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *leak_frames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *race_frames = nullptr,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *globs = nullptr) {
  auto leak_frames__ = leak_frames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*leak_frames) : 0;
  auto race_frames__ = race_frames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*race_frames) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0;
  auto globs__ = globs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*globs) : 0;
  return rpc::CreateConnectReplyRaw(
      _fbb,
      debug,
      cover,
      cover_edges,
      kernel_64_bit,
      procs,
      slowdown,
      syscall_timeout_ms,
      program_timeout_ms,
      leak_frames__,
      race_frames__,
      features,
      files__,
      globs__);
}

flatbuffers::Offset<ConnectReplyRaw> CreateConnectReplyRaw(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InfoRequestRawT : public flatbuffers::NativeTable {
  typedef InfoRequestRaw TableType;
  std::string error{};
  std::vector<std::unique_ptr<rpc::FeatureInfoRawT>> features{};
  std::vector<std::unique_ptr<rpc::FileInfoRawT>> files{};
  std::vector<std::unique_ptr<rpc::GlobInfoRawT>> globs{};
  InfoRequestRawT() = default;
  InfoRequestRawT(const InfoRequestRawT &o);
  InfoRequestRawT(InfoRequestRawT&&) FLATBUFFERS_NOEXCEPT = default;
  InfoRequestRawT &operator=(InfoRequestRawT o) FLATBUFFERS_NOEXCEPT;
};

struct InfoRequestRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InfoRequestRawT NativeTableType;
  typedef InfoRequestRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_FEATURES = 6,
    VT_FILES = 8,
    VT_GLOBS = 10
  };
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::FeatureInfoRaw>> *features() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::FeatureInfoRaw>> *>(VT_FEATURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfoRaw>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfoRaw>> *>(VT_FILES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfoRaw>> *globs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfoRaw>> *>(VT_GLOBS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           VerifyOffset(verifier, VT_GLOBS) &&
           verifier.VerifyVector(globs()) &&
           verifier.VerifyVectorOfTables(globs()) &&
           verifier.EndTable();
  }
  InfoRequestRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InfoRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InfoRequestRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InfoRequestRawBuilder {
  typedef InfoRequestRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(InfoRequestRaw::VT_ERROR, error);
  }
  void add_features(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FeatureInfoRaw>>> features) {
    fbb_.AddOffset(InfoRequestRaw::VT_FEATURES, features);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfoRaw>>> files) {
    fbb_.AddOffset(InfoRequestRaw::VT_FILES, files);
  }
  void add_globs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfoRaw>>> globs) {
    fbb_.AddOffset(InfoRequestRaw::VT_GLOBS, globs);
  }
  explicit InfoRequestRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InfoRequestRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfoRequestRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfoRequestRaw> CreateInfoRequestRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FeatureInfoRaw>>> features = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfoRaw>>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfoRaw>>> globs = 0) {
  InfoRequestRawBuilder builder_(_fbb);
  builder_.add_globs(globs);
  builder_.add_files(files);
  builder_.add_features(features);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<InfoRequestRaw> CreateInfoRequestRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    const std::vector<flatbuffers::Offset<rpc::FeatureInfoRaw>> *features = nullptr,
    const std::vector<flatbuffers::Offset<rpc::FileInfoRaw>> *files = nullptr,
    const std::vector<flatbuffers::Offset<rpc::GlobInfoRaw>> *globs = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto features__ = features ? _fbb.CreateVector<flatbuffers::Offset<rpc::FeatureInfoRaw>>(*features) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<rpc::FileInfoRaw>>(*files) : 0;
  auto globs__ = globs ? _fbb.CreateVector<flatbuffers::Offset<rpc::GlobInfoRaw>>(*globs) : 0;
  return rpc::CreateInfoRequestRaw(
      _fbb,
      error__,
      features__,
      files__,
      globs__);
}

flatbuffers::Offset<InfoRequestRaw> CreateInfoRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InfoReplyRawT : public flatbuffers::NativeTable {
  typedef InfoReplyRaw TableType;
  std::vector<uint64_t> cover_filter{};
};

struct InfoReplyRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InfoReplyRawT NativeTableType;
  typedef InfoReplyRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COVER_FILTER = 4
  };
  const flatbuffers::Vector<uint64_t> *cover_filter() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_COVER_FILTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COVER_FILTER) &&
           verifier.VerifyVector(cover_filter()) &&
           verifier.EndTable();
  }
  InfoReplyRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InfoReplyRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InfoReplyRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InfoReplyRawBuilder {
  typedef InfoReplyRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cover_filter(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cover_filter) {
    fbb_.AddOffset(InfoReplyRaw::VT_COVER_FILTER, cover_filter);
  }
  explicit InfoReplyRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InfoReplyRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfoReplyRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfoReplyRaw> CreateInfoReplyRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cover_filter = 0) {
  InfoReplyRawBuilder builder_(_fbb);
  builder_.add_cover_filter(cover_filter);
  return builder_.Finish();
}

inline flatbuffers::Offset<InfoReplyRaw> CreateInfoReplyRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *cover_filter = nullptr) {
  auto cover_filter__ = cover_filter ? _fbb.CreateVector<uint64_t>(*cover_filter) : 0;
  return rpc::CreateInfoReplyRaw(
      _fbb,
      cover_filter__);
}

flatbuffers::Offset<InfoReplyRaw> CreateInfoReplyRaw(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileInfoRawT : public flatbuffers::NativeTable {
  typedef FileInfoRaw TableType;
  std::string name{};
  bool exists = false;
  std::string error{};
  std::vector<uint8_t> data{};
};

struct FileInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileInfoRawT NativeTableType;
  typedef FileInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_EXISTS = 6,
    VT_ERROR = 8,
    VT_DATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool exists() const {
    return GetField<uint8_t>(VT_EXISTS, 0) != 0;
  }
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_EXISTS, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  FileInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FileInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileInfoRawBuilder {
  typedef FileInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FileInfoRaw::VT_NAME, name);
  }
  void add_exists(bool exists) {
    fbb_.AddElement<uint8_t>(FileInfoRaw::VT_EXISTS, static_cast<uint8_t>(exists), 0);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(FileInfoRaw::VT_ERROR, error);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(FileInfoRaw::VT_DATA, data);
  }
  explicit FileInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileInfoRaw> CreateFileInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool exists = false,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  FileInfoRawBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_error(error);
  builder_.add_name(name);
  builder_.add_exists(exists);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileInfoRaw> CreateFileInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool exists = false,
    const char *error = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return rpc::CreateFileInfoRaw(
      _fbb,
      name__,
      exists,
      error__,
      data__);
}

flatbuffers::Offset<FileInfoRaw> CreateFileInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GlobInfoRawT : public flatbuffers::NativeTable {
  typedef GlobInfoRaw TableType;
  std::string name{};
  std::vector<std::string> files{};
};

struct GlobInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GlobInfoRawT NativeTableType;
  typedef GlobInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FILES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           verifier.EndTable();
  }
  GlobInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GlobInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GlobInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GlobInfoRawBuilder {
  typedef GlobInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GlobInfoRaw::VT_NAME, name);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) {
    fbb_.AddOffset(GlobInfoRaw::VT_FILES, files);
  }
  explicit GlobInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GlobInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GlobInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<GlobInfoRaw> CreateGlobInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0) {
  GlobInfoRawBuilder builder_(_fbb);
  builder_.add_files(files);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<GlobInfoRaw> CreateGlobInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0;
  return rpc::CreateGlobInfoRaw(
      _fbb,
      name__,
      files__);
}

flatbuffers::Offset<GlobInfoRaw> CreateGlobInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FeatureInfoRawT : public flatbuffers::NativeTable {
  typedef FeatureInfoRaw TableType;
  rpc::Feature id = static_cast<rpc::Feature>(0);
  bool need_setup = false;
  std::string reason{};
};

struct FeatureInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FeatureInfoRawT NativeTableType;
  typedef FeatureInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NEED_SETUP = 6,
    VT_REASON = 8
  };
  rpc::Feature id() const {
    return static_cast<rpc::Feature>(GetField<uint64_t>(VT_ID, 0));
  }
  bool need_setup() const {
    return GetField<uint8_t>(VT_NEED_SETUP, 0) != 0;
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_NEED_SETUP, 1) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
  FeatureInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FeatureInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FeatureInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FeatureInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FeatureInfoRawBuilder {
  typedef FeatureInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(rpc::Feature id) {
    fbb_.AddElement<uint64_t>(FeatureInfoRaw::VT_ID, static_cast<uint64_t>(id), 0);
  }
  void add_need_setup(bool need_setup) {
    fbb_.AddElement<uint8_t>(FeatureInfoRaw::VT_NEED_SETUP, static_cast<uint8_t>(need_setup), 0);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(FeatureInfoRaw::VT_REASON, reason);
  }
  explicit FeatureInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FeatureInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FeatureInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<FeatureInfoRaw> CreateFeatureInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::Feature id = static_cast<rpc::Feature>(0),
    bool need_setup = false,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  FeatureInfoRawBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_reason(reason);
  builder_.add_need_setup(need_setup);
  return builder_.Finish();
}

inline flatbuffers::Offset<FeatureInfoRaw> CreateFeatureInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::Feature id = static_cast<rpc::Feature>(0),
    bool need_setup = false,
    const char *reason = nullptr) {
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return rpc::CreateFeatureInfoRaw(
      _fbb,
      id,
      need_setup,
      reason__);
}

flatbuffers::Offset<FeatureInfoRaw> CreateFeatureInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const FeatureInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostMessageRawT : public flatbuffers::NativeTable {
  typedef HostMessageRaw TableType;
  rpc::HostMessagesRawUnion msg{};
};

struct HostMessageRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostMessageRawT NativeTableType;
  typedef HostMessageRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  rpc::HostMessagesRaw msg_type() const {
    return static_cast<rpc::HostMessagesRaw>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const rpc::ExecRequestRaw *msg_as_ExecRequest() const {
    return msg_type() == rpc::HostMessagesRaw::ExecRequest ? static_cast<const rpc::ExecRequestRaw *>(msg()) : nullptr;
  }
  const rpc::SignalUpdateRaw *msg_as_SignalUpdate() const {
    return msg_type() == rpc::HostMessagesRaw::SignalUpdate ? static_cast<const rpc::SignalUpdateRaw *>(msg()) : nullptr;
  }
  const rpc::CorpusTriagedRaw *msg_as_CorpusTriaged() const {
    return msg_type() == rpc::HostMessagesRaw::CorpusTriaged ? static_cast<const rpc::CorpusTriagedRaw *>(msg()) : nullptr;
  }
  const rpc::StateRequestRaw *msg_as_StateRequest() const {
    return msg_type() == rpc::HostMessagesRaw::StateRequest ? static_cast<const rpc::StateRequestRaw *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyHostMessagesRaw(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  HostMessageRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostMessageRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const rpc::ExecRequestRaw *HostMessageRaw::msg_as<rpc::ExecRequestRaw>() const {
  return msg_as_ExecRequest();
}

template<> inline const rpc::SignalUpdateRaw *HostMessageRaw::msg_as<rpc::SignalUpdateRaw>() const {
  return msg_as_SignalUpdate();
}

template<> inline const rpc::CorpusTriagedRaw *HostMessageRaw::msg_as<rpc::CorpusTriagedRaw>() const {
  return msg_as_CorpusTriaged();
}

template<> inline const rpc::StateRequestRaw *HostMessageRaw::msg_as<rpc::StateRequestRaw>() const {
  return msg_as_StateRequest();
}

struct HostMessageRawBuilder {
  typedef HostMessageRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(rpc::HostMessagesRaw msg_type) {
    fbb_.AddElement<uint8_t>(HostMessageRaw::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(HostMessageRaw::VT_MSG, msg);
  }
  explicit HostMessageRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HostMessageRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostMessageRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostMessageRaw> CreateHostMessageRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::HostMessagesRaw msg_type = rpc::HostMessagesRaw::NONE,
    flatbuffers::Offset<void> msg = 0) {
  HostMessageRawBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<HostMessageRaw> CreateHostMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecutorMessageRawT : public flatbuffers::NativeTable {
  typedef ExecutorMessageRaw TableType;
  rpc::ExecutorMessagesRawUnion msg{};
};

struct ExecutorMessageRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutorMessageRawT NativeTableType;
  typedef ExecutorMessageRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  rpc::ExecutorMessagesRaw msg_type() const {
    return static_cast<rpc::ExecutorMessagesRaw>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const rpc::ExecResultRaw *msg_as_ExecResult() const {
    return msg_type() == rpc::ExecutorMessagesRaw::ExecResult ? static_cast<const rpc::ExecResultRaw *>(msg()) : nullptr;
  }
  const rpc::ExecutingMessageRaw *msg_as_Executing() const {
    return msg_type() == rpc::ExecutorMessagesRaw::Executing ? static_cast<const rpc::ExecutingMessageRaw *>(msg()) : nullptr;
  }
  const rpc::StateResultRaw *msg_as_State() const {
    return msg_type() == rpc::ExecutorMessagesRaw::State ? static_cast<const rpc::StateResultRaw *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyExecutorMessagesRaw(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  ExecutorMessageRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecutorMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecutorMessageRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const rpc::ExecResultRaw *ExecutorMessageRaw::msg_as<rpc::ExecResultRaw>() const {
  return msg_as_ExecResult();
}

template<> inline const rpc::ExecutingMessageRaw *ExecutorMessageRaw::msg_as<rpc::ExecutingMessageRaw>() const {
  return msg_as_Executing();
}

template<> inline const rpc::StateResultRaw *ExecutorMessageRaw::msg_as<rpc::StateResultRaw>() const {
  return msg_as_State();
}

struct ExecutorMessageRawBuilder {
  typedef ExecutorMessageRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(rpc::ExecutorMessagesRaw msg_type) {
    fbb_.AddElement<uint8_t>(ExecutorMessageRaw::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(ExecutorMessageRaw::VT_MSG, msg);
  }
  explicit ExecutorMessageRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutorMessageRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutorMessageRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutorMessageRaw> CreateExecutorMessageRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::ExecutorMessagesRaw msg_type = rpc::ExecutorMessagesRaw::NONE,
    flatbuffers::Offset<void> msg = 0) {
  ExecutorMessageRawBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<ExecutorMessageRaw> CreateExecutorMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecRequestRawT : public flatbuffers::NativeTable {
  typedef ExecRequestRaw TableType;
  int64_t id = 0;
  uint64_t avoid = 0;
  std::vector<uint8_t> prog_data{};
  std::unique_ptr<rpc::ExecOptsRaw> exec_opts{};
  rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0);
  std::vector<int32_t> all_signal{};
  ExecRequestRawT() = default;
  ExecRequestRawT(const ExecRequestRawT &o);
  ExecRequestRawT(ExecRequestRawT&&) FLATBUFFERS_NOEXCEPT = default;
  ExecRequestRawT &operator=(ExecRequestRawT o) FLATBUFFERS_NOEXCEPT;
};

struct ExecRequestRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecRequestRawT NativeTableType;
  typedef ExecRequestRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_AVOID = 6,
    VT_PROG_DATA = 8,
    VT_EXEC_OPTS = 10,
    VT_FLAGS = 12,
    VT_ALL_SIGNAL = 14
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  uint64_t avoid() const {
    return GetField<uint64_t>(VT_AVOID, 0);
  }
  const flatbuffers::Vector<uint8_t> *prog_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PROG_DATA);
  }
  const rpc::ExecOptsRaw *exec_opts() const {
    return GetStruct<const rpc::ExecOptsRaw *>(VT_EXEC_OPTS);
  }
  rpc::RequestFlag flags() const {
    return static_cast<rpc::RequestFlag>(GetField<uint64_t>(VT_FLAGS, 0));
  }
  const flatbuffers::Vector<int32_t> *all_signal() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ALL_SIGNAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_AVOID, 8) &&
           VerifyOffset(verifier, VT_PROG_DATA) &&
           verifier.VerifyVector(prog_data()) &&
           VerifyField<rpc::ExecOptsRaw>(verifier, VT_EXEC_OPTS, 8) &&
           VerifyField<uint64_t>(verifier, VT_FLAGS, 8) &&
           VerifyOffset(verifier, VT_ALL_SIGNAL) &&
           verifier.VerifyVector(all_signal()) &&
           verifier.EndTable();
  }
  ExecRequestRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecRequestRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecRequestRawBuilder {
  typedef ExecRequestRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ExecRequestRaw::VT_ID, id, 0);
  }
  void add_avoid(uint64_t avoid) {
    fbb_.AddElement<uint64_t>(ExecRequestRaw::VT_AVOID, avoid, 0);
  }
  void add_prog_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prog_data) {
    fbb_.AddOffset(ExecRequestRaw::VT_PROG_DATA, prog_data);
  }
  void add_exec_opts(const rpc::ExecOptsRaw *exec_opts) {
    fbb_.AddStruct(ExecRequestRaw::VT_EXEC_OPTS, exec_opts);
  }
  void add_flags(rpc::RequestFlag flags) {
    fbb_.AddElement<uint64_t>(ExecRequestRaw::VT_FLAGS, static_cast<uint64_t>(flags), 0);
  }
  void add_all_signal(flatbuffers::Offset<flatbuffers::Vector<int32_t>> all_signal) {
    fbb_.AddOffset(ExecRequestRaw::VT_ALL_SIGNAL, all_signal);
  }
  explicit ExecRequestRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecRequestRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecRequestRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecRequestRaw> CreateExecRequestRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    uint64_t avoid = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prog_data = 0,
    const rpc::ExecOptsRaw *exec_opts = nullptr,
    rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0),
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> all_signal = 0) {
  ExecRequestRawBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_avoid(avoid);
  builder_.add_id(id);
  builder_.add_all_signal(all_signal);
  builder_.add_exec_opts(exec_opts);
  builder_.add_prog_data(prog_data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecRequestRaw> CreateExecRequestRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    uint64_t avoid = 0,
    const std::vector<uint8_t> *prog_data = nullptr,
    const rpc::ExecOptsRaw *exec_opts = nullptr,
    rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0),
    const std::vector<int32_t> *all_signal = nullptr) {
  auto prog_data__ = prog_data ? _fbb.CreateVector<uint8_t>(*prog_data) : 0;
  auto all_signal__ = all_signal ? _fbb.CreateVector<int32_t>(*all_signal) : 0;
  return rpc::CreateExecRequestRaw(
      _fbb,
      id,
      avoid,
      prog_data__,
      exec_opts,
      flags,
      all_signal__);
}

flatbuffers::Offset<ExecRequestRaw> CreateExecRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignalUpdateRawT : public flatbuffers::NativeTable {
  typedef SignalUpdateRaw TableType;
  std::vector<uint64_t> new_max{};
};

struct SignalUpdateRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalUpdateRawT NativeTableType;
  typedef SignalUpdateRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_MAX = 4
  };
  const flatbuffers::Vector<uint64_t> *new_max() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_NEW_MAX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_MAX) &&
           verifier.VerifyVector(new_max()) &&
           verifier.EndTable();
  }
  SignalUpdateRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalUpdateRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignalUpdateRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignalUpdateRawBuilder {
  typedef SignalUpdateRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_max(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> new_max) {
    fbb_.AddOffset(SignalUpdateRaw::VT_NEW_MAX, new_max);
  }
  explicit SignalUpdateRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalUpdateRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalUpdateRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalUpdateRaw> CreateSignalUpdateRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> new_max = 0) {
  SignalUpdateRawBuilder builder_(_fbb);
  builder_.add_new_max(new_max);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalUpdateRaw> CreateSignalUpdateRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *new_max = nullptr) {
  auto new_max__ = new_max ? _fbb.CreateVector<uint64_t>(*new_max) : 0;
  return rpc::CreateSignalUpdateRaw(
      _fbb,
      new_max__);
}

flatbuffers::Offset<SignalUpdateRaw> CreateSignalUpdateRaw(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CorpusTriagedRawT : public flatbuffers::NativeTable {
  typedef CorpusTriagedRaw TableType;
};

struct CorpusTriagedRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CorpusTriagedRawT NativeTableType;
  typedef CorpusTriagedRawBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CorpusTriagedRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CorpusTriagedRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CorpusTriagedRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CorpusTriagedRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CorpusTriagedRawBuilder {
  typedef CorpusTriagedRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CorpusTriagedRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CorpusTriagedRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CorpusTriagedRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<CorpusTriagedRaw> CreateCorpusTriagedRaw(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CorpusTriagedRawBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<CorpusTriagedRaw> CreateCorpusTriagedRaw(flatbuffers::FlatBufferBuilder &_fbb, const CorpusTriagedRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateRequestRawT : public flatbuffers::NativeTable {
  typedef StateRequestRaw TableType;
};

struct StateRequestRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateRequestRawT NativeTableType;
  typedef StateRequestRawBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  StateRequestRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StateRequestRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateRequestRawBuilder {
  typedef StateRequestRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StateRequestRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StateRequestRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StateRequestRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<StateRequestRaw> CreateStateRequestRaw(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StateRequestRawBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<StateRequestRaw> CreateStateRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const StateRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecutingMessageRawT : public flatbuffers::NativeTable {
  typedef ExecutingMessageRaw TableType;
  int64_t id = 0;
  int32_t proc_id = 0;
  int32_t try_ = 0;
  int64_t wait_duration = 0;
};

struct ExecutingMessageRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutingMessageRawT NativeTableType;
  typedef ExecutingMessageRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PROC_ID = 6,
    VT_TRY_ = 8,
    VT_WAIT_DURATION = 10
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int32_t proc_id() const {
    return GetField<int32_t>(VT_PROC_ID, 0);
  }
  int32_t try_() const {
    return GetField<int32_t>(VT_TRY_, 0);
  }
  int64_t wait_duration() const {
    return GetField<int64_t>(VT_WAIT_DURATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyField<int32_t>(verifier, VT_PROC_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TRY_, 4) &&
           VerifyField<int64_t>(verifier, VT_WAIT_DURATION, 8) &&
           verifier.EndTable();
  }
  ExecutingMessageRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecutingMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecutingMessageRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecutingMessageRawBuilder {
  typedef ExecutingMessageRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ExecutingMessageRaw::VT_ID, id, 0);
  }
  void add_proc_id(int32_t proc_id) {
    fbb_.AddElement<int32_t>(ExecutingMessageRaw::VT_PROC_ID, proc_id, 0);
  }
  void add_try_(int32_t try_) {
    fbb_.AddElement<int32_t>(ExecutingMessageRaw::VT_TRY_, try_, 0);
  }
  void add_wait_duration(int64_t wait_duration) {
    fbb_.AddElement<int64_t>(ExecutingMessageRaw::VT_WAIT_DURATION, wait_duration, 0);
  }
  explicit ExecutingMessageRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutingMessageRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutingMessageRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutingMessageRaw> CreateExecutingMessageRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int32_t proc_id = 0,
    int32_t try_ = 0,
    int64_t wait_duration = 0) {
  ExecutingMessageRawBuilder builder_(_fbb);
  builder_.add_wait_duration(wait_duration);
  builder_.add_id(id);
  builder_.add_try_(try_);
  builder_.add_proc_id(proc_id);
  return builder_.Finish();
}

flatbuffers::Offset<ExecutingMessageRaw> CreateExecutingMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallInfoRawT : public flatbuffers::NativeTable {
  typedef CallInfoRaw TableType;
  rpc::CallFlag flags = static_cast<rpc::CallFlag>(0);
  int32_t error = 0;
  std::vector<uint64_t> signal{};
  std::vector<uint64_t> cover{};
  std::vector<rpc::ComparisonRaw> comps{};
};

struct CallInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallInfoRawT NativeTableType;
  typedef CallInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_ERROR = 6,
    VT_SIGNAL = 8,
    VT_COVER = 10,
    VT_COMPS = 12
  };
  rpc::CallFlag flags() const {
    return static_cast<rpc::CallFlag>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const flatbuffers::Vector<uint64_t> *signal() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_SIGNAL);
  }
  const flatbuffers::Vector<uint64_t> *cover() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_COVER);
  }
  const flatbuffers::Vector<const rpc::ComparisonRaw *> *comps() const {
    return GetPointer<const flatbuffers::Vector<const rpc::ComparisonRaw *> *>(VT_COMPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyField<int32_t>(verifier, VT_ERROR, 4) &&
           VerifyOffset(verifier, VT_SIGNAL) &&
           verifier.VerifyVector(signal()) &&
           VerifyOffset(verifier, VT_COVER) &&
           verifier.VerifyVector(cover()) &&
           VerifyOffset(verifier, VT_COMPS) &&
           verifier.VerifyVector(comps()) &&
           verifier.EndTable();
  }
  CallInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallInfoRawBuilder {
  typedef CallInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(rpc::CallFlag flags) {
    fbb_.AddElement<uint8_t>(CallInfoRaw::VT_FLAGS, static_cast<uint8_t>(flags), 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(CallInfoRaw::VT_ERROR, error, 0);
  }
  void add_signal(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> signal) {
    fbb_.AddOffset(CallInfoRaw::VT_SIGNAL, signal);
  }
  void add_cover(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cover) {
    fbb_.AddOffset(CallInfoRaw::VT_COVER, cover);
  }
  void add_comps(flatbuffers::Offset<flatbuffers::Vector<const rpc::ComparisonRaw *>> comps) {
    fbb_.AddOffset(CallInfoRaw::VT_COMPS, comps);
  }
  explicit CallInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CallInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallInfoRaw> CreateCallInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::CallFlag flags = static_cast<rpc::CallFlag>(0),
    int32_t error = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> signal = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> cover = 0,
    flatbuffers::Offset<flatbuffers::Vector<const rpc::ComparisonRaw *>> comps = 0) {
  CallInfoRawBuilder builder_(_fbb);
  builder_.add_comps(comps);
  builder_.add_cover(cover);
  builder_.add_signal(signal);
  builder_.add_error(error);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<CallInfoRaw> CreateCallInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::CallFlag flags = static_cast<rpc::CallFlag>(0),
    int32_t error = 0,
    const std::vector<uint64_t> *signal = nullptr,
    const std::vector<uint64_t> *cover = nullptr,
    const std::vector<rpc::ComparisonRaw> *comps = nullptr) {
  auto signal__ = signal ? _fbb.CreateVector<uint64_t>(*signal) : 0;
  auto cover__ = cover ? _fbb.CreateVector<uint64_t>(*cover) : 0;
  auto comps__ = comps ? _fbb.CreateVectorOfStructs<rpc::ComparisonRaw>(*comps) : 0;
  return rpc::CreateCallInfoRaw(
      _fbb,
      flags,
      error,
      signal__,
      cover__,
      comps__);
}

flatbuffers::Offset<CallInfoRaw> CreateCallInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProgInfoRawT : public flatbuffers::NativeTable {
  typedef ProgInfoRaw TableType;
  std::vector<std::unique_ptr<rpc::CallInfoRawT>> calls{};
  std::vector<std::unique_ptr<rpc::CallInfoRawT>> extra_raw{};
  std::unique_ptr<rpc::CallInfoRawT> extra{};
  uint64_t elapsed = 0;
  uint64_t freshness = 0;
  ProgInfoRawT() = default;
  ProgInfoRawT(const ProgInfoRawT &o);
  ProgInfoRawT(ProgInfoRawT&&) FLATBUFFERS_NOEXCEPT = default;
  ProgInfoRawT &operator=(ProgInfoRawT o) FLATBUFFERS_NOEXCEPT;
};

struct ProgInfoRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgInfoRawT NativeTableType;
  typedef ProgInfoRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALLS = 4,
    VT_EXTRA_RAW = 6,
    VT_EXTRA = 8,
    VT_ELAPSED = 10,
    VT_FRESHNESS = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>> *calls() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>> *>(VT_CALLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>> *extra_raw() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>> *>(VT_EXTRA_RAW);
  }
  const rpc::CallInfoRaw *extra() const {
    return GetPointer<const rpc::CallInfoRaw *>(VT_EXTRA);
  }
  uint64_t elapsed() const {
    return GetField<uint64_t>(VT_ELAPSED, 0);
  }
  uint64_t freshness() const {
    return GetField<uint64_t>(VT_FRESHNESS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALLS) &&
           verifier.VerifyVector(calls()) &&
           verifier.VerifyVectorOfTables(calls()) &&
           VerifyOffset(verifier, VT_EXTRA_RAW) &&
           verifier.VerifyVector(extra_raw()) &&
           verifier.VerifyVectorOfTables(extra_raw()) &&
           VerifyOffset(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           VerifyField<uint64_t>(verifier, VT_ELAPSED, 8) &&
           VerifyField<uint64_t>(verifier, VT_FRESHNESS, 8) &&
           verifier.EndTable();
  }
  ProgInfoRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProgInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProgInfoRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProgInfoRawBuilder {
  typedef ProgInfoRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_calls(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>>> calls) {
    fbb_.AddOffset(ProgInfoRaw::VT_CALLS, calls);
  }
  void add_extra_raw(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>>> extra_raw) {
    fbb_.AddOffset(ProgInfoRaw::VT_EXTRA_RAW, extra_raw);
  }
  void add_extra(flatbuffers::Offset<rpc::CallInfoRaw> extra) {
    fbb_.AddOffset(ProgInfoRaw::VT_EXTRA, extra);
  }
  void add_elapsed(uint64_t elapsed) {
    fbb_.AddElement<uint64_t>(ProgInfoRaw::VT_ELAPSED, elapsed, 0);
  }
  void add_freshness(uint64_t freshness) {
    fbb_.AddElement<uint64_t>(ProgInfoRaw::VT_FRESHNESS, freshness, 0);
  }
  explicit ProgInfoRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProgInfoRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgInfoRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgInfoRaw> CreateProgInfoRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>>> calls = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfoRaw>>> extra_raw = 0,
    flatbuffers::Offset<rpc::CallInfoRaw> extra = 0,
    uint64_t elapsed = 0,
    uint64_t freshness = 0) {
  ProgInfoRawBuilder builder_(_fbb);
  builder_.add_freshness(freshness);
  builder_.add_elapsed(elapsed);
  builder_.add_extra(extra);
  builder_.add_extra_raw(extra_raw);
  builder_.add_calls(calls);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgInfoRaw> CreateProgInfoRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<rpc::CallInfoRaw>> *calls = nullptr,
    const std::vector<flatbuffers::Offset<rpc::CallInfoRaw>> *extra_raw = nullptr,
    flatbuffers::Offset<rpc::CallInfoRaw> extra = 0,
    uint64_t elapsed = 0,
    uint64_t freshness = 0) {
  auto calls__ = calls ? _fbb.CreateVector<flatbuffers::Offset<rpc::CallInfoRaw>>(*calls) : 0;
  auto extra_raw__ = extra_raw ? _fbb.CreateVector<flatbuffers::Offset<rpc::CallInfoRaw>>(*extra_raw) : 0;
  return rpc::CreateProgInfoRaw(
      _fbb,
      calls__,
      extra_raw__,
      extra,
      elapsed,
      freshness);
}

flatbuffers::Offset<ProgInfoRaw> CreateProgInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecResultRawT : public flatbuffers::NativeTable {
  typedef ExecResultRaw TableType;
  int64_t id = 0;
  int32_t proc = 0;
  std::vector<uint8_t> output{};
  bool hanged = false;
  std::string error{};
  std::unique_ptr<rpc::ProgInfoRawT> info{};
  ExecResultRawT() = default;
  ExecResultRawT(const ExecResultRawT &o);
  ExecResultRawT(ExecResultRawT&&) FLATBUFFERS_NOEXCEPT = default;
  ExecResultRawT &operator=(ExecResultRawT o) FLATBUFFERS_NOEXCEPT;
};

struct ExecResultRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecResultRawT NativeTableType;
  typedef ExecResultRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PROC = 6,
    VT_OUTPUT = 8,
    VT_HANGED = 10,
    VT_ERROR = 12,
    VT_INFO = 14
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int32_t proc() const {
    return GetField<int32_t>(VT_PROC, 0);
  }
  const flatbuffers::Vector<uint8_t> *output() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTPUT);
  }
  bool hanged() const {
    return GetField<uint8_t>(VT_HANGED, 0) != 0;
  }
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const rpc::ProgInfoRaw *info() const {
    return GetPointer<const rpc::ProgInfoRaw *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyField<int32_t>(verifier, VT_PROC, 4) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           VerifyField<uint8_t>(verifier, VT_HANGED, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
  ExecResultRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecResultRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecResultRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecResultRawBuilder {
  typedef ExecResultRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ExecResultRaw::VT_ID, id, 0);
  }
  void add_proc(int32_t proc) {
    fbb_.AddElement<int32_t>(ExecResultRaw::VT_PROC, proc, 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output) {
    fbb_.AddOffset(ExecResultRaw::VT_OUTPUT, output);
  }
  void add_hanged(bool hanged) {
    fbb_.AddElement<uint8_t>(ExecResultRaw::VT_HANGED, static_cast<uint8_t>(hanged), 0);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(ExecResultRaw::VT_ERROR, error);
  }
  void add_info(flatbuffers::Offset<rpc::ProgInfoRaw> info) {
    fbb_.AddOffset(ExecResultRaw::VT_INFO, info);
  }
  explicit ExecResultRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecResultRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecResultRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecResultRaw> CreateExecResultRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int32_t proc = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output = 0,
    bool hanged = false,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<rpc::ProgInfoRaw> info = 0) {
  ExecResultRawBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_info(info);
  builder_.add_error(error);
  builder_.add_output(output);
  builder_.add_proc(proc);
  builder_.add_hanged(hanged);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecResultRaw> CreateExecResultRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int32_t proc = 0,
    const std::vector<uint8_t> *output = nullptr,
    bool hanged = false,
    const char *error = nullptr,
    flatbuffers::Offset<rpc::ProgInfoRaw> info = 0) {
  auto output__ = output ? _fbb.CreateVector<uint8_t>(*output) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return rpc::CreateExecResultRaw(
      _fbb,
      id,
      proc,
      output__,
      hanged,
      error__,
      info);
}

flatbuffers::Offset<ExecResultRaw> CreateExecResultRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateResultRawT : public flatbuffers::NativeTable {
  typedef StateResultRaw TableType;
  std::vector<uint8_t> data{};
};

struct StateResultRaw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateResultRawT NativeTableType;
  typedef StateResultRawBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  StateResultRawT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateResultRawT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StateResultRaw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateResultRawT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateResultRawBuilder {
  typedef StateResultRaw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(StateResultRaw::VT_DATA, data);
  }
  explicit StateResultRawBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StateResultRaw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StateResultRaw>(end);
    return o;
  }
};

inline flatbuffers::Offset<StateResultRaw> CreateStateResultRaw(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  StateResultRawBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<StateResultRaw> CreateStateResultRawDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return rpc::CreateStateResultRaw(
      _fbb,
      data__);
}

flatbuffers::Offset<StateResultRaw> CreateStateResultRaw(flatbuffers::FlatBufferBuilder &_fbb, const StateResultRawT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SnapshotHeaderT : public flatbuffers::NativeTable {
  typedef SnapshotHeader TableType;
  rpc::SnapshotState state = rpc::SnapshotState::Initial;
  uint32_t output_offset = 0;
  uint32_t output_size = 0;
};

struct SnapshotHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SnapshotHeaderT NativeTableType;
  typedef SnapshotHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_OUTPUT_OFFSET = 6,
    VT_OUTPUT_SIZE = 8
  };
  rpc::SnapshotState state() const {
    return static_cast<rpc::SnapshotState>(GetField<uint64_t>(VT_STATE, 0));
  }
  uint32_t output_offset() const {
    return GetField<uint32_t>(VT_OUTPUT_OFFSET, 0);
  }
  uint32_t output_size() const {
    return GetField<uint32_t>(VT_OUTPUT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_STATE, 8) &&
           VerifyField<uint32_t>(verifier, VT_OUTPUT_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_OUTPUT_SIZE, 4) &&
           verifier.EndTable();
  }
  SnapshotHeaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SnapshotHeaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SnapshotHeader> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotHeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SnapshotHeaderBuilder {
  typedef SnapshotHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(rpc::SnapshotState state) {
    fbb_.AddElement<uint64_t>(SnapshotHeader::VT_STATE, static_cast<uint64_t>(state), 0);
  }
  void add_output_offset(uint32_t output_offset) {
    fbb_.AddElement<uint32_t>(SnapshotHeader::VT_OUTPUT_OFFSET, output_offset, 0);
  }
  void add_output_size(uint32_t output_size) {
    fbb_.AddElement<uint32_t>(SnapshotHeader::VT_OUTPUT_SIZE, output_size, 0);
  }
  explicit SnapshotHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SnapshotHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SnapshotHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<SnapshotHeader> CreateSnapshotHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::SnapshotState state = rpc::SnapshotState::Initial,
    uint32_t output_offset = 0,
    uint32_t output_size = 0) {
  SnapshotHeaderBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_output_size(output_size);
  builder_.add_output_offset(output_offset);
  return builder_.Finish();
}

flatbuffers::Offset<SnapshotHeader> CreateSnapshotHeader(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotHeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SnapshotHandshakeT : public flatbuffers::NativeTable {
  typedef SnapshotHandshake TableType;
  bool cover_edges = false;
  bool kernel_64_bit = false;
  int32_t slowdown = 0;
  int32_t syscall_timeout_ms = 0;
  int32_t program_timeout_ms = 0;
  rpc::Feature features = static_cast<rpc::Feature>(0);
  rpc::ExecEnv env_flags = static_cast<rpc::ExecEnv>(0);
  int64_t sandbox_arg = 0;
};

struct SnapshotHandshake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SnapshotHandshakeT NativeTableType;
  typedef SnapshotHandshakeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COVER_EDGES = 4,
    VT_KERNEL_64_BIT = 6,
    VT_SLOWDOWN = 8,
    VT_SYSCALL_TIMEOUT_MS = 10,
    VT_PROGRAM_TIMEOUT_MS = 12,
    VT_FEATURES = 14,
    VT_ENV_FLAGS = 16,
    VT_SANDBOX_ARG = 18
  };
  bool cover_edges() const {
    return GetField<uint8_t>(VT_COVER_EDGES, 0) != 0;
  }
  bool kernel_64_bit() const {
    return GetField<uint8_t>(VT_KERNEL_64_BIT, 0) != 0;
  }
  int32_t slowdown() const {
    return GetField<int32_t>(VT_SLOWDOWN, 0);
  }
  int32_t syscall_timeout_ms() const {
    return GetField<int32_t>(VT_SYSCALL_TIMEOUT_MS, 0);
  }
  int32_t program_timeout_ms() const {
    return GetField<int32_t>(VT_PROGRAM_TIMEOUT_MS, 0);
  }
  rpc::Feature features() const {
    return static_cast<rpc::Feature>(GetField<uint64_t>(VT_FEATURES, 0));
  }
  rpc::ExecEnv env_flags() const {
    return static_cast<rpc::ExecEnv>(GetField<uint64_t>(VT_ENV_FLAGS, 0));
  }
  int64_t sandbox_arg() const {
    return GetField<int64_t>(VT_SANDBOX_ARG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COVER_EDGES, 1) &&
           VerifyField<uint8_t>(verifier, VT_KERNEL_64_BIT, 1) &&
           VerifyField<int32_t>(verifier, VT_SLOWDOWN, 4) &&
           VerifyField<int32_t>(verifier, VT_SYSCALL_TIMEOUT_MS, 4) &&
           VerifyField<int32_t>(verifier, VT_PROGRAM_TIMEOUT_MS, 4) &&
           VerifyField<uint64_t>(verifier, VT_FEATURES, 8) &&
           VerifyField<uint64_t>(verifier, VT_ENV_FLAGS, 8) &&
           VerifyField<int64_t>(verifier, VT_SANDBOX_ARG, 8) &&
           verifier.EndTable();
  }
  SnapshotHandshakeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SnapshotHandshakeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SnapshotHandshake> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotHandshakeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SnapshotHandshakeBuilder {
  typedef SnapshotHandshake Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cover_edges(bool cover_edges) {
    fbb_.AddElement<uint8_t>(SnapshotHandshake::VT_COVER_EDGES, static_cast<uint8_t>(cover_edges), 0);
  }
  void add_kernel_64_bit(bool kernel_64_bit) {
    fbb_.AddElement<uint8_t>(SnapshotHandshake::VT_KERNEL_64_BIT, static_cast<uint8_t>(kernel_64_bit), 0);
  }
  void add_slowdown(int32_t slowdown) {
    fbb_.AddElement<int32_t>(SnapshotHandshake::VT_SLOWDOWN, slowdown, 0);
  }
  void add_syscall_timeout_ms(int32_t syscall_timeout_ms) {
    fbb_.AddElement<int32_t>(SnapshotHandshake::VT_SYSCALL_TIMEOUT_MS, syscall_timeout_ms, 0);
  }
  void add_program_timeout_ms(int32_t program_timeout_ms) {
    fbb_.AddElement<int32_t>(SnapshotHandshake::VT_PROGRAM_TIMEOUT_MS, program_timeout_ms, 0);
  }
  void add_features(rpc::Feature features) {
    fbb_.AddElement<uint64_t>(SnapshotHandshake::VT_FEATURES, static_cast<uint64_t>(features), 0);
  }
  void add_env_flags(rpc::ExecEnv env_flags) {
    fbb_.AddElement<uint64_t>(SnapshotHandshake::VT_ENV_FLAGS, static_cast<uint64_t>(env_flags), 0);
  }
  void add_sandbox_arg(int64_t sandbox_arg) {
    fbb_.AddElement<int64_t>(SnapshotHandshake::VT_SANDBOX_ARG, sandbox_arg, 0);
  }
  explicit SnapshotHandshakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SnapshotHandshake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SnapshotHandshake>(end);
    return o;
  }
};

inline flatbuffers::Offset<SnapshotHandshake> CreateSnapshotHandshake(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool cover_edges = false,
    bool kernel_64_bit = false,
    int32_t slowdown = 0,
    int32_t syscall_timeout_ms = 0,
    int32_t program_timeout_ms = 0,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    rpc::ExecEnv env_flags = static_cast<rpc::ExecEnv>(0),
    int64_t sandbox_arg = 0) {
  SnapshotHandshakeBuilder builder_(_fbb);
  builder_.add_sandbox_arg(sandbox_arg);
  builder_.add_env_flags(env_flags);
  builder_.add_features(features);
  builder_.add_program_timeout_ms(program_timeout_ms);
  builder_.add_syscall_timeout_ms(syscall_timeout_ms);
  builder_.add_slowdown(slowdown);
  builder_.add_kernel_64_bit(kernel_64_bit);
  builder_.add_cover_edges(cover_edges);
  return builder_.Finish();
}

flatbuffers::Offset<SnapshotHandshake> CreateSnapshotHandshake(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotHandshakeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SnapshotRequestT : public flatbuffers::NativeTable {
  typedef SnapshotRequest TableType;
  rpc::ExecFlag exec_flags = static_cast<rpc::ExecFlag>(0);
  int32_t num_calls = 0;
  uint64_t all_call_signal = 0;
  bool all_extra_signal = false;
  std::vector<uint8_t> prog_data{};
};

struct SnapshotRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SnapshotRequestT NativeTableType;
  typedef SnapshotRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXEC_FLAGS = 4,
    VT_NUM_CALLS = 6,
    VT_ALL_CALL_SIGNAL = 8,
    VT_ALL_EXTRA_SIGNAL = 10,
    VT_PROG_DATA = 12
  };
  rpc::ExecFlag exec_flags() const {
    return static_cast<rpc::ExecFlag>(GetField<uint64_t>(VT_EXEC_FLAGS, 0));
  }
  int32_t num_calls() const {
    return GetField<int32_t>(VT_NUM_CALLS, 0);
  }
  uint64_t all_call_signal() const {
    return GetField<uint64_t>(VT_ALL_CALL_SIGNAL, 0);
  }
  bool all_extra_signal() const {
    return GetField<uint8_t>(VT_ALL_EXTRA_SIGNAL, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *prog_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PROG_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_EXEC_FLAGS, 8) &&
           VerifyField<int32_t>(verifier, VT_NUM_CALLS, 4) &&
           VerifyField<uint64_t>(verifier, VT_ALL_CALL_SIGNAL, 8) &&
           VerifyField<uint8_t>(verifier, VT_ALL_EXTRA_SIGNAL, 1) &&
           VerifyOffset(verifier, VT_PROG_DATA) &&
           verifier.VerifyVector(prog_data()) &&
           verifier.EndTable();
  }
  SnapshotRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SnapshotRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SnapshotRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SnapshotRequestBuilder {
  typedef SnapshotRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exec_flags(rpc::ExecFlag exec_flags) {
    fbb_.AddElement<uint64_t>(SnapshotRequest::VT_EXEC_FLAGS, static_cast<uint64_t>(exec_flags), 0);
  }
  void add_num_calls(int32_t num_calls) {
    fbb_.AddElement<int32_t>(SnapshotRequest::VT_NUM_CALLS, num_calls, 0);
  }
  void add_all_call_signal(uint64_t all_call_signal) {
    fbb_.AddElement<uint64_t>(SnapshotRequest::VT_ALL_CALL_SIGNAL, all_call_signal, 0);
  }
  void add_all_extra_signal(bool all_extra_signal) {
    fbb_.AddElement<uint8_t>(SnapshotRequest::VT_ALL_EXTRA_SIGNAL, static_cast<uint8_t>(all_extra_signal), 0);
  }
  void add_prog_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prog_data) {
    fbb_.AddOffset(SnapshotRequest::VT_PROG_DATA, prog_data);
  }
  explicit SnapshotRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SnapshotRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SnapshotRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SnapshotRequest> CreateSnapshotRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::ExecFlag exec_flags = static_cast<rpc::ExecFlag>(0),
    int32_t num_calls = 0,
    uint64_t all_call_signal = 0,
    bool all_extra_signal = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prog_data = 0) {
  SnapshotRequestBuilder builder_(_fbb);
  builder_.add_all_call_signal(all_call_signal);
  builder_.add_exec_flags(exec_flags);
  builder_.add_prog_data(prog_data);
  builder_.add_num_calls(num_calls);
  builder_.add_all_extra_signal(all_extra_signal);
  return builder_.Finish();
}

inline flatbuffers::Offset<SnapshotRequest> CreateSnapshotRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::ExecFlag exec_flags = static_cast<rpc::ExecFlag>(0),
    int32_t num_calls = 0,
    uint64_t all_call_signal = 0,
    bool all_extra_signal = false,
    const std::vector<uint8_t> *prog_data = nullptr) {
  auto prog_data__ = prog_data ? _fbb.CreateVector<uint8_t>(*prog_data) : 0;
  return rpc::CreateSnapshotRequest(
      _fbb,
      exec_flags,
      num_calls,
      all_call_signal,
      all_extra_signal,
      prog_data__);
}

flatbuffers::Offset<SnapshotRequest> CreateSnapshotRequest(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ConnectRequestRawT *ConnectRequestRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConnectRequestRawT>(new ConnectRequestRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConnectRequestRaw::UnPackTo(ConnectRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = arch(); if (_e) _o->arch = _e->str(); }
  { auto _e = git_revision(); if (_e) _o->git_revision = _e->str(); }
  { auto _e = syz_revision(); if (_e) _o->syz_revision = _e->str(); }
}

inline flatbuffers::Offset<ConnectRequestRaw> ConnectRequestRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConnectRequestRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConnectRequestRaw> CreateConnectRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConnectRequestRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _arch = _o->arch.empty() ? 0 : _fbb.CreateString(_o->arch);
  auto _git_revision = _o->git_revision.empty() ? 0 : _fbb.CreateString(_o->git_revision);
  auto _syz_revision = _o->syz_revision.empty() ? 0 : _fbb.CreateString(_o->syz_revision);
  return rpc::CreateConnectRequestRaw(
      _fbb,
      _id,
      _arch,
      _git_revision,
      _syz_revision);
}

inline ConnectReplyRawT *ConnectReplyRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConnectReplyRawT>(new ConnectReplyRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConnectReplyRaw::UnPackTo(ConnectReplyRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = debug(); _o->debug = _e; }
  { auto _e = cover(); _o->cover = _e; }
  { auto _e = cover_edges(); _o->cover_edges = _e; }
  { auto _e = kernel_64_bit(); _o->kernel_64_bit = _e; }
  { auto _e = procs(); _o->procs = _e; }
  { auto _e = slowdown(); _o->slowdown = _e; }
  { auto _e = syscall_timeout_ms(); _o->syscall_timeout_ms = _e; }
  { auto _e = program_timeout_ms(); _o->program_timeout_ms = _e; }
  { auto _e = leak_frames(); if (_e) { _o->leak_frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->leak_frames[_i] = _e->Get(_i)->str(); } } }
  { auto _e = race_frames(); if (_e) { _o->race_frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->race_frames[_i] = _e->Get(_i)->str(); } } }
  { auto _e = features(); _o->features = _e; }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = _e->Get(_i)->str(); } } }
  { auto _e = globs(); if (_e) { _o->globs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->globs[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<ConnectReplyRaw> ConnectReplyRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConnectReplyRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConnectReplyRaw> CreateConnectReplyRaw(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConnectReplyRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _debug = _o->debug;
  auto _cover = _o->cover;
  auto _cover_edges = _o->cover_edges;
  auto _kernel_64_bit = _o->kernel_64_bit;
  auto _procs = _o->procs;
  auto _slowdown = _o->slowdown;
  auto _syscall_timeout_ms = _o->syscall_timeout_ms;
  auto _program_timeout_ms = _o->program_timeout_ms;
  auto _leak_frames = _o->leak_frames.size() ? _fbb.CreateVectorOfStrings(_o->leak_frames) : 0;
  auto _race_frames = _o->race_frames.size() ? _fbb.CreateVectorOfStrings(_o->race_frames) : 0;
  auto _features = _o->features;
  auto _files = _o->files.size() ? _fbb.CreateVectorOfStrings(_o->files) : 0;
  auto _globs = _o->globs.size() ? _fbb.CreateVectorOfStrings(_o->globs) : 0;
  return rpc::CreateConnectReplyRaw(
      _fbb,
      _debug,
      _cover,
      _cover_edges,
      _kernel_64_bit,
      _procs,
      _slowdown,
      _syscall_timeout_ms,
      _program_timeout_ms,
      _leak_frames,
      _race_frames,
      _features,
      _files,
      _globs);
}

inline InfoRequestRawT::InfoRequestRawT(const InfoRequestRawT &o)
      : error(o.error) {
  features.reserve(o.features.size());
  for (const auto &features_ : o.features) { features.emplace_back((features_) ? new rpc::FeatureInfoRawT(*features_) : nullptr); }
  files.reserve(o.files.size());
  for (const auto &files_ : o.files) { files.emplace_back((files_) ? new rpc::FileInfoRawT(*files_) : nullptr); }
  globs.reserve(o.globs.size());
  for (const auto &globs_ : o.globs) { globs.emplace_back((globs_) ? new rpc::GlobInfoRawT(*globs_) : nullptr); }
}

inline InfoRequestRawT &InfoRequestRawT::operator=(InfoRequestRawT o) FLATBUFFERS_NOEXCEPT {
  std::swap(error, o.error);
  std::swap(features, o.features);
  std::swap(files, o.files);
  std::swap(globs, o.globs);
  return *this;
}

inline InfoRequestRawT *InfoRequestRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InfoRequestRawT>(new InfoRequestRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InfoRequestRaw::UnPackTo(InfoRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = features(); if (_e) { _o->features.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->features[_i] = std::unique_ptr<rpc::FeatureInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = std::unique_ptr<rpc::FileInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = globs(); if (_e) { _o->globs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->globs[_i] = std::unique_ptr<rpc::GlobInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<InfoRequestRaw> InfoRequestRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInfoRequestRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InfoRequestRaw> CreateInfoRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InfoRequestRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _features = _o->features.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::FeatureInfoRaw>> (_o->features.size(), [](size_t i, _VectorArgs *__va) { return CreateFeatureInfoRaw(*__va->__fbb, __va->__o->features[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _files = _o->files.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::FileInfoRaw>> (_o->files.size(), [](size_t i, _VectorArgs *__va) { return CreateFileInfoRaw(*__va->__fbb, __va->__o->files[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _globs = _o->globs.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::GlobInfoRaw>> (_o->globs.size(), [](size_t i, _VectorArgs *__va) { return CreateGlobInfoRaw(*__va->__fbb, __va->__o->globs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return rpc::CreateInfoRequestRaw(
      _fbb,
      _error,
      _features,
      _files,
      _globs);
}

inline InfoReplyRawT *InfoReplyRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InfoReplyRawT>(new InfoReplyRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InfoReplyRaw::UnPackTo(InfoReplyRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cover_filter(); if (_e) { _o->cover_filter.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cover_filter[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<InfoReplyRaw> InfoReplyRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInfoReplyRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InfoReplyRaw> CreateInfoReplyRaw(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InfoReplyRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cover_filter = _o->cover_filter.size() ? _fbb.CreateVector(_o->cover_filter) : 0;
  return rpc::CreateInfoReplyRaw(
      _fbb,
      _cover_filter);
}

inline FileInfoRawT *FileInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileInfoRawT>(new FileInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileInfoRaw::UnPackTo(FileInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = exists(); _o->exists = _e; }
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline flatbuffers::Offset<FileInfoRaw> FileInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FileInfoRaw> CreateFileInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FileInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _exists = _o->exists;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return rpc::CreateFileInfoRaw(
      _fbb,
      _name,
      _exists,
      _error,
      _data);
}

inline GlobInfoRawT *GlobInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GlobInfoRawT>(new GlobInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GlobInfoRaw::UnPackTo(GlobInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<GlobInfoRaw> GlobInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGlobInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GlobInfoRaw> CreateGlobInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GlobInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _files = _o->files.size() ? _fbb.CreateVectorOfStrings(_o->files) : 0;
  return rpc::CreateGlobInfoRaw(
      _fbb,
      _name,
      _files);
}

inline FeatureInfoRawT *FeatureInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FeatureInfoRawT>(new FeatureInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FeatureInfoRaw::UnPackTo(FeatureInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = need_setup(); _o->need_setup = _e; }
  { auto _e = reason(); if (_e) _o->reason = _e->str(); }
}

inline flatbuffers::Offset<FeatureInfoRaw> FeatureInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FeatureInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFeatureInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FeatureInfoRaw> CreateFeatureInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const FeatureInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FeatureInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _need_setup = _o->need_setup;
  auto _reason = _o->reason.empty() ? 0 : _fbb.CreateString(_o->reason);
  return rpc::CreateFeatureInfoRaw(
      _fbb,
      _id,
      _need_setup,
      _reason);
}

inline HostMessageRawT *HostMessageRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HostMessageRawT>(new HostMessageRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostMessageRaw::UnPackTo(HostMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg_type(); _o->msg.type = _e; }
  { auto _e = msg(); if (_e) _o->msg.value = rpc::HostMessagesRawUnion::UnPack(_e, msg_type(), _resolver); }
}

inline flatbuffers::Offset<HostMessageRaw> HostMessageRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostMessageRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostMessageRaw> CreateHostMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostMessageRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return rpc::CreateHostMessageRaw(
      _fbb,
      _msg_type,
      _msg);
}

inline ExecutorMessageRawT *ExecutorMessageRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecutorMessageRawT>(new ExecutorMessageRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecutorMessageRaw::UnPackTo(ExecutorMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg_type(); _o->msg.type = _e; }
  { auto _e = msg(); if (_e) _o->msg.value = rpc::ExecutorMessagesRawUnion::UnPack(_e, msg_type(), _resolver); }
}

inline flatbuffers::Offset<ExecutorMessageRaw> ExecutorMessageRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecutorMessageRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecutorMessageRaw> CreateExecutorMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecutorMessageRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return rpc::CreateExecutorMessageRaw(
      _fbb,
      _msg_type,
      _msg);
}

inline ExecRequestRawT::ExecRequestRawT(const ExecRequestRawT &o)
      : id(o.id),
        avoid(o.avoid),
        prog_data(o.prog_data),
        exec_opts((o.exec_opts) ? new rpc::ExecOptsRaw(*o.exec_opts) : nullptr),
        flags(o.flags),
        all_signal(o.all_signal) {
}

inline ExecRequestRawT &ExecRequestRawT::operator=(ExecRequestRawT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(avoid, o.avoid);
  std::swap(prog_data, o.prog_data);
  std::swap(exec_opts, o.exec_opts);
  std::swap(flags, o.flags);
  std::swap(all_signal, o.all_signal);
  return *this;
}

inline ExecRequestRawT *ExecRequestRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecRequestRawT>(new ExecRequestRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecRequestRaw::UnPackTo(ExecRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = avoid(); _o->avoid = _e; }
  { auto _e = prog_data(); if (_e) { _o->prog_data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->prog_data.begin()); } }
  { auto _e = exec_opts(); if (_e) _o->exec_opts = std::unique_ptr<rpc::ExecOptsRaw>(new rpc::ExecOptsRaw(*_e)); }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = all_signal(); if (_e) { _o->all_signal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->all_signal[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ExecRequestRaw> ExecRequestRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecRequestRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecRequestRaw> CreateExecRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecRequestRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _avoid = _o->avoid;
  auto _prog_data = _o->prog_data.size() ? _fbb.CreateVector(_o->prog_data) : 0;
  auto _exec_opts = _o->exec_opts ? _o->exec_opts.get() : nullptr;
  auto _flags = _o->flags;
  auto _all_signal = _o->all_signal.size() ? _fbb.CreateVector(_o->all_signal) : 0;
  return rpc::CreateExecRequestRaw(
      _fbb,
      _id,
      _avoid,
      _prog_data,
      _exec_opts,
      _flags,
      _all_signal);
}

inline SignalUpdateRawT *SignalUpdateRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignalUpdateRawT>(new SignalUpdateRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignalUpdateRaw::UnPackTo(SignalUpdateRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = new_max(); if (_e) { _o->new_max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_max[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SignalUpdateRaw> SignalUpdateRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignalUpdateRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignalUpdateRaw> CreateSignalUpdateRaw(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignalUpdateRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _new_max = _o->new_max.size() ? _fbb.CreateVector(_o->new_max) : 0;
  return rpc::CreateSignalUpdateRaw(
      _fbb,
      _new_max);
}

inline CorpusTriagedRawT *CorpusTriagedRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CorpusTriagedRawT>(new CorpusTriagedRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CorpusTriagedRaw::UnPackTo(CorpusTriagedRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<CorpusTriagedRaw> CorpusTriagedRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CorpusTriagedRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCorpusTriagedRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CorpusTriagedRaw> CreateCorpusTriagedRaw(flatbuffers::FlatBufferBuilder &_fbb, const CorpusTriagedRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CorpusTriagedRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return rpc::CreateCorpusTriagedRaw(
      _fbb);
}

inline StateRequestRawT *StateRequestRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StateRequestRawT>(new StateRequestRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StateRequestRaw::UnPackTo(StateRequestRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<StateRequestRaw> StateRequestRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateRequestRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStateRequestRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StateRequestRaw> CreateStateRequestRaw(flatbuffers::FlatBufferBuilder &_fbb, const StateRequestRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StateRequestRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return rpc::CreateStateRequestRaw(
      _fbb);
}

inline ExecutingMessageRawT *ExecutingMessageRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecutingMessageRawT>(new ExecutingMessageRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecutingMessageRaw::UnPackTo(ExecutingMessageRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = proc_id(); _o->proc_id = _e; }
  { auto _e = try_(); _o->try_ = _e; }
  { auto _e = wait_duration(); _o->wait_duration = _e; }
}

inline flatbuffers::Offset<ExecutingMessageRaw> ExecutingMessageRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecutingMessageRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecutingMessageRaw> CreateExecutingMessageRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecutingMessageRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _proc_id = _o->proc_id;
  auto _try_ = _o->try_;
  auto _wait_duration = _o->wait_duration;
  return rpc::CreateExecutingMessageRaw(
      _fbb,
      _id,
      _proc_id,
      _try_,
      _wait_duration);
}

inline CallInfoRawT *CallInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CallInfoRawT>(new CallInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallInfoRaw::UnPackTo(CallInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = error(); _o->error = _e; }
  { auto _e = signal(); if (_e) { _o->signal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->signal[_i] = _e->Get(_i); } } }
  { auto _e = cover(); if (_e) { _o->cover.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cover[_i] = _e->Get(_i); } } }
  { auto _e = comps(); if (_e) { _o->comps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->comps[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<CallInfoRaw> CallInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallInfoRaw> CreateCallInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  auto _error = _o->error;
  auto _signal = _o->signal.size() ? _fbb.CreateVector(_o->signal) : 0;
  auto _cover = _o->cover.size() ? _fbb.CreateVector(_o->cover) : 0;
  auto _comps = _o->comps.size() ? _fbb.CreateVectorOfStructs(_o->comps) : 0;
  return rpc::CreateCallInfoRaw(
      _fbb,
      _flags,
      _error,
      _signal,
      _cover,
      _comps);
}

inline ProgInfoRawT::ProgInfoRawT(const ProgInfoRawT &o)
      : extra((o.extra) ? new rpc::CallInfoRawT(*o.extra) : nullptr),
        elapsed(o.elapsed),
        freshness(o.freshness) {
  calls.reserve(o.calls.size());
  for (const auto &calls_ : o.calls) { calls.emplace_back((calls_) ? new rpc::CallInfoRawT(*calls_) : nullptr); }
  extra_raw.reserve(o.extra_raw.size());
  for (const auto &extra_raw_ : o.extra_raw) { extra_raw.emplace_back((extra_raw_) ? new rpc::CallInfoRawT(*extra_raw_) : nullptr); }
}

inline ProgInfoRawT &ProgInfoRawT::operator=(ProgInfoRawT o) FLATBUFFERS_NOEXCEPT {
  std::swap(calls, o.calls);
  std::swap(extra_raw, o.extra_raw);
  std::swap(extra, o.extra);
  std::swap(elapsed, o.elapsed);
  std::swap(freshness, o.freshness);
  return *this;
}

inline ProgInfoRawT *ProgInfoRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProgInfoRawT>(new ProgInfoRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProgInfoRaw::UnPackTo(ProgInfoRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = calls(); if (_e) { _o->calls.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->calls[_i] = std::unique_ptr<rpc::CallInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = extra_raw(); if (_e) { _o->extra_raw.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extra_raw[_i] = std::unique_ptr<rpc::CallInfoRawT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = extra(); if (_e) _o->extra = std::unique_ptr<rpc::CallInfoRawT>(_e->UnPack(_resolver)); }
  { auto _e = elapsed(); _o->elapsed = _e; }
  { auto _e = freshness(); _o->freshness = _e; }
}

inline flatbuffers::Offset<ProgInfoRaw> ProgInfoRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProgInfoRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProgInfoRaw> CreateProgInfoRaw(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProgInfoRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _calls = _o->calls.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::CallInfoRaw>> (_o->calls.size(), [](size_t i, _VectorArgs *__va) { return CreateCallInfoRaw(*__va->__fbb, __va->__o->calls[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extra_raw = _o->extra_raw.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::CallInfoRaw>> (_o->extra_raw.size(), [](size_t i, _VectorArgs *__va) { return CreateCallInfoRaw(*__va->__fbb, __va->__o->extra_raw[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extra = _o->extra ? CreateCallInfoRaw(_fbb, _o->extra.get(), _rehasher) : 0;
  auto _elapsed = _o->elapsed;
  auto _freshness = _o->freshness;
  return rpc::CreateProgInfoRaw(
      _fbb,
      _calls,
      _extra_raw,
      _extra,
      _elapsed,
      _freshness);
}

inline ExecResultRawT::ExecResultRawT(const ExecResultRawT &o)
      : id(o.id),
        proc(o.proc),
        output(o.output),
        hanged(o.hanged),
        error(o.error),
        info((o.info) ? new rpc::ProgInfoRawT(*o.info) : nullptr) {
}

inline ExecResultRawT &ExecResultRawT::operator=(ExecResultRawT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(proc, o.proc);
  std::swap(output, o.output);
  std::swap(hanged, o.hanged);
  std::swap(error, o.error);
  std::swap(info, o.info);
  return *this;
}

inline ExecResultRawT *ExecResultRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecResultRawT>(new ExecResultRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecResultRaw::UnPackTo(ExecResultRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = proc(); _o->proc = _e; }
  { auto _e = output(); if (_e) { _o->output.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->output.begin()); } }
  { auto _e = hanged(); _o->hanged = _e; }
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = info(); if (_e) _o->info = std::unique_ptr<rpc::ProgInfoRawT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ExecResultRaw> ExecResultRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecResultRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecResultRaw> CreateExecResultRaw(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecResultRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _proc = _o->proc;
  auto _output = _o->output.size() ? _fbb.CreateVector(_o->output) : 0;
  auto _hanged = _o->hanged;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _info = _o->info ? CreateProgInfoRaw(_fbb, _o->info.get(), _rehasher) : 0;
  return rpc::CreateExecResultRaw(
      _fbb,
      _id,
      _proc,
      _output,
      _hanged,
      _error,
      _info);
}

inline StateResultRawT *StateResultRaw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StateResultRawT>(new StateResultRawT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StateResultRaw::UnPackTo(StateResultRawT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline flatbuffers::Offset<StateResultRaw> StateResultRaw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateResultRawT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStateResultRaw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StateResultRaw> CreateStateResultRaw(flatbuffers::FlatBufferBuilder &_fbb, const StateResultRawT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StateResultRawT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return rpc::CreateStateResultRaw(
      _fbb,
      _data);
}

inline SnapshotHeaderT *SnapshotHeader::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SnapshotHeaderT>(new SnapshotHeaderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SnapshotHeader::UnPackTo(SnapshotHeaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = state(); _o->state = _e; }
  { auto _e = output_offset(); _o->output_offset = _e; }
  { auto _e = output_size(); _o->output_size = _e; }
}

inline flatbuffers::Offset<SnapshotHeader> SnapshotHeader::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotHeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSnapshotHeader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SnapshotHeader> CreateSnapshotHeader(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotHeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SnapshotHeaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _state = _o->state;
  auto _output_offset = _o->output_offset;
  auto _output_size = _o->output_size;
  return rpc::CreateSnapshotHeader(
      _fbb,
      _state,
      _output_offset,
      _output_size);
}

inline SnapshotHandshakeT *SnapshotHandshake::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SnapshotHandshakeT>(new SnapshotHandshakeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SnapshotHandshake::UnPackTo(SnapshotHandshakeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cover_edges(); _o->cover_edges = _e; }
  { auto _e = kernel_64_bit(); _o->kernel_64_bit = _e; }
  { auto _e = slowdown(); _o->slowdown = _e; }
  { auto _e = syscall_timeout_ms(); _o->syscall_timeout_ms = _e; }
  { auto _e = program_timeout_ms(); _o->program_timeout_ms = _e; }
  { auto _e = features(); _o->features = _e; }
  { auto _e = env_flags(); _o->env_flags = _e; }
  { auto _e = sandbox_arg(); _o->sandbox_arg = _e; }
}

inline flatbuffers::Offset<SnapshotHandshake> SnapshotHandshake::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotHandshakeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSnapshotHandshake(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SnapshotHandshake> CreateSnapshotHandshake(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotHandshakeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SnapshotHandshakeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cover_edges = _o->cover_edges;
  auto _kernel_64_bit = _o->kernel_64_bit;
  auto _slowdown = _o->slowdown;
  auto _syscall_timeout_ms = _o->syscall_timeout_ms;
  auto _program_timeout_ms = _o->program_timeout_ms;
  auto _features = _o->features;
  auto _env_flags = _o->env_flags;
  auto _sandbox_arg = _o->sandbox_arg;
  return rpc::CreateSnapshotHandshake(
      _fbb,
      _cover_edges,
      _kernel_64_bit,
      _slowdown,
      _syscall_timeout_ms,
      _program_timeout_ms,
      _features,
      _env_flags,
      _sandbox_arg);
}

inline SnapshotRequestT *SnapshotRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SnapshotRequestT>(new SnapshotRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SnapshotRequest::UnPackTo(SnapshotRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exec_flags(); _o->exec_flags = _e; }
  { auto _e = num_calls(); _o->num_calls = _e; }
  { auto _e = all_call_signal(); _o->all_call_signal = _e; }
  { auto _e = all_extra_signal(); _o->all_extra_signal = _e; }
  { auto _e = prog_data(); if (_e) { _o->prog_data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->prog_data.begin()); } }
}

inline flatbuffers::Offset<SnapshotRequest> SnapshotRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSnapshotRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SnapshotRequest> CreateSnapshotRequest(flatbuffers::FlatBufferBuilder &_fbb, const SnapshotRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SnapshotRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exec_flags = _o->exec_flags;
  auto _num_calls = _o->num_calls;
  auto _all_call_signal = _o->all_call_signal;
  auto _all_extra_signal = _o->all_extra_signal;
  auto _prog_data = _o->prog_data.size() ? _fbb.CreateVector(_o->prog_data) : 0;
  return rpc::CreateSnapshotRequest(
      _fbb,
      _exec_flags,
      _num_calls,
      _all_call_signal,
      _all_extra_signal,
      _prog_data);
}

inline bool VerifyHostMessagesRaw(flatbuffers::Verifier &verifier, const void *obj, HostMessagesRaw type) {
  switch (type) {
    case HostMessagesRaw::NONE: {
      return true;
    }
    case HostMessagesRaw::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequestRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostMessagesRaw::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdateRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostMessagesRaw::CorpusTriaged: {
      auto ptr = reinterpret_cast<const rpc::CorpusTriagedRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostMessagesRaw::StateRequest: {
      auto ptr = reinterpret_cast<const rpc::StateRequestRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyHostMessagesRawVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<HostMessagesRaw> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyHostMessagesRaw(
        verifier,  values->Get(i), types->GetEnum<HostMessagesRaw>(i))) {
      return false;
    }
  }
  return true;
}

inline void *HostMessagesRawUnion::UnPack(const void *obj, HostMessagesRaw type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case HostMessagesRaw::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequestRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    case HostMessagesRaw::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdateRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    case HostMessagesRaw::CorpusTriaged: {
      auto ptr = reinterpret_cast<const rpc::CorpusTriagedRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    case HostMessagesRaw::StateRequest: {
      auto ptr = reinterpret_cast<const rpc::StateRequestRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> HostMessagesRawUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case HostMessagesRaw::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequestRawT *>(value);
      return CreateExecRequestRaw(_fbb, ptr, _rehasher).Union();
    }
    case HostMessagesRaw::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdateRawT *>(value);
      return CreateSignalUpdateRaw(_fbb, ptr, _rehasher).Union();
    }
    case HostMessagesRaw::CorpusTriaged: {
      auto ptr = reinterpret_cast<const rpc::CorpusTriagedRawT *>(value);
      return CreateCorpusTriagedRaw(_fbb, ptr, _rehasher).Union();
    }
    case HostMessagesRaw::StateRequest: {
      auto ptr = reinterpret_cast<const rpc::StateRequestRawT *>(value);
      return CreateStateRequestRaw(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline HostMessagesRawUnion::HostMessagesRawUnion(const HostMessagesRawUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case HostMessagesRaw::ExecRequest: {
      value = new rpc::ExecRequestRawT(*reinterpret_cast<rpc::ExecRequestRawT *>(u.value));
      break;
    }
    case HostMessagesRaw::SignalUpdate: {
      value = new rpc::SignalUpdateRawT(*reinterpret_cast<rpc::SignalUpdateRawT *>(u.value));
      break;
    }
    case HostMessagesRaw::CorpusTriaged: {
      value = new rpc::CorpusTriagedRawT(*reinterpret_cast<rpc::CorpusTriagedRawT *>(u.value));
      break;
    }
    case HostMessagesRaw::StateRequest: {
      value = new rpc::StateRequestRawT(*reinterpret_cast<rpc::StateRequestRawT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void HostMessagesRawUnion::Reset() {
  switch (type) {
    case HostMessagesRaw::ExecRequest: {
      auto ptr = reinterpret_cast<rpc::ExecRequestRawT *>(value);
      delete ptr;
      break;
    }
    case HostMessagesRaw::SignalUpdate: {
      auto ptr = reinterpret_cast<rpc::SignalUpdateRawT *>(value);
      delete ptr;
      break;
    }
    case HostMessagesRaw::CorpusTriaged: {
      auto ptr = reinterpret_cast<rpc::CorpusTriagedRawT *>(value);
      delete ptr;
      break;
    }
    case HostMessagesRaw::StateRequest: {
      auto ptr = reinterpret_cast<rpc::StateRequestRawT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = HostMessagesRaw::NONE;
}

inline bool VerifyExecutorMessagesRaw(flatbuffers::Verifier &verifier, const void *obj, ExecutorMessagesRaw type) {
  switch (type) {
    case ExecutorMessagesRaw::NONE: {
      return true;
    }
    case ExecutorMessagesRaw::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResultRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExecutorMessagesRaw::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessageRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExecutorMessagesRaw::State: {
      auto ptr = reinterpret_cast<const rpc::StateResultRaw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExecutorMessagesRawVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ExecutorMessagesRaw> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExecutorMessagesRaw(
        verifier,  values->Get(i), types->GetEnum<ExecutorMessagesRaw>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ExecutorMessagesRawUnion::UnPack(const void *obj, ExecutorMessagesRaw type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ExecutorMessagesRaw::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResultRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    case ExecutorMessagesRaw::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessageRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    case ExecutorMessagesRaw::State: {
      auto ptr = reinterpret_cast<const rpc::StateResultRaw *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ExecutorMessagesRawUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ExecutorMessagesRaw::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResultRawT *>(value);
      return CreateExecResultRaw(_fbb, ptr, _rehasher).Union();
    }
    case ExecutorMessagesRaw::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessageRawT *>(value);
      return CreateExecutingMessageRaw(_fbb, ptr, _rehasher).Union();
    }
    case ExecutorMessagesRaw::State: {
      auto ptr = reinterpret_cast<const rpc::StateResultRawT *>(value);
      return CreateStateResultRaw(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ExecutorMessagesRawUnion::ExecutorMessagesRawUnion(const ExecutorMessagesRawUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ExecutorMessagesRaw::ExecResult: {
      value = new rpc::ExecResultRawT(*reinterpret_cast<rpc::ExecResultRawT *>(u.value));
      break;
    }
    case ExecutorMessagesRaw::Executing: {
      value = new rpc::ExecutingMessageRawT(*reinterpret_cast<rpc::ExecutingMessageRawT *>(u.value));
      break;
    }
    case ExecutorMessagesRaw::State: {
      value = new rpc::StateResultRawT(*reinterpret_cast<rpc::StateResultRawT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ExecutorMessagesRawUnion::Reset() {
  switch (type) {
    case ExecutorMessagesRaw::ExecResult: {
      auto ptr = reinterpret_cast<rpc::ExecResultRawT *>(value);
      delete ptr;
      break;
    }
    case ExecutorMessagesRaw::Executing: {
      auto ptr = reinterpret_cast<rpc::ExecutingMessageRawT *>(value);
      delete ptr;
      break;
    }
    case ExecutorMessagesRaw::State: {
      auto ptr = reinterpret_cast<rpc::StateResultRawT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ExecutorMessagesRaw::NONE;
}

}  // namespace rpc

#endif  // FLATBUFFERS_GENERATED_FLATRPC_RPC_H_
