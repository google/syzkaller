# Copyright 2017 syzkaller project authors. All rights reserved.
# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

include <linux/types.h>
include <linux/byteorder/generic.h>

syz_emit_ethernet(len len[packet], packet ptr[in, eth_packet])

################################################################################
################################### Ethernet ###################################
################################################################################

# https://en.wikipedia.org/wiki/Ethernet_frame#Structure
# https://en.wikipedia.org/wiki/IEEE_802.1Q

include <uapi/linux/if.h>
include <uapi/linux/if_ether.h>

mac_addr_local {
# This corresponds to LOCAL_MAC ("aa:aa:aa:aa:aa:%02hx" % pid) in executor/common.h
	a0		array[const[0xaa, int8], 5]
	a1		proc[int8, 0, 1]
} [packed]

mac_addr_remote {
# This corresponds to REMOTE_MAC ("bb:bb:bb:bb:bb:%02hx" % pid) in executor/common.h
	a0		array[const[0xbb, int8], 5]
	a1		proc[int8, 0, 1]
} [packed]

mac_addr [
	empty		array[const[0x00, int8], 6]
	local		mac_addr_local
	remote		mac_addr_remote
	random		array[int8, 6]
]

vlan_tag_ad {
	tpid		const[0x9100, int16be]
	pcp		int16:3
	dei		int16:1
	vid		int16:12
} [packed]

vlan_tag_q {
	tpid		const[0x8100, int16be]
	pcp		int16:3
	dei		int16:1
	vid		int16:12
} [packed]

vlan_tag {
	tag_ad		array[vlan_tag_ad, 0:1]
	tag_q		vlan_tag_q
} [packed]

eth_packet {
	dst_mac		mac_addr
	src_mac		mac_addr
	vtag		array[vlan_tag, 0:1]
	payload		eth_payload
} [packed]

eth_payload {
	eth2		eth2_packet
} [packed]

################################################################################
################################## Ethernet 2 ##################################
################################################################################

# https://en.wikipedia.org/wiki/Ethernet_frame#Ethernet_II

ether_types = ETH_P_LOOP, ETH_P_PUP, ETH_P_PUPAT, ETH_P_TSN, ETH_P_IP, ETH_P_X25, ETH_P_ARP, ETH_P_IEEEPUP, ETH_P_IEEEPUPAT, ETH_P_BATMAN, ETH_P_DEC, ETH_P_DNA_DL, ETH_P_DNA_RC, ETH_P_DNA_RT, ETH_P_LAT, ETH_P_DIAG, ETH_P_CUST, ETH_P_SCA, ETH_P_TEB, ETH_P_RARP, ETH_P_ATALK, ETH_P_AARP, ETH_P_8021Q, ETH_P_IPX, ETH_P_IPV6, ETH_P_PAUSE, ETH_P_SLOW, ETH_P_WCCP, ETH_P_MPLS_UC, ETH_P_MPLS_MC, ETH_P_ATMMPOA, ETH_P_PPP_DISC, ETH_P_PPP_SES, ETH_P_LINK_CTL, ETH_P_ATMFATE, ETH_P_PAE, ETH_P_AOE, ETH_P_8021AD, ETH_P_802_EX1, ETH_P_TIPC, ETH_P_MACSEC, ETH_P_8021AH, ETH_P_MVRP, ETH_P_1588, ETH_P_NCSI, ETH_P_PRP, ETH_P_FCOE, ETH_P_TDLS, ETH_P_FIP, ETH_P_80221, ETH_P_HSR, ETH_P_LOOPBACK, ETH_P_QINQ1, ETH_P_QINQ2, ETH_P_QINQ3, ETH_P_EDSA, ETH_P_AF_IUCV, ETH_P_802_3_MIN

eth2_packet {
	etype		flags[ether_types, int16be]
	payload		eth2_payload
} [packed]

eth2_payload [
	ipv4		ipv4_packet
	ipv6		ipv6_packet
] [varlen]

################################################################################
##################################### IPv4 #####################################
################################################################################

# https://tools.ietf.org/html/rfc791#section-3.1
# https://en.wikipedia.org/wiki/IPv4#Header

# TODO: https://en.wikipedia.org/wiki/IPsec#Authentication_Header
# TODO: https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload

include <uapi/linux/in.h>
include <uapi/linux/ip.h>
include <net/cipso_ipv4.h>

# This corresponds to LOCAL_IPV4 ("172.20.%d.170" % pid) in executor/common.h
ipv4_addr_local {
	a0		const[0xac, int8]
	a1		const[0x14, int8]
	a2		proc[int8, 0, 1]
	a3		const[0xaa, int8]
} [packed]

# This corresponds to LOCAL_IPV4 ("172.20.%d.187" % pid) in executor/common.h
ipv4_addr_remote {
	a0		const[0xac, int8]
	a1		const[0x14, int8]
	a2		proc[int8, 0, 1]
	a3		const[0xbb, int8]
} [packed]

ipv4_addr [
# 0.0.0.0
	empty		const[0x00000000, int32be]
# 172.20.%d.170
	local		ipv4_addr_local
# 172.20.%d.187
	remote		ipv4_addr_remote
# 127.0.0.1
	loopback	const[0x7f000001, int32be]
# 224.0.0.1
	multicast1	const[0xe0000001, int32be]
# 224.0.0.2
	multicast2	const[0xe0000002, int32be]
# 255.255.255.255
	broadcast	const[0xffffffff, int32be]
# random
	rand_addr	int32be
]

# http://www.iana.org/assignments/ip-parameters/ip-parameters.xhtml#ip-parameters-1
ipv4_option [
	generic		ipv4_option_generic
	end		ipv4_option_end
	noop		ipv4_option_noop
	lsrr		ipv4_option_lsrr
	ssrr		ipv4_option_ssrr
	rr		ipv4_option_rr
	timestamp	ipv4_option_timestamp
	cipso		ipv4_option_cipso
	ra		ipv4_option_ra
# IPOPT_SEC and IPOPT_SID are not supported by Linux kernel
] [varlen]

ipv4_option_types = IPOPT_END, IPOPT_NOOP, IPOPT_SEC, IPOPT_LSRR, IPOPT_TIMESTAMP, IPOPT_CIPSO, IPOPT_RR, IPOPT_SID, IPOPT_SSRR, IPOPT_RA

ipv4_option_generic {
	type		flags[ipv4_option_types, int8]
	length		len[parent, int8]
	data		array[int8, 0:16]
} [packed]

# https://tools.ietf.org/html/rfc791#section-3.1
ipv4_option_end {
	type		const[IPOPT_END, int8]
} [packed]

# https://tools.ietf.org/html/rfc791#section-3.1
ipv4_option_noop {
	type		const[IPOPT_NOOP, int8]
} [packed]

# https://tools.ietf.org/html/rfc791#section-3.1
ipv4_option_lsrr {
	type		const[IPOPT_LSRR, int8]
	length		len[parent, int8]
	pointer		int8
	data		array[ipv4_addr]
} [packed]

# https://tools.ietf.org/html/rfc791#section-3.1
ipv4_option_ssrr {
	type		const[IPOPT_SSRR, int8]
	length		len[parent, int8]
	pointer		int8
	data		array[ipv4_addr]
} [packed]

# https://tools.ietf.org/html/rfc791#section-3.1
ipv4_option_rr {
	type		const[IPOPT_RR, int8]
	length		len[parent, int8]
	pointer		int8
	data		array[ipv4_addr]
} [packed]

ipv4_option_timestamp_flags = IPOPT_TS_TSONLY, IPOPT_TS_TSANDADDR, IPOPT_TS_PRESPEC

ipv4_option_timestamp_timestamp {
	addr		array[ipv4_addr, 0:1]
	timestamp	int32be
} [packed]

# https://tools.ietf.org/html/rfc791#section-3.1
# http://www.networksorcery.com/enp/protocol/ip/option004.htm
ipv4_option_timestamp {
	type		const[IPOPT_TIMESTAMP, int8]
	length		len[parent, int8]
	pointer		int8
	flg		flags[ipv4_option_timestamp_flags, int8:4]
	oflw		int8:4
	timestamps	array[ipv4_option_timestamp_timestamp]
} [packed]

ipv4_option_cipso_tag_types = CIPSO_V4_TAG_INVALID, CIPSO_V4_TAG_RBITMAP, CIPSO_V4_TAG_ENUM, CIPSO_V4_TAG_RANGE, CIPSO_V4_TAG_PBITMAP, CIPSO_V4_TAG_FREEFORM

# TODO: describe particular tag types
ipv4_option_cipso_tag {
	type		flags[ipv4_option_cipso_tag_types, int8]
	length		len[parent, int8]
	data		array[int8, 0:16]
} [packed]

# https://www.ietf.org/archive/id/draft-ietf-cipso-ipsecurity-01.txt
ipv4_option_cipso {
	type		const[IPOPT_CIPSO, int8]
	length		len[parent, int8]
	doi		int32be
	tags		array[ipv4_option_cipso_tag]
} [packed]

# https://tools.ietf.org/html/rfc2113
ipv4_option_ra {
	type		const[IPOPT_RA, int8]
	length		len[parent, int8]
	value		int32be
} [packed]

ipv4_options {
	options		array[ipv4_option]
} [packed, align_4]

ipv4_types = IPPROTO_IP, IPPROTO_ICMP, IPPROTO_IGMP, IPPROTO_IPIP, IPPROTO_TCP, IPPROTO_EGP, IPPROTO_PUP, IPPROTO_UDP, IPPROTO_IDP, IPPROTO_TP, IPPROTO_DCCP, IPPROTO_IPV6, IPPROTO_RSVP, IPPROTO_GRE, IPPROTO_ESP, IPPROTO_AH, IPPROTO_MTP, IPPROTO_BEETPH, IPPROTO_ENCAP, IPPROTO_PIM, IPPROTO_COMP, IPPROTO_SCTP, IPPROTO_UDPLITE, IPPROTO_MPLS, IPPROTO_RAW

ipv4_header {
	ihl		bytesize4[parent, int8:4]
	version		const[4, int8:4]
	ecn		int8:2
	dscp		int8:6
	total_len	len[ipv4_packet, int16be]
	id		int16be
	frag_off	int16be
# TODO: frag_off is actually 13 bits, 3 bits are flags
	ttl		int8
	protocol	flags[ipv4_types, int8]
	csum		csum[ipv4, int16be]
	src_ip		ipv4_addr
	dst_ip		ipv4_addr
	options		ipv4_options
} [packed]

ipv4_packet {
	header		ipv4_header
	payload		ip_payload
} [packed]

################################################################################
##################################### IPv6 #####################################
################################################################################

# https://tools.ietf.org/html/rfc2460#section-3
# https://en.wikipedia.org/wiki/IPv6_packet#Fixed_header

include <uapi/linux/in6.h>
include <uapi/linux/ipv6.h>
include <net/ipv6.h>

ipv6_types = IPPROTO_IP, IPPROTO_ICMP, IPPROTO_IGMP, IPPROTO_IPIP, IPPROTO_TCP, IPPROTO_EGP, IPPROTO_PUP, IPPROTO_UDP, IPPROTO_IDP, IPPROTO_TP, IPPROTO_DCCP, IPPROTO_IPV6, IPPROTO_RSVP, IPPROTO_GRE, IPPROTO_ESP, IPPROTO_AH, IPPROTO_MTP, IPPROTO_BEETPH, IPPROTO_ENCAP, IPPROTO_PIM, IPPROTO_COMP, IPPROTO_SCTP, IPPROTO_UDPLITE, IPPROTO_MPLS, IPPROTO_RAW, IPPROTO_HOPOPTS, IPPROTO_ROUTING, IPPROTO_FRAGMENT, IPPROTO_ICMPV6, IPPROTO_NONE, IPPROTO_DSTOPTS, IPPROTO_MH, NEXTHDR_HOP, NEXTHDR_TCP, NEXTHDR_UDP, NEXTHDR_IPV6, NEXTHDR_ROUTING, NEXTHDR_FRAGMENT, NEXTHDR_GRE, NEXTHDR_ESP, NEXTHDR_AUTH, NEXTHDR_ICMP, NEXTHDR_NONE, NEXTHDR_DEST, NEXTHDR_SCTP, NEXTHDR_MOBILITY

# This corresponds to LOCAL_IPV6 ("fd00::%02hxaa" % pid) in executor/common.h
ipv6_addr_local {
	a0		const[0xfd, int8]
	a1		array[const[0x00, int8], 13]
	a2		proc[int8, 0, 1]
	a3		const[0xaa, int8]
} [packed]

# This corresponds to REMOTE_IPV6 ("fd00::%02hxbb" % pid) in executor/common.h
ipv6_addr_remote {
	a0		const[0xfd, int8]
	a1		array[const[0x00, int8], 13]
	a2		proc[int8, 0, 1]
	a3		const[0xbb, int8]
} [packed]

ipv6_addr_loopback {
	a0		const[0, int64be]
	a1		const[1, int64be]
} [packed]

ipv6_addr [
	local		ipv6_addr_local
	remote		ipv6_addr_remote
	loopback	ipv6_addr_loopback
]

# TODO: Describe more types of headers
# NEXTHDR_HOP, NEXTHDR_TCP, NEXTHDR_UDP, NEXTHDR_IPV6, NEXTHDR_ROUTING, NEXTHDR_FRAGMENT, NEXTHDR_GRE, NEXTHDR_ESP, NEXTHDR_AUTH, NEXTHDR_ICMP, NEXTHDR_NONE, NEXTHDR_DEST, NEXTHDR_SCTP, NEXTHDR_MOBILITY
# https://tools.ietf.org/html/rfc2402
# https://tools.ietf.org/html/rfc2406

# https://tools.ietf.org/html/rfc2460#section-4
# The length field in each of the extension headers specifies the
# length of the header in 8-octet units not including the first 8 octets.
ipv6_ext_header [
	hopopts 	ipv6_hopots_ext_header
	routing 	ipv6_routing_ext_header
	fragment	ipv6_fragment_ext_header
	dstopts		ipv6_dstopts_ext_header
] [varlen]

ipv6_hopots_ext_header {
	next_header	flags[ipv6_types, int8]
	length		bytesize8[options, int8]
	pad		array[const[0, int8], 6]
	options		array[ipv6_tlv_option]
} [packed, align_8]

ipv6_routing_types = IPV6_SRCRT_STRICT, IPV6_SRCRT_TYPE_0, IPV6_SRCRT_TYPE_2

ipv6_routing_ext_header {
	next_header	flags[ipv6_types, int8]
	length		bytesize8[data, int8]
	routing_type	flags[ipv6_routing_types, int8]
	segments_left	int8
	reserved	int32be
	data		array[ipv6_addr]
} [packed, align_8]

ipv6_fragment_ext_header {
	next_header	flags[ipv6_types, int8]
	reserved1	int8
	m_flag		int16:1
	reserved2	int16:2
	fragment_offset	int16be:13
	identification	int32
} [packed]

ipv6_dstopts_ext_header {
	next_header	flags[ipv6_types, int8]
	length		bytesize8[options, int8]
	pad		array[const[0, int8], 6]
	options		array[ipv6_tlv_option]
} [packed]

# TODO: describe particular tlv options
ipv6_tlv_option_types = IPV6_TLV_PAD1, IPV6_TLV_PADN, IPV6_TLV_ROUTERALERT, IPV6_TLV_CALIPSO, IPV6_TLV_JUMBO, IPV6_TLV_HAO, 0xff, 0xfe

ipv6_tlv_option {
	type		flags[ipv6_tlv_option_types, int8]
	length		len[data, int8]
	data		array[int8]
} [packed]

ipv6_packet {
	priority	int8:4
	version		const[6, int8:4]
	flow_label	array[int8, 3]
# TODO: flow_label is actually 20 bits, 4 bits are part of priority
	length		len[payload, int16be]
	next_header	flags[ipv6_types, int8]
	hop_limit	int8
	src_ip		ipv6_addr
	dst_ip		ipv6_addr
	payload		ipv6_packet_payload
} [packed]

ipv6_packet_payload {
	ext_headers	array[ipv6_ext_header]
	payload		ip_payload
} [packed]

################################################################################
###################################### IP ######################################
################################################################################

ip_payload [
	tcp		tcp_packet
	udp		udp_packet
] [varlen]

################################################################################
###################################### UDP #####################################
################################################################################

# https://tools.ietf.org/html/rfc768
# https://en.wikipedia.org/wiki/User_Datagram_Protocol#Packet_structure

udp_packet {
	src_port	proc[int16be, 20000, 4]
	dst_port	proc[int16be, 20000, 4]
	length		len[parent, int16be]
	csum		csum[udp, int16be]
	data		array[int8]
} [packed]

################################################################################
###################################### TCP #####################################
################################################################################

# https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure
# http://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml

include <net/tcp.h>
include <uapi/linux/tcp.h>

tcp_option [
	generic		tcp_generic_option
	nop		tcp_nop_option
	eol		tcp_eol_option
	mss		tcp_mss_option
	window		tcp_window_option
	sack_perm	tcp_sack_perm_option
	sack		tcp_sack_option
	timestamp	tcp_timestamp_option
	md5sig		tcp_md5sig_option
	fastopen	tcp_fastopen_option
# TODO: TCPOPT_EXP option
] [varlen]

tcp_option_types = TCPOPT_NOP, TCPOPT_EOL, TCPOPT_MSS, TCPOPT_WINDOW, TCPOPT_SACK_PERM, TCPOPT_SACK, TCPOPT_TIMESTAMP, TCPOPT_MD5SIG, TCPOPT_FASTOPEN, TCPOPT_EXP

tcp_generic_option {
	type		flags[tcp_option_types, int8]
	length		len[parent, int8]
	data		array[int8, 0:16]
} [packed]

# https://tools.ietf.org/html/rfc793#section-3.1
tcp_nop_option {
	type		const[TCPOPT_NOP, int8]
} [packed]

# https://tools.ietf.org/html/rfc793#section-3.1
tcp_eol_option {
	type		const[TCPOPT_EOL, int8]
} [packed]

# https://tools.ietf.org/html/rfc793#section-3.1
tcp_mss_option {
	type		const[TCPOPT_MSS, int8]
	length		len[parent, int8]
	seg_size	int16
} [packed]

# https://tools.ietf.org/html/rfc7323#section-2
tcp_window_option {
	type		const[TCPOPT_WINDOW, int8]
	length		len[parent, int8]
	shift		int8
} [packed]

# https://tools.ietf.org/html/rfc2018#section-2
tcp_sack_perm_option {
	type		const[TCPOPT_SACK_PERM, int8]
	length		len[parent, int8]
} [packed]

# https://tools.ietf.org/html/rfc2018#section-3
tcp_sack_option {
	type		const[TCPOPT_SACK, int8]
	length		len[parent, int8]
	data		array[int32be]
} [packed]

# https://tools.ietf.org/html/rfc7323#section-3
tcp_timestamp_option {
	type		const[TCPOPT_TIMESTAMP, int8]
	length		len[parent, int8]
	tsval		int32be
	tsecr		int32be
} [packed]

# https://tools.ietf.org/html/rfc2385#section-3.0
tcp_md5sig_option {
	type		const[TCPOPT_MD5SIG, int8]
	length		len[parent, int8]
	md5		array[int8, 16]
} [packed]

# https://tools.ietf.org/html/rfc7413#section-4.1.1
tcp_fastopen_option {
	type		const[TCPOPT_FASTOPEN, int8]
	length		len[parent, int8]
	data		array[int8, 0:16]
} [packed]

tcp_options {
	options		array[tcp_option]
} [packed, align_4]

# TODO: extract sequence numbers from packets
tcp_seq_num [
	init	const[0x56565656, int32be]
	next	const[0x56565657, int32be]
	nextn	int32be[0x56565656:0x56566000]
	random	int32be
]

tcp_flags = 0, TCPHDR_FIN, TCPHDR_SYN, TCPHDR_RST, TCPHDR_PSH, TCPHDR_ACK, TCPHDR_URG, TCPHDR_ECE, TCPHDR_CWR, TCPHDR_SYN_ECN

tcp_header {
	src_port	proc[int16be, 20000, 4]
	dst_port	proc[int16be, 20000, 4]
	seq_num		tcp_seq_num
	ack_num		tcp_seq_num
	ns		int8:1
	reserved	const[0, int8:3]
	data_off	bytesize4[parent, int8:4]
	flags		flags[tcp_flags, int8]
	window_size	int16be
	csum		csum[tcp, int16be]
	urg_ptr		int16be
	options		tcp_options
} [packed]

tcp_packet {
	header		tcp_header
	payload		tcp_payload
} [packed]

tcp_payload {
	payload		array[int8]
} [packed]
