// Copyright 2015/2016 syzkaller project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"sort"
	"sync"

	"github.com/google/syzkaller/pkg/ast"
	"github.com/google/syzkaller/pkg/compiler"
	"github.com/google/syzkaller/pkg/serializer"
)

var (
	flagV          = flag.Int("v", 0, "verbosity")
	flagMemProfile = flag.String("memprofile", "", "write a memory profile to the file")
)

func main() {
	flag.Parse()

	top := ast.ParseGlob("sys/*\\.txt", nil)
	if top == nil {
		os.Exit(1)
	}

	type Result struct {
		OK          bool
		Errors      []string
		Unsupported map[string]bool
		ArchData    []byte
	}
	results := make([]Result, len(archs))
	var wg sync.WaitGroup
	wg.Add(len(archs))

	for i, arch := range archs {
		arch := arch
		res := &results[i]
		go func() {
			defer wg.Done()
			eh := func(pos ast.Pos, msg string) {
				res.Errors = append(res.Errors, fmt.Sprintf("%v: %v\n", pos, msg))
			}
			consts := compiler.DeserializeConstsGlob("sys/*_"+arch.Name+"\\.const", eh)
			if consts == nil {
				return
			}
			prog := compiler.Compile(top, consts, eh)
			if prog == nil {
				return
			}
			res.Unsupported = prog.Unsupported

			sysFile := filepath.Join("sys", "sys_"+arch.Name+".go")
			out := new(bytes.Buffer)
			generate(arch.Name, prog, consts, out)
			writeSource(sysFile, out.Bytes())

			res.ArchData = generateExecutorSyscalls(arch, prog.Syscalls)
			res.OK = true
		}()
	}
	wg.Wait()

	var syscallArchs [][]byte
	unsupported := make(map[string]int)
	for i, arch := range archs {
		res := &results[i]
		fmt.Printf("generating %v...\n", arch.Name)
		for _, msg := range res.Errors {
			fmt.Print(msg)
		}
		if !res.OK {
			os.Exit(1)
		}
		syscallArchs = append(syscallArchs, res.ArchData)
		for u := range res.Unsupported {
			unsupported[u]++
		}
		fmt.Printf("\n")
	}

	for what, count := range unsupported {
		if count == len(archs) {
			failf("%v is unsupported on all arches (typo?)", what)
		}
	}

	writeExecutorSyscalls(syscallArchs)

	if *flagMemProfile != "" {
		f, err := os.Create(*flagMemProfile)
		if err != nil {
			failf("could not create memory profile: ", err)
		}
		runtime.GC() // get up-to-date statistics
		if err := pprof.WriteHeapProfile(f); err != nil {
			failf("could not write memory profile: ", err)
		}
		f.Close()
	}
}

func generate(arch string, prog *compiler.Prog, consts map[string]uint64, out io.Writer) {
	fmt.Fprintf(out, "// AUTOGENERATED FILE\n")
	fmt.Fprintf(out, "package sys\n\n")

	fmt.Fprintf(out, "var resourceArray = ")
	serializer.Write(out, prog.Resources)
	fmt.Fprintf(out, "\n\n")

	// Struct fields can refer to other structs. Go compiler won't like if
	// we refer to Structs during Structs initialization. So we do
	// it in 2 passes: on the first pass create struct types without fields,
	// on the second pass we fill in fields.

	// Since structs of the same type can be fields with different names
	// of multiple other structs, we have an instance of those structs
	// for each field indexed by the name of the parent struct, field name and dir.
	fmt.Fprintf(out, "var structFields = ")
	serializer.Write(out, prog.StructFields)
	fmt.Fprintf(out, "\n\n")

	fmt.Fprintf(out, "var Calls = ")
	serializer.Write(out, prog.Syscalls)
	fmt.Fprintf(out, "\n\n")

	type NameValue struct {
		name string
		val  uint64
	}
	constArr := make([]NameValue, 0, len(consts))
	for name, val := range consts {
		constArr = append(constArr, NameValue{name, val})
	}
	sort.Slice(constArr, func(i, j int) bool {
		return constArr[i].name < constArr[j].name
	})

	fmt.Fprintf(out, "const (\n")
	for _, nv := range constArr {
		fmt.Fprintf(out, "%v = %v\n", nv.name, nv.val)
	}
	fmt.Fprintf(out, ")\n")
}

func writeSource(file string, data []byte) {
	src, err := format.Source(data)
	if err != nil {
		fmt.Printf("%s\n", data)
		failf("failed to format output: %v", err)
	}
	if oldSrc, err := ioutil.ReadFile(file); err == nil && bytes.Equal(src, oldSrc) {
		return
	}
	writeFile(file, src)
}

func writeFile(file string, data []byte) {
	outf, err := os.Create(file)
	if err != nil {
		failf("failed to create output file: %v", err)
	}
	defer outf.Close()
	outf.Write(data)
}

func failf(msg string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, msg+"\n", args...)
	os.Exit(1)
}

func logf(v int, msg string, args ...interface{}) {
	if *flagV >= v {
		fmt.Fprintf(os.Stderr, msg+"\n", args...)
	}
}
