// Copyright 2015/2016 syzkaller project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"sort"
	"sync"

	"github.com/google/syzkaller/pkg/ast"
	"github.com/google/syzkaller/pkg/compiler"
	"github.com/google/syzkaller/pkg/serializer"
	"github.com/google/syzkaller/prog"
)

var (
	flagV          = flag.Int("v", 0, "verbosity")
	flagMemProfile = flag.String("memprofile", "", "write a memory profile to the file")
)

func main() {
	flag.Parse()

	top := ast.ParseGlob(filepath.Join("sys", "linux", "*\\.txt"), nil)
	if top == nil {
		os.Exit(1)
	}

	type Result struct {
		OK          bool
		Errors      []string
		Unsupported map[string]bool
		ArchData    []byte
	}
	results := make([]Result, len(archs))
	var wg sync.WaitGroup
	wg.Add(len(archs))

	for i, arch := range archs {
		arch := arch
		res := &results[i]
		go func() {
			defer wg.Done()
			eh := func(pos ast.Pos, msg string) {
				res.Errors = append(res.Errors, fmt.Sprintf("%v: %v\n", pos, msg))
			}
			consts := compiler.DeserializeConstsGlob(filepath.Join("sys", "linux", "*_"+arch.Name+"\\.const"), eh)
			if consts == nil {
				return
			}
			prog := compiler.Compile(top, consts, arch.PtrSize, eh)
			if prog == nil {
				return
			}
			res.Unsupported = prog.Unsupported

			sysFile := filepath.Join("sys", "linux", arch.Name+".go")
			out := new(bytes.Buffer)
			generate(arch, prog, consts, out)
			writeSource(sysFile, out.Bytes())

			res.ArchData = generateExecutorSyscalls(arch, prog.Syscalls)
			res.OK = true
		}()
	}
	wg.Wait()

	var syscallArchs [][]byte
	unsupported := make(map[string]int)
	for i, arch := range archs {
		res := &results[i]
		fmt.Printf("generating %v...\n", arch.Name)
		for _, msg := range res.Errors {
			fmt.Print(msg)
		}
		if !res.OK {
			os.Exit(1)
		}
		syscallArchs = append(syscallArchs, res.ArchData)
		for u := range res.Unsupported {
			unsupported[u]++
		}
		fmt.Printf("\n")
	}

	for what, count := range unsupported {
		if count == len(archs) {
			failf("%v is unsupported on all arches (typo?)", what)
		}
	}

	writeExecutorSyscalls(syscallArchs)

	if *flagMemProfile != "" {
		f, err := os.Create(*flagMemProfile)
		if err != nil {
			failf("could not create memory profile: ", err)
		}
		runtime.GC() // get up-to-date statistics
		if err := pprof.WriteHeapProfile(f); err != nil {
			failf("could not write memory profile: ", err)
		}
		f.Close()
	}
}

func generate(arch *Arch, prg *compiler.Prog, consts map[string]uint64, out io.Writer) {
	fmt.Fprintf(out, "// AUTOGENERATED FILE\n")
	fmt.Fprintf(out, "package linux\n\n")
	fmt.Fprintf(out, "import . \"github.com/google/syzkaller/prog\"\n\n")

	fmt.Fprintf(out, "func init() {\n")
	fmt.Fprintf(out, "\tinitArch(syscalls_%v, resources_%v, structDescs_%v, consts_%v, %q, %v)\n",
		arch.Name, arch.Name, arch.Name, arch.Name, arch.Name, arch.PtrSize)
	fmt.Fprintf(out, "}\n\n")

	fmt.Fprintf(out, "var resources_%v = ", arch.Name)
	serializer.Write(out, prg.Resources)
	fmt.Fprintf(out, "\n\n")

	fmt.Fprintf(out, "var structDescs_%v = ", arch.Name)
	serializer.Write(out, prg.StructDescs)
	fmt.Fprintf(out, "\n\n")

	fmt.Fprintf(out, "var syscalls_%v = ", arch.Name)
	serializer.Write(out, prg.Syscalls)
	fmt.Fprintf(out, "\n\n")

	constArr := make([]prog.ConstValue, 0, len(consts))
	for name, val := range consts {
		constArr = append(constArr, prog.ConstValue{name, val})
	}
	sort.Slice(constArr, func(i, j int) bool {
		return constArr[i].Name < constArr[j].Name
	})
	fmt.Fprintf(out, "var consts_%v = ", arch.Name)
	serializer.Write(out, constArr)
	fmt.Fprintf(out, "\n")
}

func writeSource(file string, data []byte) {
	src, err := format.Source(data)
	if err != nil {
		fmt.Printf("%s\n", data)
		failf("failed to format output: %v", err)
	}
	if oldSrc, err := ioutil.ReadFile(file); err == nil && bytes.Equal(src, oldSrc) {
		return
	}
	writeFile(file, src)
}

func writeFile(file string, data []byte) {
	outf, err := os.Create(file)
	if err != nil {
		failf("failed to create output file: %v", err)
	}
	defer outf.Close()
	outf.Write(data)
}

func failf(msg string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, msg+"\n", args...)
	os.Exit(1)
}

func logf(v int, msg string, args ...interface{}) {
	if *flagV >= v {
		fmt.Fprintf(os.Stderr, msg+"\n", args...)
	}
}
