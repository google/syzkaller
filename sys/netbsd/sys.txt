# Copyright 2017 syzkaller project authors. All rights reserved.
# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

include <sys/types.h>
include <sys/mman.h>
include <sys/stat.h>
include <fcntl.h>
include <unistd.h>
include <sys/time.h>
include <dirent.h>
include <poll.h>
include <sys/select.h>
include <sys/param.h>
include <sys/resource.h>
include <time.h>
include <signal.h>
include <sys/wait.h>
include <sys/ptrace.h>
include <sys/sched.h>
include <sys/signal.h>
include <sys/spawn.h>

syz_execute_func(text ptr[in, text[target]])

pipe(pipefd ptr[out, pipefd])

stat(file ptr[in, filename], statbuf ptr[out, stat])
lstat(file ptr[in, filename], statbuf ptr[out, stat])

poll(fds ptr[in, array[pollfd]], nfds len[fds], timeout int32)
select(n len[inp], inp ptr[inout, fd_set], outp ptr[inout, fd_set], exp ptr[inout, fd_set], tvp ptr[inout, timeval])

mincore(addr vma, size len[addr], vec buffer[out])

fcntl$dupfd(fd fd, cmd flags[fcntl_dupfd], arg fd) fd
fcntl$getflags(fd fd, cmd flags[fcntl_getflags])
fcntl$setflags(fd fd, cmd const[F_SETFD], flags flags[fcntl_flags])
fcntl$setstatus(fd fd, cmd const[F_SETFL], flags flags[fcntl_status])
fcntl$lock(fd fd, cmd flags[fcntl_lock], lock ptr[in, flock])
fcntl$getown(fd fd, cmd const[F_GETOWN]) pid
fcntl$setown(fd fd, cmd const[F_SETOWN], pid pid)

mknod(file ptr[in, filename], mode flags[mknod_mode], dev int32)
mknod$loop(file ptr[in, filename], mode flags[mknod_mode], dev proc[1792, 2])
mknodat(dirfd fd_dir, file ptr[in, filename], mode flags[mknod_mode], dev int32)
chmod(file ptr[in, filename], mode flags[open_mode])
fchmod(fd fd, mode flags[open_mode])
fchmodat(dirfd fd_dir, file ptr[in, filename], mode flags[open_mode], flags flags[at_flags])
chown(file ptr[in, filename], uid uid, gid gid)
lchown(file ptr[in, filename], uid uid, gid gid)
fchown(fd fd, uid uid, gid gid)
fchownat(dirfd fd_dir, file ptr[in, filename], uid uid, gid gid, flags flags[at_flags])
faccessat(dirfd fd_dir, pathname ptr[in, filename], mode flags[open_mode], flags flags[faccessat_flags])
utimes(filename ptr[in, filename], times ptr[in, itimerval])
utimensat(dir fd_dir, pathname ptr[in, filename], times ptr[in, itimerval], flags flags[utimensat_flags])

execve(file ptr[in, filename], argv ptr[in, array[ptr[in, string]]], envp ptr[in, array[ptr[in, string]]])

getgid() gid
getegid() gid
setuid(uid uid)
setgid(gid gid)
seteuid(euid uid)
setegid(egid gid)
getuid() uid
geteuid() uid
setpgid(pid pid, pgid pid)
getpgid(pid pid) pid
getpgrp() pid
getpid() pid
getppid() pid
setreuid(ruid uid, euid uid)
setregid(rgid gid, egid gid)
getgroups(size len[list], list ptr[inout, array[gid]])
setgroups(size len[list], list ptr[in, array[gid]])

link(old ptr[in, filename], new ptr[in, filename])
linkat(oldfd fd_dir, old ptr[in, filename], newfd fd_dir, new ptr[in, filename], flags flags[linkat_flags])
symlinkat(old ptr[in, filename], newfd fd_dir, new ptr[in, filename])
symlink(old ptr[in, filename], new ptr[in, filename])
unlink(path ptr[in, filename])
unlinkat(fd fd_dir, path ptr[in, filename], flags flags[unlinkat_flags])
readlink(path ptr[in, filename], buf buffer[out], siz len[buf])
readlinkat(fd fd_dir, path ptr[in, filename], buf buffer[out], siz len[buf])
rename(old ptr[in, filename], new ptr[in, filename])
renameat(oldfd fd_dir, old ptr[in, filename], newfd fd_dir, new ptr[in, filename])
mkdir(path ptr[in, filename], mode flags[open_mode])
mkdirat(fd fd_dir, path ptr[in, filename], mode flags[open_mode])
rmdir(path ptr[in, filename])
truncate(file ptr[in, filename], len intptr)
ftruncate(fd fd, len intptr)
flock(fd fd, op flags[flock_op])
fsync(fd fd)
fdatasync(fd fd)
sync()
getdents(fd fd_dir, ent buffer[out], count len[ent])
chroot(dir ptr[in, filename])
fchroot(fd fd)
chdir(dir ptr[in, filename])
fchdir(fd fd)

getrusage(who flags[rusage_who], usage ptr[out, rusage])
getrlimit(res flags[rlimit_type], rlim ptr[out, rlimit])
setrlimit(res flags[rlimit_type], rlim ptr[in, rlimit])

clock_gettime(id flags[clock_id], tp ptr[out, timespec])
clock_settime(id flags[clock_id], tp ptr[in, timespec])
clock_getres(id flags[clock_id], tp ptr[out, timespec])
clock_nanosleep(id flags[clock_id], flags flags[timer_flags], rqtp ptr[in, timespec], rmtp ptr[out, timespec, opt])
nanosleep(req ptr[in, timespec], rem ptr[out, timespec, opt])
getitimer(which flags[getitimer_which], cur ptr[out, itimerval])
setitimer(which flags[getitimer_which], new ptr[in, itimerval], old ptr[out, itimerval, opt])
wait4(pid pid, status ptr[out, int32, opt], options flags[wait_options], ru ptr[out, rusage, opt])

exit(code intptr)
ptrace(request intptr, pid pid, addr ptr[out, intptr], data intptr)
__clone(flags flags[clone_flags], sp buffer[in]) pid
fork() pid
__vfork14() pid
vfork() pid
posix_spawn(pid pid, path ptr[in, string], file_actions ptr[in, posix_spawn_file_actions], attrp ptr[in, posix_spawnattr], argv ptr[in, array[string]], envp ptr[in, array[string]]) pid

pollfd {
	fd	fd
	events	flags[pollfd_events, int16]
	revents	const[0, int16]
}

timespec {
	sec	intptr
	nsec	intptr
}

timeval {
	sec	intptr
	usec	intptr
}

itimerval {
	interv	timeval
	value	timeval
}

# TODO: fd_set needs to be a separate type
fd_set {
	mask0	int64
	mask1	int64
	mask2	int64
	mask3	int64
	mask4	int64
	mask5	int64
	mask6	int64
	mask7	int64
}

rusage {
	utime	timeval
	stime	timeval
	maxrss	intptr
	ixrss	intptr
	idrss	intptr
	isrss	intptr
	minflt	intptr
	majflt	intptr
	nswap	intptr
	inblock	intptr
	oublock	intptr
	msgsnd	intptr
	msgrcv	intptr
	signals	intptr
	nvcsw	intptr
	nivcsw	intptr
}

rlimit {
	soft	intptr
	hard	intptr
}

flock {
	type	flags[flock_type, int16]
	whence	flags[seek_whence, int16]
	start	intptr
	len	intptr
	pid	pid
}

linger {
	onoff	int32
	linger	int32
}

ucred {
	pid	pid
	uid	uid
	gid	gid
}

posix_spawn_file_actions {
	size	int32
	len	int32
	fae	ptr[in, posix_spawn_file_actions_entry]
}

posix_spawn_file_actions_entry [
	open	posix_spawn_file_actions_entry_t[FAE_OPEN, fd, open_t]
	dup	posix_spawn_file_actions_entry_t[FAE_DUP2, fd, dup2_t]
	close	posix_spawn_file_actions_entry_t[FAE_CLOSE, fd, void]
]

type posix_spawn_file_actions_entry_t[ACTION, FILEDES, DATA] {
	fae_action	const[ACTION, int32]
	fae_filedes	FILEDES
	fae_data	DATA
}

open_t {
	path	ptr[in, string]
	oflag	int32
	mode	int32
}

dup2_t {
	newfildes	int32
}

posix_spawnattr {
	sa_flags	flags[sa_flags, int16]
	sa_pgroup	pid
	sa_schedparam	sched_param
	sa_schedpolicy	int32
	sa_sigdefault	sigset_t
	sa_sigmask	sigset_t
}

sched_param {
	sched_priority	int32
}

pollfd_events = POLLIN, POLLPRI, POLLOUT, POLLERR, POLLHUP, POLLNVAL, POLLRDNORM, POLLRDBAND, POLLWRNORM, POLLWRBAND
mknod_mode = S_IFREG, S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
at_flags = AT_SYMLINK_NOFOLLOW, AT_SYMLINK_FOLLOW
linkat_flags = AT_SYMLINK_FOLLOW
unlinkat_flags = 0, AT_REMOVEDIR
flock_op = LOCK_SH, LOCK_EX, LOCK_UN, LOCK_NB
faccessat_flags = AT_EACCESS, AT_SYMLINK_NOFOLLOW
rusage_who = RUSAGE_SELF, RUSAGE_CHILDREN
rlimit_type = RLIMIT_AS, RLIMIT_CORE, RLIMIT_CPU, RLIMIT_DATA, RLIMIT_FSIZE, RLIMIT_MEMLOCK, RLIMIT_NOFILE, RLIMIT_NPROC, RLIMIT_RSS, RLIMIT_STACK, RLIMIT_NTHR, RLIMIT_STACK
clock_id = CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID, CLOCK_VIRTUAL, CLOCK_PROF
getitimer_which = ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF, ITIMER_MONOTONIC
wait_options = WALLSIG, WALTSIG, WCONTINUED, WEXITED, WNOHANG, WNOZOMBIE, WSTOPPED, WTRAPPED, WUNTRACED
timer_flags = 0, TIMER_ABSTIME
utimensat_flags = 0, AT_SYMLINK_NOFOLLOW
fcntl_dupfd = F_DUPFD, F_DUPFD_CLOEXEC
fcntl_getflags = F_GETFD, F_GETFL
fcntl_lock = F_SETLK, F_SETLKW, F_GETLK
fcntl_flags = FD_CLOEXEC
fcntl_status = O_APPEND, O_ASYNC, O_NONBLOCK, O_DSYNC, O_RSYNC, O_ALT_IO, O_DIRECT, O_NOSIGPIPE
flock_type = F_RDLCK, F_WRLCK, F_UNLCK
clone_flags = CLONE_CSIGNAL, CLONE_VM, CLONE_FS, CLONE_FILES, CLONE_SIGHAND, CLONE_PID, CLONE_PTRACE, CLONE_VFORK
sa_flags = SA_ONSTACK, SA_RESTART, SA_RESETHAND, SA_NODEFER, SA_NOCLDSTOP, SA_NOCLDWAIT, SA_SIGINFO, SA_NOKERNINFO, SA_ALLBITS
