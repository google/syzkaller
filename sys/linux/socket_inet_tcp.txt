# Copyright 2017 syzkaller project authors. All rights reserved.
# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

# AF_INET and AF_INET6: TCP support

include <asm/ioctls.h>
include <linux/tcp.h>
include <net/tcp.h>
include <uapi/linux/sockios.h>
include <uapi/linux/tls.h>

resource sock_tcp[sock_in]

tcp_pair {
	f0	sock_tcp
	f1	sock_tcp
}

socket$inet_tcp(domain const[AF_INET], type const[SOCK_STREAM], proto const[0]) sock_tcp
socketpair$inet_tcp(domain const[AF_INET], type const[SOCK_STREAM], proto const[0], fds ptr[out, tcp_pair])

# From interface point of view SMC sockets seem to be the same as TCP.
socket$inet_smc(domain const[AF_SMC], type const[SOCK_STREAM], proto const[0]) sock_tcp
socketpair$inet_smc(domain const[AF_SMC], type const[SOCK_STREAM], proto const[0], fds ptr[out, tcp_pair])

resource sock_tcp6[sock_in6]

tcp6_pair {
	f0	sock_tcp6
	f1	sock_tcp6
}

socket$inet6_tcp(domain const[AF_INET6], type const[SOCK_STREAM], proto const[0]) sock_tcp6
socketpair$inet6_tcp(domain const[AF_INET6], type const[SOCK_STREAM], proto const[0], fds ptr[out, tcp6_pair])

# Generic TCP socket options

tcp_option_types_int = TCP_NODELAY, TCP_MAXSEG, TCP_CORK, TCP_KEEPIDLE, TCP_KEEPINTVL, TCP_KEEPCNT, TCP_SYNCNT, TCP_LINGER2, TCP_DEFER_ACCEPT, TCP_WINDOW_CLAMP, TCP_QUICKACK, TCP_THIN_LINEAR_TIMEOUTS, TCP_THIN_DUPACK, TCP_USER_TIMEOUT, TCP_REPAIR, TCP_REPAIR_QUEUE, TCP_QUEUE_SEQ, TCP_FASTOPEN, TCP_FASTOPEN_CONNECT, TCP_FASTOPEN_NO_COOKIE, TCP_TIMESTAMP, TCP_NOTSENT_LOWAT, TCP_SAVE_SYN, TCP_INQ

tcp_option_types_buf = TCP_INFO, TCP_CONGESTION, TCP_ULP, TCP_MD5SIG, TCP_REPAIR_OPTIONS, TCP_CC_INFO, TCP_SAVED_SYN, TCP_REPAIR_WINDOW, TCP_FASTOPEN_KEY

getsockopt$inet_tcp_int(fd sock_tcp, level const[IPPROTO_TCP], optname flags[tcp_option_types_int], optval ptr[out, int32], optlen ptr[inout, len[optval, int32]])
setsockopt$inet_tcp_int(fd sock_tcp, level const[IPPROTO_TCP], optname flags[tcp_option_types_int], optval ptr[in, int32], optlen len[optval])
getsockopt$inet6_tcp_int(fd sock_tcp6, level const[IPPROTO_TCP], optname flags[tcp_option_types_int], optval ptr[out, int32], optlen ptr[inout, len[optval, int32]])
setsockopt$inet6_tcp_int(fd sock_tcp6, level const[IPPROTO_TCP], optname flags[tcp_option_types_int], optval ptr[in, int32], optlen len[optval])

getsockopt$inet_tcp_buf(fd sock_tcp, level const[IPPROTO_TCP], optname flags[tcp_option_types_buf], optval buffer[out], optlen ptr[inout, len[optval, int32]])
setsockopt$inet_tcp_buf(fd sock_tcp, level const[IPPROTO_TCP], optname flags[tcp_option_types_buf], optval buffer[in], optlen len[optval])
getsockopt$inet6_tcp_buf(fd sock_tcp6, level const[IPPROTO_TCP], optname flags[tcp_option_types_buf], optval buffer[out], optlen ptr[inout, len[optval, int32]])
setsockopt$inet6_tcp_buf(fd sock_tcp6, level const[IPPROTO_TCP], optname flags[tcp_option_types_buf], optval buffer[in], optlen len[optval])

getsockopt$inet_tcp_TCP_ZEROCOPY_RECEIVE(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_ZEROCOPY_RECEIVE], optval ptr[in, tcp_zerocopy_receive], optlen ptr[inout, len[optval, int32]])
getsockopt$inet6_tcp_TCP_ZEROCOPY_RECEIVE(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_ZEROCOPY_RECEIVE], optval ptr[in, tcp_zerocopy_receive], optlen ptr[inout, len[optval, int32]])

tcp_zerocopy_receive {
# TODO: this is 8-byte pointer that must be page-aligned, need vma64.
	address		vma
	length		len[address, int32]
	recv_skip_hint	const[0, int32]
}

# Specific TCP socket options

# TODO: use TCP_SAVED_SYN to extract sequence numbers

setsockopt$inet_tcp_TCP_CONGESTION(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_CONGESTION], optval ptr[in, string[tcp_congestion_control_alg_names]], optlen len[optval])
setsockopt$inet6_tcp_TCP_CONGESTION(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_CONGESTION], optval ptr[in, string[tcp_congestion_control_alg_names]], optlen len[optval])

setsockopt$inet_tcp_TCP_ULP(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_ULP], optval ptr[in, string[tcp_ulp_names]], optlen len[optval])
setsockopt$inet6_tcp_TCP_ULP(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_ULP], optval ptr[in, string[tcp_ulp_names]], optlen len[optval])

setsockopt$inet_tcp_TCP_MD5SIG(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_MD5SIG], optval ptr[in, tcp_md5sig], optlen len[optval])
setsockopt$inet6_tcp_TCP_MD5SIG(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_MD5SIG], optval ptr[in, tcp_md5sig], optlen len[optval])

setsockopt$inet_tcp_TCP_REPAIR_OPTIONS(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_REPAIR_OPTIONS], optval ptr[in, array[tcp_repair_opt]], optlen len[optval])
setsockopt$inet6_tcp_TCP_REPAIR_OPTIONS(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_REPAIR_OPTIONS], optval ptr[in, array[tcp_repair_opt]], optlen len[optval])

getsockopt$inet_tcp_TCP_REPAIR_WINDOW(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_REPAIR_WINDOW], optval ptr[out, tcp_repair_window], optlen ptr[inout, len[optval, int32]])
setsockopt$inet_tcp_TCP_REPAIR_WINDOW(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_REPAIR_WINDOW], optval ptr[in, tcp_repair_window], optlen len[optval])
getsockopt$inet6_tcp_TCP_REPAIR_WINDOW(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_REPAIR_WINDOW], optval ptr[out, tcp_repair_window], optlen ptr[inout, len[optval, int32]])
setsockopt$inet6_tcp_TCP_REPAIR_WINDOW(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_REPAIR_WINDOW], optval ptr[in, tcp_repair_window], optlen len[optval])

setsockopt$inet_tcp_TCP_FASTOPEN_KEY(fd sock_tcp, level const[IPPROTO_TCP], optname const[TCP_FASTOPEN_KEY], optval ptr[in, array[int8, TCP_FASTOPEN_KEY_LENGTH]], optlen len[optval])
setsockopt$inet6_tcp_TCP_FASTOPEN_KEY(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TCP_FASTOPEN_KEY], optval ptr[in, array[int8, TCP_FASTOPEN_KEY_LENGTH]], optlen len[optval])

setsockopt$inet_tcp_TLS_TX(fd sock_tcp, level const[IPPROTO_TCP], optname const[TLS_TX], optval ptr[in, tls_crypto_info], optlen len[optval])
setsockopt$inet6_tcp_TLS_TX(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TLS_TX], optval ptr[in, tls_crypto_info], optlen len[optval])
setsockopt$inet_tcp_TLS_RX(fd sock_tcp, level const[IPPROTO_TCP], optname const[TLS_RX], optval ptr[in, tls_crypto_info], optlen len[optval])
setsockopt$inet6_tcp_TLS_RX(fd sock_tcp6, level const[IPPROTO_TCP], optname const[TLS_RX], optval ptr[in, tls_crypto_info], optlen len[optval])

tcp_congestion_control_alg_names = "cubic", "reno", "bic", "cdg", "dctcp", "westwood", "highspeed", "hybla", "htcp", "vegas", "nv", "veno", "scalable", "lp", "yeah", "illinois", "dctcp-reno", "bbr"

tcp_ulp_names = "tls"

tcp_repair_window {
	snd_wl1		int32
	snd_wnd		int32
	max_window	int32
	rcv_wnd		int32
	rcv_wup		int32
}

sockaddr_storage_tcp [
	in	sockaddr_storage_in
	in6	sockaddr_storage_in6
]

tcp_md5sig {
	tcpm_addr	sockaddr_storage_tcp
	__tcpm_pad1	int16
	tcpm_keylen	int16
	__tcpm_pad2	int32
	tcpm_key	array[int8, TCP_MD5SIG_MAXKEYLEN]
}

tcp_repair_opt_codes = TCPOPT_MSS, TCPOPT_WINDOW, TCPOPT_SACK_PERM, TCPOPT_TIMESTAMP

tcp_repair_opt {
	opt_code	flags[tcp_repair_opt_codes, int32]
	opt_val		int32
}

tls_crypto_info {
	version		const[TLS_1_2_VERSION, int16]
	cipher_type	const[TLS_CIPHER_AES_GCM_128, int16]
}

# TCP ioctls

# http://lxr.free-electrons.com/ident?i=tcp_ioctl

ioctl$sock_inet_tcp_SIOCINQ(fd sock_tcp, cmd const[SIOCINQ], arg ptr[out, int32])
ioctl$sock_inet6_tcp_SIOCINQ(fd sock_tcp6, cmd const[SIOCINQ], arg ptr[out, int32])

ioctl$sock_inet_tcp_SIOCATMARK(fd sock_tcp, cmd const[SIOCATMARK], arg ptr[out, int32])
ioctl$sock_inet6_tcp_SIOCATMARK(fd sock_tcp6, cmd const[SIOCATMARK], arg ptr[out, int32])

ioctl$sock_inet_tcp_SIOCOUTQ(fd sock_tcp, cmd const[SIOCOUTQ], arg ptr[out, int32])
ioctl$sock_inet6_tcp_SIOCOUTQ(fd sock_tcp6, cmd const[SIOCOUTQ], arg ptr[out, int32])

ioctl$sock_inet_tcp_SIOCOUTQNSD(fd sock_tcp, cmd const[SIOCOUTQNSD], arg ptr[out, int32])
ioctl$sock_inet6_tcp_SIOCOUTQNSD(fd sock_tcp6, cmd const[SIOCOUTQNSD], arg ptr[out, int32])
