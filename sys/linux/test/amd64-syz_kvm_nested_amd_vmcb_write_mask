#
# requires: arch=amd64 -threaded
#
r0 = openat$kvm(0, &AUTO='/dev/kvm\x00', 0x0, 0x0)
r1 = ioctl$KVM_CREATE_VM(r0, AUTO, 0x0)
r2 = syz_kvm_setup_syzos_vm$x86(r1, &(0x7f0000c00000/0x400000)=nil)

# Create a nested AMD VM that performs HLT and INVD to test vmcb_write_mask.
# This is the AMD equivalent of the amd64-syz_kvm_nested_vmwrite_mask test.
# 1. L2 executes HLT -> exit to L1 (HLT is intercepted by default).
# 2. L1 disables HLT intercept via vmcb_write_mask.
# 3. L1 resumes L2.
# 4. L2 executes HLT (no L2->L1 exit), causing an L1->L0 KVM_EXIT_HLT.
# 5. L0 resumes L1, which resumes L2.
# 6. L2 executes INVD -> exit to L1.
#
# The HLT intercept bit is bit 24 in the VMCB's intercept vector 3 (offset 0xC).
# We unset this bit (0x1000000).
#
r3 = syz_kvm_add_vcpu$x86(r2, &AUTO={0x0, &AUTO=[@enable_nested={AUTO, AUTO, 0x0}, @nested_create_vm={AUTO, AUTO, 0x0}, @nested_load_code={AUTO, AUTO, {0x0, "f40f08"}}, @nested_vmlaunch={AUTO, AUTO, 0x0}, @nested_amd_vmcb_write_mask={AUTO, AUTO, {0x0, @control_area=0xc, 0x0, 0x1000000, 0x0}}, @nested_vmresume={AUTO, AUTO, 0x0}], AUTO})
r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)

# L2 VM executes HLT. Exit reason is mapped to 0xe2e20001.
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
syz_kvm_assert_syzos_uexit$x86(r3, r5, 0xe2e20001)

# L1 disables HLT intercept and resumes L2. L2 executes HLT, causing KVM_EXIT_HLT (0x5) from L1 to L0.
# This confirms that the vmcb_write_mask command was successful.
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
syz_kvm_assert_syzos_kvm_exit$x86(r5, 0x5)

# After resuming, L2 executes INVD. Exit reason is mapped to 0xe2e20002.
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
syz_kvm_assert_syzos_uexit$x86(r3, r5, 0xe2e20002)

# guest_main should finish with guest_uexit(-1).
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
syz_kvm_assert_syzos_uexit$x86(r3, r5, 0xffffffffffffffff)
