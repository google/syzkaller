#
# requires: arch=riscv64 -threaded
#

r0 = openat$kvm(0, &AUTO='/dev/kvm\x00', 0x0, 0x0)
r1 = ioctl$KVM_CREATE_VM(r0, AUTO, 0x0)
r2 = syz_kvm_setup_syzos_vm$riscv64(r1, &(0x7f0000c00000/0x400000)=nil)

# Perform two uexits. The first one is done via a code blob:
#       lui   a0, 0x40000
#       addi  a0, a0, 0x100        # a0 = RISCV64_ADDR_UEXIT
#       sd    zero, 0(a0)
#       ret
# The second uexit is done via a syzos API command that sets uexit exit code to 0xaaaa.
#
r3 = syz_kvm_add_vcpu$riscv64(r2, &AUTO={0x0, &AUTO=[@code={AUTO, AUTO, {"370500401305051023300500", 0x00008067}}, @uexit={AUTO, AUTO, 0xaaaa}], AUTO}, 0x0, 0x0)

r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)

# Run till the first uexit.
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
syz_kvm_assert_syzos_uexit$riscv64(r3, r5, 0x0)
# Run till the second uexit.
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
syz_kvm_assert_syzos_uexit$riscv64(r3, r5, 0xaaaa)
# Run till the end of guest_main(). 0xffffffffffffffff is UEXIT_END.
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
# Ensure that exit reason is KVM_EXIT_MMIO and uexit code is UEXIT_END.
#
syz_kvm_assert_syzos_kvm_exit$riscv64(r5, 0x6)
syz_kvm_assert_syzos_uexit$riscv64(r3, r5, 0xffffffffffffffff)
