# requires: arch=amd64 -threaded
#
r0 = openat$kvm(0, &AUTO='/dev/kvm\x00', 0x0, 0x0)
r1 = ioctl$KVM_CREATE_VM(r0, AUTO, 0x0)
r2 = syz_kvm_setup_syzos_vm$x86(r1, &(0x7f0000c00000/0x400000)=nil)

# Create a nested VM that executes a SYZOS uexit payload.
#
r3 = syz_kvm_add_vcpu$x86(r2, &AUTO={0x0, &AUTO=[@enable_nested={AUTO, AUTO, 0x0}, @nested_create_vm={AUTO, AUTO, 0x0}, @nested_load_syzos={AUTO, AUTO, {0x0, 0x10, [@uexit={AUTO, AUTO, 0xFACEFEED}]}}, @nested_vmlaunch={AUTO, AUTO, 0x0}], AUTO})
r4 = ioctl$KVM_GET_VCPU_MMAP_SIZE(r0, AUTO)
r5 = mmap$KVM_VCPU(&(0x7f0000009000/0x1000)=nil, r4, 0x3, 0x1, r3, 0x0)

# Run VCPU. L2 should start, execute uexit(0xFACEFEED).
# L1 intercepts this, adds nesting level 1 to the top byte, and re-throws to L0.
# Expected value: 0x01 (Level) << 56 | 0xFACEFEED = 0x01000000FACEFEED
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
syz_kvm_assert_syzos_uexit$x86(r3, r5, 0x01000000FACEFEED)

# guest_main should finish with guest_uexit(-1).
# L1 executes this directly, so nesting level is 0.
# Expected value: 0x00 << 56 | -1 = 0xFFFFFFFFFFFFFFFF
#
ioctl$KVM_RUN(r3, AUTO, 0x0)
syz_kvm_assert_syzos_uexit$x86(r3, r5, 0xffffffffffffffff)
