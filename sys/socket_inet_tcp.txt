# Copyright 2017 syzkaller project authors. All rights reserved.
# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

# AF_INET and AF_INET6: TCP support

include <linux/tcp.h>

resource sock_tcp[sock]

socket$tcp(domain const[AF_INET], type const[SOCK_STREAM], proto const[0]) sock_tcp
socketpair$tcp(domain const[AF_INET], type const[SOCK_STREAM], proto const[0], fds ptr[out, tcp_pair])
accept$tcp(fd sock_tcp, peer ptr[out, sockaddr_in, opt], peerlen ptr[inout, len[peer, int32]]) sock_tcp
accept4$tcp(fd sock_tcp, peer ptr[out, sockaddr_in, opt], peerlen ptr[inout, len[peer, int32]], flags flags[accept_flags]) sock_tcp
bind$tcp(fd sock_tcp, addr ptr[in, sockaddr_in], addrlen len[addr])
connect$tcp(fd sock_tcp, addr ptr[in, sockaddr_in], addrlen len[addr])
sendto$tcp(fd sock_tcp, buf buffer[in], len len[buf], f flags[send_flags], addr ptr[in, sockaddr_in, opt], addrlen len[addr])
recvfrom$tcp(fd sock_tcp, buf buffer[out], len len[buf], f flags[recv_flags], addr ptr[in, sockaddr_in, opt], addrlen len[addr])
getsockname$tcp(fd sock_tcp, addr ptr[out, sockaddr_in], addrlen ptr[inout, len[addr, int32]])
getpeername$tcp(fd sock_tcp, peer ptr[out, sockaddr_in], peerlen ptr[inout, len[peer, int32]])

tcp_pair {
	f0	sock_tcp
	f1	sock_tcp
}

resource sock_tcp6[sock]

socket$tcp6(domain const[AF_INET6], type const[SOCK_STREAM], proto const[0]) sock_tcp6
socketpair$tcp6(domain const[AF_INET6], type const[SOCK_STREAM], proto const[0], fds ptr[out, tcp6_pair])
accept$tcp6(fd sock_tcp6, peer ptr[out, sockaddr_in6, opt], peerlen ptr[inout, len[peer, int32]]) sock_tcp6
accept4$tcp6(fd sock_tcp6, peer ptr[out, sockaddr_in6, opt], peerlen ptr[inout, len[peer, int32]], flags flags[accept_flags]) sock_tcp6
bind$tcp6(fd sock_tcp6, addr ptr[in, sockaddr_in6], addrlen len[addr])
connect$tcp6(fd sock_tcp6, addr ptr[in, sockaddr_in6], addrlen len[addr])
sendto$tcp6(fd sock_tcp6, buf buffer[in], len len[buf], f flags[send_flags], addr ptr[in, sockaddr_in6, opt], addrlen len[addr])
recvfrom$tcp6(fd sock_tcp6, buf buffer[out], len len[buf], f flags[recv_flags], addr ptr[in, sockaddr_in6, opt], addrlen len[addr])
getsockname$tcp6(fd sock_tcp6, addr ptr[out, sockaddr_in6], addrlen ptr[inout, len[addr, int32]])
getpeername$tcp6(fd sock_tcp6, peer ptr[out, sockaddr_in6], peerlen ptr[inout, len[peer, int32]])

tcp6_pair {
	f0	sock_tcp6
	f1	sock_tcp6
}

sockopt_opt_tcp_int = TCP_CORK, TCP_DEFER_ACCEPT, TCP_KEEPCNT, TCP_KEEPIDLE, TCP_KEEPINTVL, TCP_LINGER2, TCP_MAXSEG, TCP_NODELAY, TCP_QUICKACK, TCP_SYNCNT, TCP_WINDOW_CLAMP

getsockopt$tcp_int(fd sock, level const[IPPROTO_TCP], optname flags[sockopt_opt_tcp_int], optval ptr[out, int32], optlen ptr[inout, len[optval, int32]])
setsockopt$tcp_int(fd sock, level const[IPPROTO_TCP], optname flags[sockopt_opt_tcp_int], optval ptr[in, int32], optlen len[optval])
getsockopt$tcp_buf(fd sock, level const[IPPROTO_TCP], optname const[TCP_INFO], optval buffer[out], optlen ptr[inout, len[optval, int32]])
setsockopt$tcp_buf(fd sock, level const[IPPROTO_TCP], optname const[TCP_INFO], optval buffer[in], optlen len[optval])
