// Copyright 2015/2016 syzkaller project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	. "github.com/google/syzkaller/sysparser"
)

var (
	flagV = flag.Int("v", 0, "verbosity")
)

func main() {
	flag.Parse()

	inputFiles, err := filepath.Glob("sys/*\\.txt")
	if err != nil {
		failf("failed to find input files: %v", err)
	}
	var r io.Reader = bytes.NewReader(nil)
	for _, f := range inputFiles {
		inf, err := os.Open(f)
		logf(1, "Load descriptions from file %v", f)
		if err != nil {
			failf("failed to open input file: %v", err)
		}
		defer inf.Close()
		r = io.MultiReader(r, bufio.NewReader(inf))
	}

	logf(1, "Parse system call descriptions")
	desc := Parse(r)

	consts := make(map[string]map[string]uint64)
	for _, arch := range archs {
		logf(0, "generating %v...", arch.Name)
		consts[arch.Name] = readConsts(arch.Name)

		unsupported := make(map[string]bool)
		archFlags := make(map[string][]string)
		for f, vals := range desc.Flags {
			var archVals []string
			for _, val := range vals {
				if isIdentifier(val) {
					if v, ok := consts[arch.Name][val]; ok {
						archVals = append(archVals, fmt.Sprint(v))
					} else {
						if !unsupported[val] {
							unsupported[val] = true
							logf(0, "unsupported flag: %v", val)
						}
					}
				} else {
					archVals = append(archVals, val)
				}
			}
			archFlags[f] = archVals
		}

		sysFile := filepath.Join("sys", "sys_"+arch.Name+".go")
		logf(1, "Generate code to init system call data in %v", sysFile)
		out := new(bytes.Buffer)
		archDesc := *desc
		archDesc.Flags = archFlags
		generate(arch.Name, &archDesc, consts[arch.Name], out)
		writeSource(sysFile, out.Bytes())
		logf(0, "")
	}

	generateExecutorSyscalls(desc.Syscalls, consts)
}

func readConsts(arch string) map[string]uint64 {
	constFiles, err := filepath.Glob("sys/*_" + arch + ".const")
	if err != nil {
		failf("failed to find const files: %v", err)
	}
	consts := make(map[string]uint64)
	for _, fname := range constFiles {
		f, err := os.Open(fname)
		if err != nil {
			failf("failed to open const file: %v", err)
		}
		defer f.Close()
		s := bufio.NewScanner(f)
		for s.Scan() {
			line := s.Text()
			if line == "" || line[0] == '#' {
				continue
			}
			eq := strings.IndexByte(line, '=')
			if eq == -1 {
				failf("malformed const file %v: no '=' in '%v'", fname, line)
			}
			name := strings.TrimSpace(line[:eq])
			val, err := strconv.ParseUint(strings.TrimSpace(line[eq+1:]), 0, 64)
			if err != nil {
				failf("malformed const file %v: bad value in '%v'", fname, line)
			}
			if old, ok := consts[name]; ok && old != val {
				failf("const %v has different values for %v: %v vs %v", name, arch, old, val)
			}
			consts[name] = val
		}
		if err := s.Err(); err != nil {
			failf("failed to read const file: %v", err)
		}
	}
	for name, nr := range syzkalls {
		consts["__NR_"+name] = nr
	}
	return consts
}

var skipCurrentSyscall string

func skipSyscall(why string) {
	if skipCurrentSyscall != "" {
		skipCurrentSyscall = why
	}
}

func generate(arch string, desc *Description, consts map[string]uint64, out io.Writer) {
	unsupported := make(map[string]bool)

	fmt.Fprintf(out, "// AUTOGENERATED FILE\n")
	fmt.Fprintf(out, "package sys\n\n")

	fmt.Fprintf(out, "var Resources = map[string]*ResourceDesc{\n")
	var resArray ResourceArray
	for _, res := range desc.Resources {
		resArray = append(resArray, res)
	}
	sort.Sort(resArray)
	for _, res := range resArray {
		underlying := ""
		name := res.Name
		kind := []string{name}
		var values []string
	loop:
		for {
			var values1 []string
			for _, v := range res.Values {
				if v1, ok := consts[v]; ok {
					values1 = append(values1, fmt.Sprint(v1))
				} else if !isIdentifier(v) {
					values1 = append(values1, v)
				}
			}
			values = append(values1, values...)
			switch res.Base {
			case "int8", "int16", "int32", "int64", "intptr":
				underlying = res.Base
				break loop
			default:
				if _, ok := desc.Resources[res.Base]; !ok {
					failf("resource '%v' has unknown parent resource '%v'", name, res.Base)
				}
				kind = append([]string{res.Base}, kind...)
				res = desc.Resources[res.Base]
			}
		}
		fmt.Fprintf(out, "\"%v\": &ResourceDesc{Name: \"%v\", Type: ", name, name)
		generateArg("resource-type", underlying, nil, desc, consts, true, true, out)
		fmt.Fprintf(out, ", Kind: []string{")
		for i, k := range kind {
			if i != 0 {
				fmt.Fprintf(out, ", ")
			}
			fmt.Fprintf(out, "\"%v\"", k)
		}
		fmt.Fprintf(out, "}, Values: []uintptr{")
		if len(values) == 0 {
			values = append(values, "0")
		}
		for i, v := range values {
			if i != 0 {
				fmt.Fprintf(out, ", ")
			}
			fmt.Fprintf(out, "%v", v)
		}
		fmt.Fprintf(out, "}},\n")
	}
	fmt.Fprintf(out, "}\n")

	fmt.Fprintf(out, "func initCalls() {\n")
	for _, s := range desc.Syscalls {
		logf(4, "    generate population code for %v", s.Name)
		skipCurrentSyscall = ""
		syscallNR := -1
		if nr, ok := consts["__NR_"+s.CallName]; ok {
			syscallNR = int(nr)
		} else {
			if !unsupported[s.CallName] {
				unsupported[s.CallName] = true
				logf(0, "unsupported syscall: %v", s.CallName)
			}
		}
		fmt.Fprintf(out, "func() { Calls = append(Calls, &Call{Name: \"%v\", CallName: \"%v\"", s.Name, s.CallName)
		if len(s.Ret) != 0 {
			fmt.Fprintf(out, ", Ret: ")
			generateArg("ret", s.Ret[0], s.Ret[1:], desc, consts, true, false, out)
		}
		fmt.Fprintf(out, ", Args: []Type{")
		for i, a := range s.Args {
			if i != 0 {
				fmt.Fprintf(out, ", ")
			}
			logf(5, "      generate description for arg %v", i)
			generateArg(a[0], a[1], a[2:], desc, consts, true, false, out)
		}
		if skipCurrentSyscall != "" {
			logf(0, "unsupported syscall: %v due to %v", s.Name, skipCurrentSyscall)
			syscallNR = -1
		}
		fmt.Fprintf(out, "}, NR: %v})}()\n", syscallNR)
	}
	fmt.Fprintf(out, "}\n\n")

	var constArr []NameValue
	for name, val := range consts {
		constArr = append(constArr, NameValue{name, val})
	}
	sort.Sort(NameValueArray(constArr))

	fmt.Fprintf(out, "const (\n")
	for _, nv := range constArr {
		fmt.Fprintf(out, "%v = %v\n", nv.name, nv.val)
	}
	fmt.Fprintf(out, ")\n")
}

func generateArg(
	name, typ string,
	a []string,
	desc *Description,
	consts map[string]uint64,
	isArg, isField bool,
	out io.Writer) {
	name = "\"" + name + "\""
	opt := false
	for i, v := range a {
		if v == "opt" {
			opt = true
			copy(a[i:], a[i+1:])
			a = a[:len(a)-1]
			break
		}
	}
	common := func() string {
		return fmt.Sprintf("TypeCommon: TypeCommon{TypeName: %v, IsOptional: %v}", name, opt)
	}
	canBeArg := false
	switch typ {
	case "fileoff":
		canBeArg = true
		var size uint64
		if isField {
			if want := 2; len(a) != want {
				failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
			}
			size = typeToSize(a[1])
		} else {
			if want := 1; len(a) != want {
				failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
			}
		}
		fmt.Fprintf(out, "FileoffType{%v, File: \"%v\", TypeSize: %v}", common(), a[0], size)
	case "buffer":
		canBeArg = true
		if want := 1; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		commonHdr := common()
		opt = false
		fmt.Fprintf(out, "PtrType{%v, Dir: %v, Type: BufferType{%v, Kind: BufferBlob}}", commonHdr, fmtDir(a[0]), common())
	case "string":
		canBeArg = true
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		commonHdr := common()
		opt = false
		fmt.Fprintf(out, "PtrType{%v, Dir: %v, Type: BufferType{%v, Kind: BufferString}}", commonHdr, fmtDir("in"), common())
	case "filesystem":
		canBeArg = true
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		commonHdr := common()
		opt = false
		fmt.Fprintf(out, "PtrType{%v, Dir: %v, Type: BufferType{%v, Kind: BufferFilesystem}}", commonHdr, fmtDir("in"), common())
	case "sockaddr":
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "BufferType{%v, Kind: BufferSockaddr}", common())
	case "salg_type":
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "BufferType{%v, Kind: BufferAlgType}", common())
	case "salg_name":
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "BufferType{%v, Kind: BufferAlgName}", common())
	case "vma":
		canBeArg = true
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "VmaType{%v}", common())
	case "len", "bytesize":
		canBeArg = true
		var size uint64
		if isField {
			if want := 2; len(a) != want {
				failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
			}
			size = typeToSize(a[1])
		} else {
			if want := 1; len(a) != want {
				failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
			}
		}
		fmt.Fprintf(out, "LenType{%v, Buf: \"%v\", TypeSize: %v, ByteSize: %v}", common(), a[0], size, typ == "bytesize")
	case "flags":
		canBeArg = true
		var size uint64
		if isField {
			if want := 2; len(a) != want {
				failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
			}
			size = typeToSize(a[1])
		} else {
			if want := 1; len(a) != want {
				failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
			}
		}
		vals, ok := desc.Flags[a[0]]
		if !ok {
			failf("unknown flag %v", a[0])
		}
		if len(vals) == 0 {
			fmt.Fprintf(out, "IntType{%v, TypeSize: %v}", common(), size)
		} else {
			fmt.Fprintf(out, "FlagsType{%v, TypeSize: %v, Vals: []uintptr{%v}}", common(), size, strings.Join(vals, ","))
		}
	case "const":
		canBeArg = true
		var size uint64
		if isField {
			if want := 2; len(a) != want {
				failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
			}
			size = typeToSize(a[1])
		} else {
			if want := 1; len(a) != want {
				failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
			}
		}
		val := a[0]
		if v, ok := consts[a[0]]; ok {
			val = fmt.Sprint(v)
		} else if isIdentifier(a[0]) {
			// This is an identifier for which we don't have a value for this arch.
			// Skip this syscall on this arch.
			val = "0"
			skipSyscall(fmt.Sprintf("missing const %v", a[0]))
		}
		fmt.Fprintf(out, "ConstType{%v, TypeSize: %v, Val: uintptr(%v)}", common(), size, val)
	case "strconst":
		canBeArg = true
		if want := 1; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "PtrType{%v, Dir: %v, Type: StrConstType{%v, Val: \"%v\"}}", common(), fmtDir("in"), common(), a[0]+"\\x00")
	case "int8", "int16", "int32", "int64", "intptr":
		canBeArg = true
		switch len(a) {
		case 0:
			fmt.Fprintf(out, "IntType{%v, TypeSize: %v}", common(), typeToSize(typ))
		case 1:
			var lo, hi int64
			if _, err := fmt.Sscanf(a[0], "%d:%d", &lo, &hi); err != nil {
				failf("failed to parse int range: %v (%v)", a[0], err)
			}
			if lo >= hi {
				failf("bad int range: %v", a[0])
			}
			fmt.Fprintf(out, "IntType{%v, TypeSize: %v, Kind: IntRange, RangeBegin: %v, RangeEnd: %v}", common(), typeToSize(typ), lo, hi)
		default:
			failf("wrong number of arguments for %v arg %v, want 0 or 1, got %v", typ, name, len(a))
		}
	case "signalno":
		canBeArg = true
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "IntType{%v, TypeSize: 4, Kind: IntSignalno}", common())
	case "in_addr":
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "IntType{%v, TypeSize: 4, Kind: IntInaddr}", common())
	case "in_port":
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "IntType{%v, TypeSize: 2, Kind: IntInport}", common())
	case "filename":
		canBeArg = true
		if want := 0; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		commonHdr := common()
		opt = false
		fmt.Fprintf(out, "PtrType{%v, Dir: DirIn, Type: FilenameType{%v}}", commonHdr, common())
	case "array":
		want := 1
		if len(a) == 2 {
			want = 2
		}
		if len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		sz := "0"
		if len(a) == 2 {
			sz = a[1]
			if v, ok := consts[sz]; ok {
				sz = fmt.Sprint(v)
			}
		}
		fmt.Fprintf(out, "ArrayType{%v, Type: %v, Len: %v}", common(), generateType(a[0], desc, consts), sz)
	case "ptr":
		canBeArg = true
		if want := 2; len(a) != want {
			failf("wrong number of arguments for %v arg %v, want %v, got %v", typ, name, want, len(a))
		}
		fmt.Fprintf(out, "PtrType{%v, Type: %v, Dir: %v}", common(), generateType(a[1], desc, consts), fmtDir(a[0]))
	default:
		if strings.HasPrefix(typ, "unnamed") {
			if inner, ok := desc.Unnamed[typ]; ok {
				generateArg("", inner[0], inner[1:], desc, consts, false, isField, out)
				return
			}
			failf("unknown unnamed type '%v'", typ)
		}
		if str, ok := desc.Structs[typ]; ok {
			if len(a) != 0 {
				failf("struct '%v' has args", typ)
			}
			typ := "StructType"
			fields := "Fields"
			if str.IsUnion {
				typ = "UnionType"
				fields = "Options"
			}
			packed := ""
			if str.Packed {
				packed = ", packed: true"
			}
			varlen := ""
			if str.Varlen {
				varlen = ", varlen: true"
			}
			align := ""
			if str.Align != 0 {
				align = fmt.Sprintf(", align: %v", str.Align)
			}
			fmt.Fprintf(out, "%v{TypeCommon: TypeCommon{TypeName: \"%v\", IsOptional: %v} %v %v %v, %v: []Type{", typ, str.Name, false, packed, align, varlen, fields)
			for i, a := range str.Flds {
				if i != 0 {
					fmt.Fprintf(out, ", ")
				}
				generateArg(a[0], a[1], a[2:], desc, consts, false, true, out)
			}
			fmt.Fprintf(out, "}}")
		} else if _, ok := desc.Resources[typ]; ok {
			if len(a) != 0 {
				failf("resource '%v' has args", typ)
			}
			fmt.Fprintf(out, "ResourceType{%v, Desc: Resources[\"%v\"]}", common(), typ)
			return
		} else {
			failf("unknown arg type \"%v\" for %v", typ, name)
		}
	}
	if isArg && !canBeArg {
		failf("%v %v can't be syscall argument/return", name, typ)
	}
}

func generateType(typ string, desc *Description, consts map[string]uint64) string {
	buf := new(bytes.Buffer)
	generateArg("", typ, nil, desc, consts, false, true, buf)
	return buf.String()
}

func fmtDir(s string) string {
	switch s {
	case "in":
		return "DirIn"
	case "out":
		return "DirOut"
	case "inout":
		return "DirInOut"
	default:
		failf("bad direction %v", s)
		return ""
	}
}

func typeToSize(typ string) uint64 {
	switch typ {
	case "int8", "int16", "int32", "int64", "intptr":
	default:
		failf("unknown type %v", typ)
	}
	sz := int64(64) // TODO: assume that pointer is 8 bytes for now
	if typ != "intptr" {
		sz, _ = strconv.ParseInt(typ[3:], 10, 64)
	}
	return uint64(sz / 8)
}

func isIdentifier(s string) bool {
	for i, c := range s {
		if c == '_' || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || i > 0 && (c >= '0' && c <= '9') {
			continue
		}
		return false
	}
	return true
}

func writeSource(file string, data []byte) {
	src, err := format.Source(data)
	if err != nil {
		fmt.Printf("%s\n", data)
		failf("failed to format output: %v", err)
	}
	writeFile(file, src)
}

func writeFile(file string, data []byte) {
	outf, err := os.Create(file)
	if err != nil {
		failf("failed to create output file: %v", err)
	}
	defer outf.Close()
	outf.Write(data)
}

type NameValue struct {
	name string
	val  uint64
}

type NameValueArray []NameValue

func (a NameValueArray) Len() int           { return len(a) }
func (a NameValueArray) Less(i, j int) bool { return a[i].name < a[j].name }
func (a NameValueArray) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

type ResourceArray []Resource

func (a ResourceArray) Len() int           { return len(a) }
func (a ResourceArray) Less(i, j int) bool { return a[i].Name < a[j].Name }
func (a ResourceArray) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

func failf(msg string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, msg+"\n", args...)
	os.Exit(1)
}

func logf(v int, msg string, args ...interface{}) {
	if *flagV >= v {
		fmt.Fprintf(os.Stderr, msg+"\n", args...)
	}
}
